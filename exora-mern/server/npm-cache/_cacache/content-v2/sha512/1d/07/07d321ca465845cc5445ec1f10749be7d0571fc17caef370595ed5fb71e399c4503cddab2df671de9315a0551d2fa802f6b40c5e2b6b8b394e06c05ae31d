{"_id":"mssql","_rev":"447-b4e66c4d017d7b9a089642853244f238","name":"mssql","description":"Microsoft SQL Server client for Node.js.","dist-tags":{"legacy":"7.3.5","release-9.3.x":"9.3.0","release-9.x":"9.3.0","release-9.2.x":"9.2.1","latest":"11.0.1"},"versions":{"0.2.0":{"name":"mssql","version":"0.2.0","keywords":["database","mssql","sql"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.2.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"b3e17a45434063d3b6cebcad43311d46a263a36c","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.2.0.tgz","integrity":"sha512-Uw620Hr4G/uWsibg7acVDdkDxTVgod8oLw8Lo3R9i8KRVqDPRqhML5ROkVuoAJlzOc5PYgqxV1TUqEqmzURxVg==","signatures":[{"sig":"MEUCIGSG/6EDVVf+j1cjqxiJcwbnW3ix/f8FjROSFvGfIx+uAiEAvRWyFU1BUXdwGoB9m/GNyucEHULfaO0LZ5UFmyc5bfQ=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":"*"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.5","description":"MSSQL database connector for NodeJS","directories":{},"dependencies":{"tedious":"*","tedious-connection-pool":"*"},"devDependencies":{"mocha":"*"}},"0.2.1":{"name":"mssql","version":"0.2.1","keywords":["database","mssql","sql"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.2.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"1d34e73e807cd7a0e93dbcfdc3d262b7aac70e6d","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.2.1.tgz","integrity":"sha512-oASzfndDMymSqJaHeRAiLqmlBl3aXrvUyBjCgVFBB+QkN+aVKi8nnMKpzyIFaZV1qaLxS0K+/6kb1yBKNlIkKQ==","signatures":[{"sig":"MEUCIQCBsARcp3foclc4YNovRIrS76r/Cp4H7baD8JHiAOwvCwIgbOyk1S8RDY1tPSf/nDaWd9vXgVj96ZUH7uR/n0EjTSI=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":"*"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.5","description":"MSSQL database connector for NodeJS","directories":{},"dependencies":{"tedious":"*","tedious-connection-pool":"*"},"devDependencies":{"mocha":"*"}},"0.2.2":{"name":"mssql","version":"0.2.2","keywords":["database","mssql","sql"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.2.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"d1f9c6e76eb659370f4ff2129fba923c8a556ebf","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.2.2.tgz","integrity":"sha512-kAWKAGTqQGP8jc6ncMlxly8K3n66SfC4VCLEBYC4fZVcocb9w5Dt/+acoSYDTLgEuQqN2kVam9bM1sGQztrKmg==","signatures":[{"sig":"MEQCIAIvj81i1hsEUG/gH6ecS2jTs5JFVn9ywrBXqjCDF2J7AiAB+w5DLhlHFG0I0aw5XC/agv38nIKs8lrBnb/wdCOQpA==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.5","description":"MSSQL database connector for NodeJS","directories":{},"dependencies":{"tedious":">=0.1.5","tedious-connection-pool":">=0.1.1"},"devDependencies":{"mocha":"*","coffee-script":"*"}},"0.2.3":{"name":"mssql","version":"0.2.3","keywords":["database","mssql","sql"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.2.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"6d673d17082956bea7cc6f4c981be32cc273515f","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.2.3.tgz","integrity":"sha512-ji3dCM5suN7e4dhF4vpZu3HuymLu/bluvkCrINOBsO3nm4OqE12jOZpLVzgoHhpqIe0dTWp7U8B9bWaf53LB4Q==","signatures":[{"sig":"MEUCIQDvP83/LKndvUTRS2YFvTg+lu8ZFjaI06+Pi9cRxxJ/RgIgaTUyYno3cMtI5+3ugRUN4cYXDzOq4LMWyhtRhCx/Ba8=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.5","description":"MSSQL database connector for NodeJS","directories":{},"dependencies":{"tedious":">=0.1.5","tedious-connection-pool":">=0.1.1"},"devDependencies":{"mocha":"*","coffee-script":"*"}},"0.2.4":{"name":"mssql","version":"0.2.4","keywords":["database","mssql","sql"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.2.4","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"c63cc0dec0fda4aa15ff42e852943e459f524eda","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.2.4.tgz","integrity":"sha512-jTTf+ytemOD8LR1dUtCLDh6FuwU1nK96xhSdyz2Peu+HMpIiXepW+8bVGf5FyZmJe5drN1najkQxF1p/c+97WA==","signatures":[{"sig":"MEUCIQDAs6nzy43CHwNhqoMxyXW83X+MU0Cuy+xYvdCl27eklgIga3xj9uXOIuxqEDrLM7F8Kni5xsT6Vt9WtZZ+aKXulK4=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --compilers coffee:coffee-script --reporter spec"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.5","description":"MSSQL database connector for NodeJS","directories":{},"dependencies":{"tedious":">=0.1.5","tedious-connection-pool":">=0.1.1"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.2.5":{"name":"mssql","version":"0.2.5","keywords":["database","mssql","sql"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.2.5","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"956eea74b7ce6698fb958d5c765803a3abdd09ae","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.2.5.tgz","integrity":"sha512-GLwa+5bISYwHj9bIiUk70iNlU7H/ibQT1GlqSXA+JGA9LbMN0z5XmpE9G8U+rPQD8nKMhj13DJLThdM3xiHRgg==","signatures":[{"sig":"MEYCIQCs1VnsnHhk4/4JpEZ3XBYf36oHauhPhFl3LJos2rddWQIhAPmjm+E8qFZaqbNA8AAJAUAFgMg6WALQMnrzTIHzuCdU","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --compilers coffee:coffee-script --reporter spec"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.5","description":"MSSQL database connector for NodeJS","directories":{},"dependencies":{"tedious":">=0.1.5","tedious-connection-pool":">=0.1.1"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.3.0":{"name":"mssql","version":"0.3.0","keywords":["database","mssql","sql","msnodesql","sqlserver"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.3.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"d0cb34166305b4964ee191abd6853895bfb81230","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.3.0.tgz","integrity":"sha512-OwisuPKYcswUt72xTCJVBg4P03MVXrXBZKSluQckwWu71cQ4TQm59ZN6Lgmc6VL2W9tM5aLWyAFDFLfA7VmRCQ==","signatures":[{"sig":"MEUCIBIiy7Wi4Na4m1FgrUt5p6zMvA9p+nBbJN5Ec83YwRw6AiEA4nImOaA3LRTnbfHnZ8pMpYROYbOaTgPfMhDlCoT/+8A=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --compilers coffee:coffee-script --reporter spec"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.5","description":"An easy-to-use MSSQL database connector for NodeJS.","directories":{},"dependencies":{"tedious":">=0.1.5","tedious-connection-pool":">=0.1.1"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.3.1":{"name":"mssql","version":"0.3.1","keywords":["database","mssql","sql","msnodesql","sqlserver"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.3.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"4e69201320238de2c0a20148d65ac1473bfad87f","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.3.1.tgz","integrity":"sha512-E8V9V1+hCu+KhRxb69RSk5CP3Nkk6seQv8PCmfnoiVS1gwTC5p6aH73+2nwS8zrVKi7lXRlaN2YFCSNpZzPH+A==","signatures":[{"sig":"MEUCIQCPyR/BMee0j8bWPFe9jQDhwaJjqctQ8D905fQTP1T1hwIgEJ/Dqkfzq/++GwLGd4r4ysOWlySbllYs15Ebpi9Y+ak=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --compilers coffee:coffee-script --reporter spec"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.5","description":"An easy-to-use MSSQL database connector for NodeJS.","directories":{},"dependencies":{"tedious":">=0.1.5","tedious-connection-pool":">=0.1.1"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.3.2":{"name":"mssql","version":"0.3.2","keywords":["database","mssql","sql","msnodesql","sqlserver"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.3.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"035c9e477cc23526d8bed1a2798567f517bed99b","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.3.2.tgz","integrity":"sha512-fIspUCPgNlYF6l33X7OPDKBoQdzEbBa/BfYw8ixLQ6bhCJbHDXgEDcxjctItwdwsZdDSdINZ4/z2zI3DnwTShg==","signatures":[{"sig":"MEYCIQDfsG7j+IGIbGTK/0zOs27wcr5E59Tqed5WuNZhQd0lYAIhAO/UqO6B+BP06pbpmOi5PC2wKCO7t70tOyCCQQ6t+gyB","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --compilers coffee:coffee-script --reporter spec"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.5","description":"An easy-to-use MSSQL database connector for NodeJS.","directories":{},"dependencies":{"tedious":">=0.1.5","tedious-connection-pool":">=0.1.1"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.3.3":{"name":"mssql","version":"0.3.3","keywords":["database","mssql","sql","msnodesql","sqlserver"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.3.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"bd04a14415f43701c0f3807e4343c7b57194323f","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.3.3.tgz","integrity":"sha512-SQ6kai2lZwPosVS0ypqxEsdWdGy9mxgrHcVRbzODGeVUgBgzV6iKMTeOvwCmTGKDgVOI8iXkWLVXMBVf8YH6Rw==","signatures":[{"sig":"MEYCIQCwgHo0QOqqExAOOxqh6vyl0ayta4IvlR6RI75EF4oWCgIhANtecGjBVtX/POsxJlh4Xd91FjMtHf3VuCFa5PzdO25V","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --compilers coffee:coffee-script --reporter spec"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.5","description":"An easy-to-use MSSQL database connector for NodeJS.","directories":{},"dependencies":{"tedious":">=0.1.5","tedious-connection-pool":">=0.1.1"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.3.4":{"name":"mssql","version":"0.3.4","keywords":["database","mssql","sql","msnodesql","sqlserver"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.3.4","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"07a81b5a33da0e0ee8b2a00908a07f91a85df804","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.3.4.tgz","integrity":"sha512-vvQ84jJMcpqwu1ZKuhRUP2xHLbtpTnPH716BoOw7ZftcZ8Eys5NaOEJIJoFJndWANzfrtJ8UlVjZR0Bb5GiCDg==","signatures":[{"sig":"MEUCIAm+4daP8m4nmZ5Ms8No5XcWYk+QBza+6UWUsBihTpwZAiEAnycwNS66aZ1FZQbQcMG7VFDN7M8T5jI45HRNadv8KFg=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --compilers coffee:coffee-script --reporter spec"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.5","description":"An easy-to-use MSSQL database connector for NodeJS.","directories":{},"dependencies":{"tedious":">=0.1.5","tedious-connection-pool":">=0.1.1"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.4.0":{"name":"mssql","version":"0.4.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.4.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"c179673544cc0ca4462f5dd35991b96c42d4e8a0","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.4.0.tgz","integrity":"sha512-dHvjgaye/56CzhAZTJ+2/nIEdW52SNGA/+u+9IBo9nfS0EUzLvhyrXuiatDJwZrJ3C0sB2GVqyJ0PT63J+gZ5Q==","signatures":[{"sig":"MEUCIALnmgeY0pwpIWX79mkayalUeRdE/Ar+Csy2sZitHgEeAiEA7Mx7BiMp+D5m4MCUnKMqtMpHMNE0GD2VSD7JU4F9eJg=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --compilers coffee:coffee-script --reporter spec"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.11","description":"An easy-to-use MSSQL database connector for NodeJS.","directories":{},"dependencies":{"tedious":">=0.1.5","generic-pool":">=2.0.4"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.4.1":{"name":"mssql","version":"0.4.1","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.4.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"8801773712d38329e895473ce871047fbea79a30","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.4.1.tgz","integrity":"sha512-LIQbQAQ/hs9duQoSegV1Rsc5lvVf3j+hbMFmMRI3/dxARS5hXRpJEGj0/NhUJBvNIXKCrFV1NJkFk6pTq5eXvA==","signatures":[{"sig":"MEUCID4cir8EH/PHaWSnLacU6adCqehV11MQsLtlP6g0KhabAiEAySSk1bb8e3medwZktdzsdWlDRFRuDZU0fP9+3zsKdys=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --compilers coffee:coffee-script --reporter spec"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.11","description":"An easy-to-use MSSQL database connector for NodeJS.","directories":{},"dependencies":{"tedious":">=0.1.5","generic-pool":">=2.0.4"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.4.2":{"name":"mssql","version":"0.4.2","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.4.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"1be9f6d0521095a725716715a24d905f74988231","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.4.2.tgz","integrity":"sha512-gwtbo9uvcT7uiq8t7KIO4Fow8lKDPjIM6wffvP48R+T1V/goWsDtycn6u65X+qi2nhkxjociU3GSpcu9sBU8WQ==","signatures":[{"sig":"MEUCIQCWQKaFDwhduRjMalrCzfGOMAmY4CLzVTWei/LQby1fEgIgEdXEQ/WuIf9Nyiah/HN9Kl5I4sg4jDLNuysaOhgSXlI=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --compilers coffee:coffee-script --reporter spec"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.11","description":"An easy-to-use MSSQL database connector for NodeJS.","directories":{},"dependencies":{"tedious":">=0.1.5","generic-pool":">=2.0.4"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.4.3":{"name":"mssql","version":"0.4.3","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.4.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"85aa57e8a9ab49fdba8de5476a0150241b4ddda2","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.4.3.tgz","integrity":"sha512-6j0MmJ4eMAweFIFSz0MmBUYXRYjWWCwEK1Ixi5ZYgaR7qQUDw/KzF0gZ1Ane58YtMvdrn64LTPUt3TcHfKMf2A==","signatures":[{"sig":"MEUCIQDEiqlk76fz+4FtjxM6GwZjg4Vs2RFGfYguSdfhGFN76QIgIdLm1qhhXzo6T5xnoCRyzd7uCbGd/ugb7Kc5tAsw20s=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --compilers coffee:coffee-script --reporter spec"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.22","description":"An easy-to-use MSSQL database connector for NodeJS.","directories":{},"dependencies":{"tedious":">=0.1.5","generic-pool":">=2.0.4"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.4.4":{"name":"mssql","version":"0.4.4","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver"],"author":{"url":"http://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.4.4","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"6919dc177a21f879ff920284735da0e1c00adee6","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.4.4.tgz","integrity":"sha512-vceglVmP+1OywOMXiQsuehRXrZhboK6ffj+Mxz3O9z43hNLTOPbK74w4r6XLRNNXKeGz6LYg1FkTBeKoxn2nWw==","signatures":[{"sig":"MEYCIQCpYHYhzuDEcX7dsP61YI57/+mWrVmcrqnXbyMkrJw1kQIhAK0yNXJnv64fq107y6udJpLRZVlMbBZgrr0mH/neV1NJ","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --compilers coffee:coffee-script --reporter spec"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.22","description":"An easy-to-use MSSQL database connector for NodeJS.","directories":{},"dependencies":{"tedious":">=0.1.5","generic-pool":">=2.0.4"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.4.5":{"name":"mssql","version":"0.4.5","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.4.5","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"c58816eb069636941f094e3b4b2f1ad6af7f74d0","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.4.5.tgz","integrity":"sha512-qf5Np8NDI/iKcwaOvaXTWwZZ+daY7jsusT58G6rN2dJvkNYzLC00tPrZKH5I6uMhjuRSd9Vlj6oPqkwR/XgRaw==","signatures":[{"sig":"MEQCIHl5ZhfrsnehI7OedMud4yvCWZ15/A0dQgrCHLHR7lsgAiB0/TVxKkH9CJTIuMCEyBKD29TPgUpzMQhma7bAtT6ThA==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.22","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":">=0.1.5","generic-pool":">=2.0.4"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.5.0":{"name":"mssql","version":"0.5.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.5.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"d549f5d7c911aaae6a2de8da400ddc655b9614ac","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.5.0.tgz","integrity":"sha512-yfXk0MJihK3RD9TVUKOazdi9CtFcq9b+NahS+MXWKtiU8SchnypFKGurLnLntOAn5PA/iMcRw1l3upgNSjskwg==","signatures":[{"sig":"MEQCIGsSZobQQj71Rw7hDmqn+c0H07C/1C7m7CxrOWYuwXbdAiBNLGohyIQaGLc84vN2SBmeTt49Hf85AAaGGZPDp2yvIA==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha --expose-gc","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.3.22","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":">=0.1.5","generic-pool":">=2.0.4"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.6.2"}},"0.5.1":{"name":"mssql","version":"0.5.1","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.5.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"3b9821b9f1138a58c33dd3ca3f0785b086c10830","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.5.1.tgz","integrity":"sha512-HCKxPr4nDFzLfIALPrL5YcRPVRKc892uQ65RTDu7NDmBaPyNXpSvH/fSn48fUgsc90VRIlQSccdPPjj+L9AsCQ==","signatures":[{"sig":"MEUCIB8KFRWgeUEsg8ZCgLPolGFPaHWdcgDRz8yKhgNaNdsiAiEAsQ/vKfOAsWM+GFQz9B5PK+FgKOi2uvij8LEXHP3fPS0=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.6","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":">=0.2.1","generic-pool":">=2.0.4"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.7.1"}},"0.5.2":{"name":"mssql","version":"0.5.2","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.5.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"ac4e0f90fc5071642364c337e9223ac783698216","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.5.2.tgz","integrity":"sha512-3V7dn4W5jSbgAnUxugyC9MYnY1c+qZiSaiuOLyL/RR4OwqAGuYLP/Z0xPX64ISmABCYt7M/J1ZrjfZwMrCnEMg==","signatures":[{"sig":"MEUCIQCVc9SxMAF5gpmak3K3vC13ZLz/9nvH0uFJbb8n2p1dTAIgBidZ6N98+hmFVk6CXeWtxaTIf1Q0/6MwphpithHCSnI=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.6","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":">=0.2.1","generic-pool":">=2.0.4"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.7.1"}},"0.5.3":{"name":"mssql","version":"0.5.3","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.5.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"470fc7e05ecf03824de804022128cb0743f87d5d","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.5.3.tgz","integrity":"sha512-25qFstszWSGR+s9zTmulBj9clgvQ89YRSMhvol2md5Yo6vhFU+eP90HoWU1rzYhRdsl7rhiMiOE0x6BGjnKJ2w==","signatures":[{"sig":"MEUCIQCkdoSSOdxAEGQtvKWiy/0/V8o/kcdcv7HhUMB6tEGZbAIgQhnNAP1s4dj5Rqr2cYxNu6/BJy/rLFMi5ZY6/rl6+Y4=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","engines":{"node":">=0.6"},"scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.6","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":">=0.2.1","generic-pool":">=2.0.4"},"devDependencies":{"mocha":">=1.12.0","coffee-script":">=1.7.1"}},"0.5.4":{"name":"mssql","version":"0.5.4","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.5.4","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"281014a976ae92e1fd5997b297639bd8595cd1c2","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.5.4.tgz","integrity":"sha512-xbeyiCFcCgzD/7uaWryYdKJBTr0ujIHVB9XYsFiS8L9zyd36z7AfYa7z/czdL+k5IXcO31T4GvrWnDwaokCg9Q==","signatures":[{"sig":"MEQCIG37hecBRd15+FCXxOw/cdBpkd7DR8uMJvspa2xeLKRLAiBH+7u0/wo6PSGOiXYEHyUKiVKg30wpaxI3MNaMV5bsow==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"281014a976ae92e1fd5997b297639bd8595cd1c2","engines":{"node":">=0.6"},"scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.9","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"0.2.4","generic-pool":"2.0.4"},"devDependencies":{"mocha":"1.12.0","coffee-script":"1.7.1"}},"0.5.5":{"name":"mssql","version":"0.5.5","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.5.5","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"8e9bb51d15040ef63a84597ea740159fd64c832b","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.5.5.tgz","integrity":"sha512-khx6u4lTIVbkYLJ4YE+R6B1jiYVA1poOOGVi3GxXBF/qvtlLmYASFSOJtx/+R5/feyEJH4n3Yvlzw/mgovEftw==","signatures":[{"sig":"MEQCIBynujW7L6RzU+y7PhjMN4x8Mf6uGPzIFFH9KIM6RVHyAiBJ76/a6Uzs792HMB9fS/n8mVbLPtBEKFeV9g9jfyDtZQ==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"8e9bb51d15040ef63a84597ea740159fd64c832b","engines":{"node":">=0.6"},"scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.9","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"0.2.4","generic-pool":"2.0.4"},"devDependencies":{"mocha":"1.12.0","coffee-script":"1.7.1"}},"0.6.0":{"name":"mssql","version":"0.6.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.6.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"dc6078e0c2c1b7e2c1f3ef8ec7c61ce21882af55","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.6.0.tgz","integrity":"sha512-MbnN8v5WroJwVFFDi2pIMjLk69D7zHS8XRU+yQ7PAgd7XUtH0JGy7ReUpXGPTZnwt4q+Rr5wNM7PK5RWXvzv7g==","signatures":[{"sig":"MEUCIQDtCiYrjeTNCsqrDPQQa+mkCAv4HcZbWVBa2mj3/R1FpAIgP8w9N/T0VDiYfdI/LKR1h6yKO801XjspIfVqcyahRKM=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"dc6078e0c2c1b7e2c1f3ef8ec7c61ce21882af55","engines":{"node":">=0.6"},"gitHead":"47ac31610a6bbbbf64c5b120c2d2edc035b03b37","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.14","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"^1.0.0","generic-pool":"^2.0.4"},"devDependencies":{"mocha":"^1.12.0","coffee-script":"^1.7.1"}},"0.6.1":{"name":"mssql","version":"0.6.1","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.6.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"cd7af3c3dbece73e99a52b5853b67a3529eec416","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.6.1.tgz","integrity":"sha512-l/9dSkw9ogGyaLxN8FYnz0252S0Yl/vZlXoDvTAm+v+B2dY19tfhIIYGXTHuLrs4XgSnzrNYsQgzX3FdtSpIOg==","signatures":[{"sig":"MEUCIAiv2SCA1b9iu8NEz9XUn96OtIGhKTtSiYIWhyRUwwvxAiEA/51k1w4x5zxIy2liGaiFRtOrEqfWez9hM7pD7yDRzVw=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"cd7af3c3dbece73e99a52b5853b67a3529eec416","engines":{"node":">=0.6"},"gitHead":"1922557f09a4b944f0d110ab8458da75218c1885","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.14","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"^1.0.0","generic-pool":"^2.0.4"},"devDependencies":{"mocha":"^1.12.0","coffee-script":"^1.7.1"}},"0.6.2":{"name":"mssql","version":"0.6.2","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@0.6.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"b52019337e75e5bec320f8441f61b507c5f74073","tarball":"https://registry.npmjs.org/mssql/-/mssql-0.6.2.tgz","integrity":"sha512-PcFBqXTRAB3jKlrYtZej6AUy3P4ttYE6fqN1apS7KbQNbn4npsyXup9XHG80j+Vj15LJGmLb3XhViolmqEyzmg==","signatures":[{"sig":"MEUCIQDyyDOBzdjRn0PD5J+7q4FBslRUTpQJg/H8H+nulvJ11gIgEPKx+uieUWl7HBTWwSX9WE7jkGWjxdJstdp/Ego5nlQ=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"b52019337e75e5bec320f8441f61b507c5f74073","engines":{"node":">=0.6"},"gitHead":"ab21a41e4a12db2b33e2ec29699c40bd0a640994","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.14","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"^1.0.0","generic-pool":"^2.0.4"},"devDependencies":{"mocha":"^1.12.0","coffee-script":"^1.7.1"}},"1.0.0":{"name":"mssql","version":"1.0.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@1.0.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"e700fb3bfbf9a7da3d9f0eda388f047110307854","tarball":"https://registry.npmjs.org/mssql/-/mssql-1.0.0.tgz","integrity":"sha512-LuquBtF5H/5If6eZFafbKzr4f4kCaedK1aR4DpTXauFn4iqk+Iv/YSBoSFyoUTmeon+8n08HgPr4pLpVefAa2Q==","signatures":[{"sig":"MEUCIQDM3jYXviOlwyYw//xeCrV5/i30kas6naoOgxcCgOEcbgIgcqKpP0OjFD1rOjanif1UrGqmCvNZniTZh4qrFQInwVE=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"e700fb3bfbf9a7da3d9f0eda388f047110307854","engines":{"node":">=0.6"},"scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.9","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"^1.0.0","generic-pool":"^2.0.4"},"devDependencies":{"mocha":"^1.12.0","coffee-script":"^1.7.1"}},"1.0.1":{"name":"mssql","version":"1.0.1","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@1.0.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"b8a80d3416d11956972c4646b6eba74019b2a13a","tarball":"https://registry.npmjs.org/mssql/-/mssql-1.0.1.tgz","integrity":"sha512-Udx3Q+ip9HLR3DPbpe09DlT9nrEbdlTgoYlS7VzBP95GyFz2eVMJB15nqAk9yp1digUjR8jNMQ+zTSr6exYKxw==","signatures":[{"sig":"MEYCIQCJe97jpd4ex0DYPstCHQOZHjdjzdu3c+Xid/9Uwj0zxAIhAPLo+wGBVVfmHC5B516dNEQ+boc7duYzbCtgWAsGDXh6","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"b8a80d3416d11956972c4646b6eba74019b2a13a","engines":{"node":">=0.6"},"gitHead":"ee702c8a4a76c86e3472345ac0d4bfff5ff9f7b1","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.14","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"^1.0.0","generic-pool":"^2.0.4"},"devDependencies":{"mocha":"^1.12.0","coffee-script":"^1.7.1"}},"1.0.2":{"name":"mssql","version":"1.0.2","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@1.0.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"ce24142be736dfdc9b1a0286c3f9fcff2a55994e","tarball":"https://registry.npmjs.org/mssql/-/mssql-1.0.2.tgz","integrity":"sha512-6ndJS+Egv5bSbHF5SN9QjOpl+mKGDuwSguqNOkwt/NE2AqCPdgaEShfW350H8Ygwwvlt1Syz+IrvKLeAl/2Mfg==","signatures":[{"sig":"MEQCIFDv/GfxskUb2IhyrEy6b+yPxLsmjzJ9CxUsnjoeznT7AiACwE/MBwbkJ2R+iycBn3vf/OUw1AaY8LKMwI9jo/o5Pw==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"ce24142be736dfdc9b1a0286c3f9fcff2a55994e","engines":{"node":">=0.6"},"gitHead":"05090b0341b2c7e5732fc45159b6efd1c147ff0c","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.14","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"^1.0.0","generic-pool":"^2.0.4"},"devDependencies":{"mocha":"^1.12.0","coffee-script":"^1.7.1"}},"1.1.0":{"name":"mssql","version":"1.1.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@1.1.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"ae4dcd1b9e15d895c308bc9b12218f5f0b46350e","tarball":"https://registry.npmjs.org/mssql/-/mssql-1.1.0.tgz","integrity":"sha512-CNqZ+1TQdmxTazRmOF++xy9BGtosmbJAiUgt3Qth1YvD9ppFRZcninE6X0FhD7MSf66R/8tIdBcH4GjULp+KZw==","signatures":[{"sig":"MEUCIQD/FBT3nyJ4ifPurRyj83K7oXprk44FzOaz1i0JwTQ4GgIgPiMRZSXdCxxiaQwQkvjAd9vLC8IcbKGx5mOk/oFD2Ak=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"ae4dcd1b9e15d895c308bc9b12218f5f0b46350e","engines":{"node":">=0.6"},"gitHead":"98756a80b1de8841c4c91e622f7b7a05769eb159","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.14","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"^1.1.0","generic-pool":"^2.0.4"},"devDependencies":{"mocha":"^1.12.0","coffee-script":"^1.7.1"}},"1.1.1":{"name":"mssql","version":"1.1.1","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@1.1.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"8742725e195541397e6a6397e64abe6307935fab","tarball":"https://registry.npmjs.org/mssql/-/mssql-1.1.1.tgz","integrity":"sha512-gGE6TYn9oFf8F3ym19rHfOHVKUgE0QRnKC3lpE3hX91I0LcYKC4fmv+uecjmuKSxFuTUvZ+sdXIVrGQR/XDZhA==","signatures":[{"sig":"MEUCIDRP/Gcbf7jRnwJw4FcQSa8Xedr6JmtGqZVRN1fYi5ioAiEAj3s+LRbCLshtrt8h0EdSl43WpV/txezpsm7wVMkmNtE=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"8742725e195541397e6a6397e64abe6307935fab","engines":{"node":">=0.6"},"gitHead":"90f85afba02c10ae52b9e4c53405392285ff3158","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.14","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"^1.2.2","generic-pool":"^2.0.4"},"devDependencies":{"mocha":"^1.12.0","coffee-script":"^1.7.1"}},"1.2.0":{"name":"mssql","version":"1.2.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@1.2.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"fd6fac31dc0aaff83ac4dc4d826803d0239369c1","tarball":"https://registry.npmjs.org/mssql/-/mssql-1.2.0.tgz","integrity":"sha512-n2JtukBMKnCfW1MuG4FOvcBHNOkznqhe1Ijm33PGxGvyUMiy9cBdVwFr0kMOvEWqxVFVJ5Kt4g/lfoLbRNF4cw==","signatures":[{"sig":"MEUCIFq86CmR7PirrmdoS5AOd7kGvti5pV33hAoKW60JrcLMAiEAzNhgLFP6T8Ux6lNc9+oxbNFdQx4/oJFrQ529Ou8V9sM=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"fd6fac31dc0aaff83ac4dc4d826803d0239369c1","engines":{"node":">=0.6"},"gitHead":"28fd960b56bb732d59943c7ea472254f74ead940","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.23","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"^1.4.0","generic-pool":"^2.0.4"},"devDependencies":{"mocha":"^1.12.0","coffee-script":"^1.7.1"}},"1.2.1":{"name":"mssql","version":"1.2.1","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@1.2.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"ee3fbf76a7055df08a931c0fb9f06bccbeb07458","tarball":"https://registry.npmjs.org/mssql/-/mssql-1.2.1.tgz","integrity":"sha512-/kOhiAGMuZOacf0Wl4kdrchyIDHCBvHL5X+uSWP/ojZiBIxZOFhGYkyEReplrg2gMzRkhSm2KQTBS7uNCcFOuw==","signatures":[{"sig":"MEQCIAlFK+qPZ1eFmYBXOCOrGx/ulDochTGqG/RWlo0VR3mrAiATPZdLOX3Z8D3W5oW2qGpwjNABbQwAMEs9ZMcJP2dS8g==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"ee3fbf76a7055df08a931c0fb9f06bccbeb07458","engines":{"node":">=0.6"},"gitHead":"a8f37b19ca50e66f63bd16c9142e230226366ffb","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.23","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"^1.5.3","generic-pool":"^2.0.4"},"devDependencies":{"mocha":"^1.12.0","coffee-script":"^1.7.1"}},"1.3.0":{"name":"mssql","version":"1.3.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@1.3.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"dist":{"shasum":"9039dbbb19c64f3bad0b69a3d1143ffc12ee8a1a","tarball":"https://registry.npmjs.org/mssql/-/mssql-1.3.0.tgz","integrity":"sha512-/Po606HOAUbuY4SuKd4obH+iSiHF3hL7kJTR+x/x/+wJ+ydniAUNskVGupOP4nwzTrgvJsSPwPmo+b/P3oj+HQ==","signatures":[{"sig":"MEQCIHHdpRWNS9K4VNxysgKREWWPsPDD2LgCUrNvBXkDq5CrAiAWmXgklIVaLUWt1kspYtSs/purDbostrZPewiw2RuMKQ==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"9039dbbb19c64f3bad0b69a3d1143ffc12ee8a1a","engines":{"node":">=0.6"},"gitHead":"f43ec24b839e331ead6d29e2cc871f477afc92e9","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"1.4.28","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"dependencies":{"tedious":"^1.7.0","generic-pool":"^2.0.4"},"devDependencies":{"mocha":"^1.12.0","coffee-script":"^1.7.1"}},"2.0.0":{"name":"mssql","version":"2.0.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@2.0.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"4f8c906903b182193390c788906751e01c7ed304","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.0.0.tgz","integrity":"sha512-gZbDdliDTU5T4zJeb1n9MPYToJfdZ4MlgcUXu3TUh7yccf+rJJ3ooxDz/ihVVQ4a6k+2K09AoeLbxuPA7kyzWw==","signatures":[{"sig":"MEUCIDfEUnCEarVbtrsWvVotjAwu70B2ohRtsFTXvf2ksmv/AiEAk1lJ3H4vA2wSmlVWqaip/u1z3+OwPUY2Cyq0unPoMEI=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"4f8c906903b182193390c788906751e01c7ed304","engines":{"node":">=0.6"},"gitHead":"5e5688401bde39ac4c2f7e3b9ab32ede6376cf05","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"2.5.1","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"1.2.0","dependencies":{"promise":"^6.1.0","tedious":"^1.10.0","generic-pool":"^2.1.1"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.0"}},"2.1.0":{"name":"mssql","version":"2.1.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@2.1.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"9f237e71a6b37fafcf2c671ef122e03f165bf446","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.1.0.tgz","integrity":"sha512-NnFqIKUi8ifxt4a0ReTIfgU0eY8KLiV53i87489K4JqbwAjWs5q7eN3pug67pKJqrkRXKBXdXr24kttJACWlgg==","signatures":[{"sig":"MEUCIQDf6Iw+dynedrs41QJ9DoGZOW2Gg2wXEXP7bcsnM2UJdQIgFqq8LbRqihKHdSV9+TRxiet98wxxrdBm0vghnik1tvo=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"9f237e71a6b37fafcf2c671ef122e03f165bf446","engines":{"node":">=0.6"},"gitHead":"156e2d2b1afff776be3c8db5f0b620014927cd0d","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"2.5.1","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"1.2.0","dependencies":{"promise":"^6.1.0","tedious":"^1.10.0","generic-pool":"^2.1.1"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.0"}},"2.1.1":{"name":"mssql","version":"2.1.1","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@2.1.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"fb2c9610d5dc0d37bbd78f50cb83dc928e501afc","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.1.1.tgz","integrity":"sha512-PMxOCP5BdXC6soIR+8IodYUlc+Gbiu0eV6fNUoLIod0kT4H5rmvV+UkseEKaW5Z0mhg3p3knxPN1+9k6yjEDDQ==","signatures":[{"sig":"MEQCIDDMP9cK9GIJx3KOvxy+EH+ZMflcPWtQFLBfE/TumrBiAiADxK1kz7x3tQMxWoOtnAfY/mFIeIR9tOhVmTgKfv/2Pg==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"fb2c9610d5dc0d37bbd78f50cb83dc928e501afc","engines":{"node":">=0.6"},"gitHead":"69e71bdb26773597bda23b17adb0a14b7d4a4d4a","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"2.5.1","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"1.2.0","dependencies":{"promise":"^6.1.0","tedious":"^1.10.0","generic-pool":"^2.1.1"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.0"}},"2.1.2":{"name":"mssql","version":"2.1.2","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@2.1.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"fc371c72c2a32eb02fad190c18c3948305c1379c","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.1.2.tgz","integrity":"sha512-chKn8q2dEOfdP0jhjBQCJMc12Ex2Xp8HG0hkrHyX+w+QfsMHyzAyZ3RTQ4nv9l+LR7QYy6/vXzn8v9INKFLRFg==","signatures":[{"sig":"MEUCIQDdiRcLP2rgYgQfIHhC4kZ08QiG6LaawF/JdgVvul1HEAIgFL3+vftvmxN8nVlixV5SkHORd3E9A6CjkS61BV8EVng=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"fc371c72c2a32eb02fad190c18c3948305c1379c","engines":{"node":">=0.6"},"gitHead":"2a91391be7cbff77cbdb281b1610f79af119833a","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"2.5.1","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"1.2.0","dependencies":{"promise":"^6.1.0","tedious":"^1.11.0","generic-pool":"^2.1.1"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.0"}},"2.1.3":{"name":"mssql","version":"2.1.3","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"_id":"mssql@2.1.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"0764d06a653960cd7e4460dcaf8f125318a6f7c3","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.1.3.tgz","integrity":"sha512-+cP7vXcQ4lpanS8RTiAVIhzj3IjkcMV61kp0uBgpHyvPxwMVj7M2C9/Gl0Yex0Da5e3Aw5C88DyELBdPEwYPxQ==","signatures":[{"sig":"MEQCIFCgN9PHcPYuNaTwNpJIZMXScHlutZwF4XyYSty4AnDBAiAwyWOs7kure6gw/WM3cUbWOdHf98PvIyJPqOvImwmHMQ==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"0764d06a653960cd7e4460dcaf8f125318a6f7c3","engines":{"node":">=0.6"},"gitHead":"63eda07acdd7ac7b659c0fab6d32936379d6f5c7","scripts":{"test":"mocha","prepublish":"coffee --compile --output ./lib ./src"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"licenses":[{"url":"http://opensource.org/licenses/mit-license.php","type":"MIT"}],"repository":{"url":"https://github.com/patriksimek/node-mssql","type":"git"},"_npmVersion":"2.7.6","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"1.2.0","dependencies":{"promise":"^7.0.1","tedious":"^1.11.0","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.0"}},"2.1.4":{"name":"mssql","version":"2.1.4","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@2.1.4","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"a958ea29b361c5ddd832162170c12f1c92b87df3","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.1.4.tgz","integrity":"sha512-FtBaKBrvfm4ZHGN4R4XaCsH1itFqhgQj7cBKgzHQw8fbUGXx6ZDhMBsJjLPjE1Kj9DrI3bc79Gw2PuGDxtwnBw==","signatures":[{"sig":"MEYCIQDMIc4wW8/WsZWlg+Z+ZWZUdL2x/03PX9Mu+GRjG+m6PwIhAKHHOe2+X0pDBB1AroTnxlnCLK4NYP3H7dWL6xH7IEkC","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"a958ea29b361c5ddd832162170c12f1c92b87df3","engines":{"node":">=0.10"},"gitHead":"bb45af4ae5d73475516b13270ecfc73e1d7e2ec2","scripts":{"test":"mocha test/unit","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.9.0","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"2.0.1","dependencies":{"promise":"^7.0.1","tedious":"^1.11.0","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"2.1.5":{"name":"mssql","version":"2.1.5","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@2.1.5","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"d391e3fcf0815a336c2b67a0bc728f35086848e8","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.1.5.tgz","integrity":"sha512-TE5LqIB1yoYaSyXAJxSHoztNBWJ+N3avcoGRk8SNc2XXlxP9O30IOosLXIzVLhLh/9up5bgMdCS9P4aYXuBiKg==","signatures":[{"sig":"MEQCIAnPILyQNmQD7Wrp26cyeUlxi0RwpDhrKOqAGxi81wFyAiADQs0+FDWHBbtCsgBS0+5opFVBygaICBKpqppilrtKwQ==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"d391e3fcf0815a336c2b67a0bc728f35086848e8","engines":{"node":">=0.10"},"gitHead":"0a4355de0030f90b7d07c5ddf59ecd267e017f41","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.9.0","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"2.0.1","dependencies":{"promise":"^7.0.1","tedious":"^1.11.0","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"2.1.6":{"name":"mssql","version":"2.1.6","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@2.1.6","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"65ecff93b6ce0103ec52b8e85729d26fd619b708","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.1.6.tgz","integrity":"sha512-AajUE6dLqFkX09uMWI9zG2xRMqSu/d1pSarC76jIoSlpBCUrJhNb2pv7qTpOBnSLZe3m/fUPFxZwQ8ZBVihJUA==","signatures":[{"sig":"MEQCIBfmJS48qW72L8Y3hUHTpn8FGI04Z0dNR/B7Jk1Nx3e8AiAo+cwX6LBw7Kdj3fKRbWzQ3NJZogmXYoYEHurK9z2Erw==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"65ecff93b6ce0103ec52b8e85729d26fd619b708","engines":{"node":">=0.10"},"gitHead":"a276f16b2f9c9de6c3c5e97a9319fa6d770f57c1","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.9.0","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"2.0.1","dependencies":{"promise":"^7.0.1","tedious":"^1.11.2","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"2.1.7":{"name":"mssql","version":"2.1.7","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@2.1.7","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"54acf1f0de6f7c5a84dfbbb05e4d3a337e046805","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.1.7.tgz","integrity":"sha512-IAZZguY94eNPVh2DXeETw6qVADxGQMFNhkbpYYX8kbYBqdhx8tFvaX7WELHBYqbFHr5gimAq446ud+xFCJiMPA==","signatures":[{"sig":"MEQCIFkHmbi4Dmk1fOab6Mvdttrj6tHzxPGox3+CHoVuBeV2AiAF+TRLEY5aOr9IlDpy+833Tp+VyVS9nl9mCDtjpxBF5w==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"54acf1f0de6f7c5a84dfbbb05e4d3a337e046805","engines":{"node":">=0.10"},"gitHead":"205a91374218b99e9fb0ead81df5c6ddfac91ed9","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.12.0","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"2.3.1","dependencies":{"promise":"^7.0.1","tedious":"1.11.4","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"2.1.8":{"name":"mssql","version":"2.1.8","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@2.1.8","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"5af92825a022c1b50cd5554e056591d8f6f50582","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.1.8.tgz","integrity":"sha512-p+cnQaXQNN5Qik9T2n0LLYplJcVjKrJl/h/0V6ufkphk81daMYEAtMshO5AJO81fIE3oAy2ZuK9w6aa5FpPE6A==","signatures":[{"sig":"MEQCIHOAF+CjMo7SAY8REoBKKGm+kZCOY6U9C8E5x64LP4TkAiAQds5fGuD9ovDjTBcgboq6MiI0aOXCDE1I1ghMVPGYmA==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"5af92825a022c1b50cd5554e056591d8f6f50582","engines":{"node":">=0.10"},"gitHead":"b64deb69dabf89739e507e94259a78da7627afe8","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.12.0","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"2.3.1","dependencies":{"promise":"^7.0.1","tedious":"~1.12.2","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"2.2.0":{"name":"mssql","version":"2.2.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@2.2.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"a4eab15d9741b459273fe996af43f93cba49959d","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.2.0.tgz","integrity":"sha512-AM/YNF2Q30I5huNNmz6NJLbH2kwO1URTjeUYeXXpbM5sh4dNCFE7vIWTXysOZuMBt4w8qmOe8o3tQKtXhHoHMg==","signatures":[{"sig":"MEQCIEUuhq8rIqGJZvZYrunbbVx55pLV767I5oa1/2458Jx4AiARCrlbwrYi6X1uKlXoJUnUnbn+WoZWXDYojB5QpPix7A==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"a4eab15d9741b459273fe996af43f93cba49959d","engines":{"node":">=0.10"},"gitHead":"e7c150c53acc2c88c2374b8b802844370cde3670","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.12.0","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"2.3.1","dependencies":{"promise":"^7.0.1","tedious":"~1.12.2","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"2.2.1":{"name":"mssql","version":"2.2.1","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@2.2.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"5f493c7566e6494d831fd5429e854bd4ffb79d69","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.2.1.tgz","integrity":"sha512-AlaoXEtmKn6B5kVO7jfRzwY6VsSvgSHQKhF9JfVe+f6i6mhMUoClLzblbv9yDIzJWNoNQSXu80gQsY8LQfTX3Q==","signatures":[{"sig":"MEYCIQCZ8pV5/oyx6mNg+wtvGYIGXD3RsNpApPjTHKJ3QWRK3gIhANbqFFxrMAVpxRoiBqy9GOk8z8st9LRUtgXYv1+UV9uw","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"5f493c7566e6494d831fd5429e854bd4ffb79d69","engines":{"node":">=0.10"},"gitHead":"e4950453da8d96b81f753ea382a7ae0f06184b18","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.13.2","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"2.5.0","dependencies":{"promise":"^7.0.1","tedious":"~1.12.3","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"2.3.0":{"name":"mssql","version":"2.3.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@2.3.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"4503468684d3bc64b12e913a98d5d4ddced9a3ff","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.3.0.tgz","integrity":"sha512-SwsY24CAZpuZKQU9ltkO4xLG8s6EUFd8ju/fg0Z4Hd5lbpLoBsyR/p7WXz1ZY7dSH8elyO/LzrYZIC1J3BDdZQ==","signatures":[{"sig":"MEQCICUgkx+GcMZrXgXB0wNE7hcdtJea4986frZJ3J3z2qGvAiBmkIZs5dv/kRjUy9ePidKM/WyZLfHuuShFZQylveW5WA==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"4503468684d3bc64b12e913a98d5d4ddced9a3ff","engines":{"node":">=0.10"},"gitHead":"ea072cb52d04f1bb423501267e943a073f960dd7","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.13.2","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"2.5.0","dependencies":{"promise":"^7.0.1","tedious":"~1.12.3","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"2.3.1":{"name":"mssql","version":"2.3.1","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@2.3.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"4c7601a410d7f4d80fb23e1574651c1c7b85df71","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.3.1.tgz","integrity":"sha512-Q/pWq5SaAtMLI5/QvoS7Z7h5j4peqk9CCDCsMjQxml2hDA88gU0j5mdeKOEMhxKaUuzB+rI4wV+X05ZSuHj3Sw==","signatures":[{"sig":"MEQCIGJQc5wbJTGomtxbkPm73GlBcDDxISzEoZIXvDG0VZnXAiBJ5ZGfNFyce2+xBPkCJVcRZd3E3hUPtCFUazyNu1tZpw==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"4c7601a410d7f4d80fb23e1574651c1c7b85df71","engines":{"node":">=0.10"},"gitHead":"552ea0518ff860466b295670e7e2b305ab603f14","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.14.3","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"4.1.0","dependencies":{"promise":"^7.0.1","tedious":"~1.12.3","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"2.3.2":{"name":"mssql","version":"2.3.2","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@2.3.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"95da6b51ed61f8cc840f67e6bb307e549efc9ba3","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.3.2.tgz","integrity":"sha512-zS0DEkWLogr/9/OmSrjej2sMr5pheRl3RMtzgWHJCJnBbTTUvPfqsoK38grw9SXYfwaCffe7eedbQt5uojhEhA==","signatures":[{"sig":"MEQCIGRa190vXIpvaF930dRdBo+ZshSRQH/L48NTiFhFoscDAiBtvlNf5AASGqI0gvjwsAIpWcoiN48cxy5t3IVl5psxpw==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"95da6b51ed61f8cc840f67e6bb307e549efc9ba3","engines":{"node":">=0.10"},"gitHead":"34b4fc78a085f32937c8e7cdd9fbb875216ab318","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.14.4","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"4.1.2","dependencies":{"promise":"^7.0.1","tedious":"~1.13.1","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"2.4.0":{"name":"mssql","version":"2.4.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@2.4.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"726d663c664fb6fbb37819083e82483bf91edb96","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.4.0.tgz","integrity":"sha512-nyBc0njJz4lPmRK+yonp0T7j8I1mZpH294q0LxwJnFGi+4W/DUy4S4VpO/riHerGb4ou4qnPrtNfizx+LVK9Lg==","signatures":[{"sig":"MEUCIQCuiV1XIdlonu0d1wfriv9m3qIbcnNkBLYsVaNS5HbiewIgVd050uZH6QanaEEN95b1UlTioQJHWvVneMD5NYMIwUI=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"726d663c664fb6fbb37819083e82483bf91edb96","engines":{"node":">=0.10"},"gitHead":"b7352775dc94b61d3721de41919786a7db553dd9","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.14.4","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"4.1.2","dependencies":{"promise":"^7.0.1","tedious":"~1.13.1","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"2.5.0":{"name":"mssql","version":"2.5.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@2.5.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"380fe178d54211aacd3af323ac19f9a7845590ef","tarball":"https://registry.npmjs.org/mssql/-/mssql-2.5.0.tgz","integrity":"sha512-crMb/kA3WkfWFUZEKrycKbSMu7t3p9hAZqKBV6lB037H9DzZd/9Ab8QBV+yCUASqEb8NSpW2bKP+2xn5wR4jCA==","signatures":[{"sig":"MEYCIQC4IK6WcwAF9QsEQi0KVTUYkG1KX0/x+vmtIxyQHqB1TwIhAJYvtnKY80w2uaq1L8xU9YqSr+V3IUqjPBTpYpW104H2","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"380fe178d54211aacd3af323ac19f9a7845590ef","engines":{"node":">=0.10"},"gitHead":"70f138fdb54ad234c7cf13c41b610003db9ea270","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.14.4","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"4.1.2","dependencies":{"promise":"^7.0.1","tedious":"~1.13.1","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"3.0.0":{"name":"mssql","version":"3.0.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@3.0.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"7ad93af90f0c06ad0946269a0c406e770871c655","tarball":"https://registry.npmjs.org/mssql/-/mssql-3.0.0.tgz","integrity":"sha512-L+TEqjfxvg1yv5dMPLngYiAukBHQV023hA/zWfsQKKcGpu2qRplAGuT3y+khPkVcMbTW9gWfreTYYRs/OH0Mlw==","signatures":[{"sig":"MEUCIDEi8Gak443ItOqK6uK0+xBCq27VTjn6ZbkNIBkEkukqAiEAtnolBwaCyRr4oa4s1vAFQot8eGrgk2fOo8PFEzfY5SM=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"7ad93af90f0c06ad0946269a0c406e770871c655","engines":{"node":">=0.10"},"gitHead":"676d448761e0f7c0fcbf4c695f577a0bf04c8988","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.14.4","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"4.1.2","dependencies":{"promise":"^7.0.1","tedious":"~1.13.1","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"}},"3.0.1":{"name":"mssql","version":"3.0.1","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@3.0.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"3fe7b73c10a3f1048c34c368f433470e8f01dfd6","tarball":"https://registry.npmjs.org/mssql/-/mssql-3.0.1.tgz","integrity":"sha512-V+CPLtV4YUqYD1nJfwFWdoxfTO0ANeKghq5Ey1tiid65dQWloPPGVKtuZXEAw3WXfCDguQpQmorqc+RhXmtHRw==","signatures":[{"sig":"MEQCIHTvS2HNVkCA7xsZmepBLEMniFUSSMXSWLmMcfdpWdDvAiBh7bUqbr2JrUm3Dpxu/Vq6HT0StOj1P6S9643/P+OOwg==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"3fe7b73c10a3f1048c34c368f433470e8f01dfd6","engines":{"node":">=0.10"},"gitHead":"0891182293a30ea148baab1d698a26b68929ecae","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.14.4","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"4.1.2","dependencies":{"promise":"^7.0.1","tedious":"~1.13.1","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql-3.0.1.tgz_1454549319874_0.6715567889623344","host":"packages-9-west.internal.npmjs.com"}},"3.1.0":{"name":"mssql","version":"3.1.0","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@3.1.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"05cd298555706c267d45700967ee120453065a44","tarball":"https://registry.npmjs.org/mssql/-/mssql-3.1.0.tgz","integrity":"sha512-wReqE5SshWwfxlHCeh1Q0upyQKLzNcfp9992c/6WbeNEBzEifpd60b8GzRPHdsrVRlja2w+UTeo2PqyipcdLHw==","signatures":[{"sig":"MEUCIEiF4YvN1x0hD1wyu5KoY1E+o3yuC9/A32jzJvURP2OiAiEA3oPTdWW4+mcjCrxx9L0VZCrGOUuLCh8EOxEXRcqokJk=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"05cd298555706c267d45700967ee120453065a44","engines":{"node":">=0.10"},"gitHead":"25f3a6f5d6775aa8cd8399cf71622819af237009","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.14.4","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"4.1.2","dependencies":{"promise":"^7.0.1","tedious":"~1.13.1","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql-3.1.0.tgz_1455402293407_0.0353520184289664","host":"packages-5-east.internal.npmjs.com"}},"3.1.1":{"name":"mssql","version":"3.1.1","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@3.1.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"26a60b2a98d99b5910e0c7cb6a89b60f3fd2c5b0","tarball":"https://registry.npmjs.org/mssql/-/mssql-3.1.1.tgz","integrity":"sha512-yfvoEOyJomzzrE1SMN67O0c1+yxlYgJuBG1JuqbI92Qqe3owdsZ5QHz9a1aDrFcr7GO/t8X43p5NKDrcNiBP6A==","signatures":[{"sig":"MEQCIGCTliP9ZYXIvMVdUiLXhmBq8nzMIKWTzbjyrYbpdNLoAiBzws7EE4l9ic51TQ8HdxtpTmF5PdIspApcrhD+cm+cxw==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"26a60b2a98d99b5910e0c7cb6a89b60f3fd2c5b0","engines":{"node":">=0.10"},"gitHead":"01d6a33024cb1197479241501ac576cd027ca465","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.14.4","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"4.1.2","dependencies":{"promise":"^7.0.1","tedious":"~1.13.1","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql-3.1.1.tgz_1456013694820_0.869314937852323","host":"packages-5-east.internal.npmjs.com"}},"3.1.2":{"name":"mssql","version":"3.1.2","keywords":["database","mssql","sql","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@3.1.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"7d38973d132a288d5560297dd3bedf29b0f0e6e7","tarball":"https://registry.npmjs.org/mssql/-/mssql-3.1.2.tgz","integrity":"sha512-ItSV6737xOyRtmAEhb9JIhbcrhiVUikR+ybnXP7y8o1hsqGAprL2EjhBut68xXGcJY6wtGUmVGRWgoZdQmUg+A==","signatures":[{"sig":"MEUCIEr+MoKbERq07LOnoRn5bKw2kBG+9RbBBZAmTlB95C/oAiEAjQB7mwwLCoIrro/h63bPBR0QOKfyGRsNBWZrvKb03HA=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"7d38973d132a288d5560297dd3bedf29b0f0e6e7","engines":{"node":">=0.10"},"gitHead":"c32b87f4fa1f46e5e8fa8dda4effc12e5570f9c4","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"2.14.4","description":"An easy-to-use MSSQL database connector for Node.js.","directories":{},"_nodeVersion":"4.1.2","dependencies":{"promise":"^7.0.1","tedious":"~1.13.1","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql-3.1.2.tgz_1457470221605_0.3447149912826717","host":"packages-12-west.internal.npmjs.com"}},"3.2.0":{"name":"mssql","version":"3.2.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@3.2.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"bdc46a9c790420be6acefdc12c06b2b089e9816e","tarball":"https://registry.npmjs.org/mssql/-/mssql-3.2.0.tgz","integrity":"sha512-BpEROWLj7lymGq28x0KROaTIhVKuhyy69fMP+YZzCq/sHvfUkEJQQaVBpnVsFnARcLh9VZEw2+4cdFzEfc0qrA==","signatures":[{"sig":"MEUCIQCOp+dBFh/aeHayGDJ5X6DMRVC0JwNhVP59AOh4qMx7EwIgThWu5NlhgMgHR4ahy5YTkHXQVyFt0wEQfM5JEoH8Ntc=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"bdc46a9c790420be6acefdc12c06b2b089e9816e","engines":{"node":">=0.10"},"gitHead":"2772b41c3edf05225120e3cd6d0d2817120c45b9","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql","test-msnodesqlv8":"mocha test/integration -g msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"3.8.3","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"4.4.0","dependencies":{"promise":"^7.0.1","tedious":"~1.14.0","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql-3.2.0.tgz_1460334241899_0.49055447638966143","host":"packages-12-west.internal.npmjs.com"}},"3.2.1":{"name":"mssql","version":"3.2.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@3.2.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"d37d754763c3b99389e4ff4e9e01da43930e816f","tarball":"https://registry.npmjs.org/mssql/-/mssql-3.2.1.tgz","integrity":"sha512-jIrp7Yx3iS0CbR0ERCwhEAMBZoa1XRFYgDA/ufBxRN8wFP/wW34MOMUVZm8xqfMD/1FY3ByY7sXO++5z8W9AJg==","signatures":[{"sig":"MEQCICYcgOAUe/Q7FHkQ2z0zkfRY1quOWncWHaGFIZGL+At1AiBeV76n6uFHtAqlztPKJry7vrgk7bm/IxkD7jH7bQ9p3Q==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"d37d754763c3b99389e4ff4e9e01da43930e816f","engines":{"node":">=0.10"},"gitHead":"fadf2cbfad4cbab9c02f604e0b4dac0661bd6c9a","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql","test-msnodesqlv8":"mocha test/integration -g msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"3.8.3","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"4.4.0","dependencies":{"promise":"^7.0.1","tedious":"~1.14.0","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql-3.2.1.tgz_1460762196220_0.3530531693249941","host":"packages-12-west.internal.npmjs.com"}},"3.3.0":{"name":"mssql","version":"3.3.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@3.3.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"b6e6337ff123e87bf8aee1e6c8344b53ca5da856","tarball":"https://registry.npmjs.org/mssql/-/mssql-3.3.0.tgz","integrity":"sha512-dfI6YUSDcHZAzV5M+BwDznFArJNhRGD81Kg1RN4naqcciWaX5Tf1pYaLptBeeZwb0jyvooaLN1VIrKRVtORR8A==","signatures":[{"sig":"MEYCIQCVFkSrcqcfYvmoI/Mx4p/3U2vul0BwZoA40LrEd9QhQAIhAMuQxWySBC3zgcShHa5CwIN5lWza5axYxPKXmJOuVa4q","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"b6e6337ff123e87bf8aee1e6c8344b53ca5da856","engines":{"node":">=0.10"},"gitHead":"817a555a37204edb63067967ae8f5b4b7e7491e3","scripts":{"test":"mocha test/unit","compile":"coffee --compile --output ./lib ./src","test-cli":"mocha test/integration -g cli","test-tds":"mocha test/integration -g tds","prepublish":"coffee --compile --output ./lib ./src","test-tedious":"mocha test/integration -g tedious","test-msnodesql":"mocha test/integration -g msnodesql","test-msnodesqlv8":"mocha test/integration -g msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"3.8.3","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"4.4.0","dependencies":{"promise":"^7.0.1","tedious":"~1.14.0","generic-pool":"^2.2.0"},"devDependencies":{"mocha":"^2.1.0","coffee-script":"^1.9.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql-3.3.0.tgz_1462576096194_0.3303074589930475","host":"packages-12-west.internal.npmjs.com"}},"4.0.0-alpha1":{"name":"mssql","version":"4.0.0-alpha1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.0.0-alpha1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"xo":{"rules":{"eqeqeq":"off","no-eq-null":"off"},"esnext":true},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"4581beaab5d2cb4653561b2333701cda4b8877de","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.0.0-alpha1.tgz","integrity":"sha512-kNY4DyOSr8r+bX2i6346mv5ZRyoDLmNZtItO0WVebspyqQ3EeFKOxOa4uai+Ou8tTEKbgptLd90bQrmH/Yk26A==","signatures":[{"sig":"MEUCID3CFYACHdMY3A7kJP8Dq5lXV2l0svv0S5kcEUhxcd3gAiEA0Br5I/xyyhnLobLMDpVlI2WU+kHuRu0o1xHl8QOjNg4=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"4581beaab5d2cb4653561b2333701cda4b8877de","engines":{"node":">=4"},"gitHead":"bdb67e346254f194d056bb1a194c58873cfb1d67","scripts":{"test":"mocha test/common/unit.js","test-cli":"mocha test/common/cli.js","test-tedious":"mocha test/tedious","test-msnodesqlv8":"mocha test/msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"3.10.10","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"6.9.5","dependencies":{"debug":"^2.6.1","tedious":"~1.14.0","generic-pool":"^3.1.7"},"devDependencies":{"mocha":"^2.1.0"},"_npmOperationalInternal":{"tmp":"tmp/mssql-4.0.0-alpha1.tgz_1487041266791_0.28603670373559","host":"packages-18-east.internal.npmjs.com"}},"4.0.0-alpha2":{"name":"mssql","version":"4.0.0-alpha2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.0.0-alpha2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"xo":{"rules":{"eqeqeq":"off","no-eq-null":"off"},"esnext":true},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"63bd2f134808bea97d4b181c27fa08fdb351fbc4","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.0.0-alpha2.tgz","integrity":"sha512-zlafClEhGUv8rytQl/W1trz28vErGYAYZ1DsR4TrSmeLfQotHSt3QGrg/LhSn1JNusaK/UGGSCICD5TLATZBJg==","signatures":[{"sig":"MEYCIQCKhaCDYyNXfXtAUX++ghq/Hl/vtc99VfTjsVg5XwpkngIhANb0tI9vGILq2IRhyYqj+yzwai9HUnjmW5Mmjmjw+zsI","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"63bd2f134808bea97d4b181c27fa08fdb351fbc4","engines":{"node":">=4"},"gitHead":"063cbac919e0138292a0c04186734f0ce1d7d9fc","scripts":{"test":"mocha test/common/unit.js","test-cli":"mocha test/common/cli.js","test-tedious":"mocha test/tedious","test-msnodesqlv8":"mocha test/msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"4.1.2","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"7.7.1","dependencies":{"debug":"^2.6.1","tedious":"~1.15.0","generic-pool":"^3.1.7"},"devDependencies":{"mocha":"^2.1.0"},"_npmOperationalInternal":{"tmp":"tmp/mssql-4.0.0-alpha2.tgz_1489198330006_0.03831758559681475","host":"packages-12-west.internal.npmjs.com"}},"4.0.0":{"name":"mssql","version":"4.0.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.0.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"7e1cc9a2a77f22408adf31bd3e3361fe6b9a703a","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.0.0.tgz","integrity":"sha512-XICSaiq6PtpSkVjFzHbMow/Mo/gPRjt9xPpQr3YEIzmjpN/PSeHG1CqQ+IusF4cNEBNUuCAq1lsCq5RLbCBt0w==","signatures":[{"sig":"MEUCID8W7TkR8uesTBNYhetrh8CGASdwD5v362eOqrXG1EWPAiEAjPRE+TyIisJ/C3j38ajvdSrSMXEU7lmsU8r2t87tfbo=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"7e1cc9a2a77f22408adf31bd3e3361fe6b9a703a","engines":{"node":">=4"},"gitHead":"353a206f8e96e3ddf5cc294fc5e52363a9aaf50f","scripts":{"test":"standard && node_modules/.bin/mocha test/common/unit.js","test-cli":"mocha test/common/cli.js","test-tedious":"mocha test/tedious","test-msnodesqlv8":"mocha test/msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"3.10.10","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"6.10.0","dependencies":{"debug":"^2.6.3","tedious":"^2.0.0","generic-pool":"^3.1.7"},"devDependencies":{"mocha":"^2.1.0","standard":"^9.0.2"},"_npmOperationalInternal":{"tmp":"tmp/mssql-4.0.0.tgz_1491007213422_0.5343425741884857","host":"packages-18-east.internal.npmjs.com"}},"4.0.1":{"name":"mssql","version":"4.0.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.0.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"5ac0028245f99a6bc8bd8dcd117c34244eba9f5b","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.0.1.tgz","integrity":"sha512-+xIXdTIOz+bxSACTgFU4bF2TOauZm0TFGU9vwynpEJV8ZZrjBXg0oeAh1Mrb77exnIM+sB4DYX44mlIgRjrDFQ==","signatures":[{"sig":"MEYCIQCf8gklykzcdbn8P5cideJz/tvEdYOwCka8c7HYImWJwQIhAKosfF+3W9cmfxSQDmpQvqtGs9eUmz6vK6o2O0RayP9V","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"5ac0028245f99a6bc8bd8dcd117c34244eba9f5b","engines":{"node":">=4"},"gitHead":"e36e30aba611866b2095f8f7f1405911f9d273ca","scripts":{"test":"standard && node_modules/.bin/mocha test/common/unit.js","test-cli":"mocha test/common/cli.js","test-tedious":"mocha test/tedious","test-msnodesqlv8":"mocha test/msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"4.5.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"6.10.0","dependencies":{"debug":"^2.6.3","tedious":"^2.0.0","generic-pool":"^3.1.7"},"devDependencies":{"mocha":"^2.1.0","standard":"^9.0.2"},"_npmOperationalInternal":{"tmp":"tmp/mssql-4.0.1.tgz_1491084030594_0.04683448770083487","host":"packages-12-west.internal.npmjs.com"}},"4.0.2":{"name":"mssql","version":"4.0.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.0.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"827c663b8657536e75a1df89fb7d8fc79cf31967","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.0.2.tgz","integrity":"sha512-pHorKygrJ6Dk+AZg1JIWx+WV8j0OLWFEPYV0vTW73VGflFImKsoEdWeKE+KmfRDVzNx0RIVvkP6Wu+qTwKcCAw==","signatures":[{"sig":"MEUCIQDjS72fME6U6CpSPvdHXqo/2qUrvOUIuY4xG5S32yBV8gIgEG5LUxBWAAHY3CNeN52SgUTGi+xb33GqSSFOP4gM31I=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"827c663b8657536e75a1df89fb7d8fc79cf31967","engines":{"node":">=4"},"gitHead":"1a490f355969a995d17aafd5e217221c67127906","scripts":{"test":"standard && node_modules/.bin/mocha test/common/unit.js","test-cli":"mocha test/common/cli.js","test-tedious":"mocha test/tedious","test-msnodesqlv8":"mocha test/msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"4.5.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"6.10.0","dependencies":{"debug":"^2.6.3","tedious":"^2.0.0","generic-pool":"^3.1.7"},"devDependencies":{"mocha":"^2.1.0","standard":"^9.0.2"},"_npmOperationalInternal":{"tmp":"tmp/mssql-4.0.2.tgz_1492632903288_0.9668218288570642","host":"packages-18-east.internal.npmjs.com"}},"4.0.3":{"name":"mssql","version":"4.0.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.0.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"4b0d848eb9318f587cc069a84cfc4f6b5b558999","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.0.3.tgz","integrity":"sha512-Ed9YIdEejlHPzNYq8XRpvQAkNT8JBQ73OK1+/+Vp7HSh0TExk9DHVBk9cNI6zOtfESjBebJLTgTdlnlTcVav1A==","signatures":[{"sig":"MEUCIQCcTN8vcwff0Ps0Fcy4NfOsUR0NRZbQUQleQHCJC8ugwgIgd4BR8AH+36/1wR35Ffh5maTCEmojbhtVh7D9VsJu4+Q=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"4b0d848eb9318f587cc069a84cfc4f6b5b558999","engines":{"node":">=4"},"gitHead":"dee9086569ea007d632813a1f209e6b2a716c2e3","scripts":{"test":"standard && node_modules/.bin/mocha test/common/unit.js","test-cli":"mocha test/common/cli.js","test-tedious":"mocha test/tedious","test-msnodesqlv8":"mocha test/msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"4.5.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"6.10.0","dependencies":{"debug":"^2.6.3","tedious":"^2.0.0","generic-pool":"^3.1.7"},"devDependencies":{"mocha":"^2.1.0","standard":"^9.0.2"},"_npmOperationalInternal":{"tmp":"tmp/mssql-4.0.3.tgz_1493138597801_0.721372454892844","host":"packages-12-west.internal.npmjs.com"}},"4.0.4":{"name":"mssql","version":"4.0.4","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.0.4","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"416d67df7653536cb6384951891fa1a47572a49b","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.0.4.tgz","integrity":"sha512-DQjrSK+3vOGIR+0R5RRf/hg8IEezuew1IMT7rP/5RSlt2MnoN9CrfijNV6v2V8Wc9CjgFFLI0L1r43Gx3XZtbw==","signatures":[{"sig":"MEUCIQDVrFqfGI1t0hQCLsQLzOBeeB3UYP8J1638nuv5RwYdnwIgA/zKpvQLifk2h6Xa54TM4gcHhBJZC+Vap+0OXr/COAc=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","_from":".","_shasum":"416d67df7653536cb6384951891fa1a47572a49b","engines":{"node":">=4"},"gitHead":"a16180bd4253656753093de08cb50a627808b6b2","scripts":{"test":"standard && node_modules/.bin/mocha test/common/unit.js","test-cli":"mocha test/common/cli.js","test-tedious":"mocha test/tedious","test-msnodesqlv8":"mocha test/msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"4.5.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"6.10.0","dependencies":{"debug":"^2.6.3","tedious":"^2.0.0","generic-pool":"^3.1.7"},"devDependencies":{"mocha":"^2.1.0","standard":"^9.0.2"},"_npmOperationalInternal":{"tmp":"tmp/mssql-4.0.4.tgz_1493156314169_0.1359078933019191","host":"packages-18-east.internal.npmjs.com"}},"4.1.0":{"name":"mssql","version":"4.1.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.1.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/patriksimek/node-mssql#readme","bugs":{"url":"https://github.com/patriksimek/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"5a70e24d751c28bcb9f23acf709c1bdaccc8eae6","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.1.0.tgz","integrity":"sha512-ekht0eILEV0P1CbpkwpAxhgO+/5goYizUJrt7pgDm3fP6lGKe0+8V9jhTvQZ8DPHkycSd0wYGUoz/YA7VN7kQQ==","signatures":[{"sig":"MEUCIDkk3MJQsJlwo4wNooNonseXn5WCHHo4zzbvFA6JDum2AiEAocj2TpPzDX/r2jdPwaqdU1WkNUvFZyoqy1qIWL0yb74=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}]},"main":"index.js","engines":{"node":">=4"},"gitHead":"85c14ff5b01b1ae0575591c7e4f1c7327cf82e51","scripts":{"test":"standard && node_modules/.bin/mocha test/common/unit.js","test-cli":"mocha test/common/cli.js","test-tedious":"mocha test/tedious","test-msnodesqlv8":"mocha test/msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/patriksimek/node-mssql.git","type":"git"},"_npmVersion":"5.4.2","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"8.6.0","dependencies":{"debug":"^2.6.3","tedious":"^2.0.0","generic-pool":"^3.1.7"},"devDependencies":{"mocha":"^2.1.0","standard":"^9.0.2"},"_npmOperationalInternal":{"tmp":"tmp/mssql-4.1.0.tgz_1506702391005_0.8393137641251087","host":"s3://npm-registry-packages"}},"4.2.0":{"name":"mssql","version":"4.2.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.2.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"12a611743dac56d9051e15f656c8f628a8848013","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.2.0.tgz","fileCount":19,"integrity":"sha512-x0jvlmSh8sOUr6S4h9Bw0HpstmGDezZjJZUN06sH/k2An5TnqIf1CBaRCwttunw/Ezov0GIPVVxwwbimzQtHwA==","signatures":[{"sig":"MEUCIF+bkozQCtYiSS6dFt5r6a49yUvekvGioLOqCzzjd8wYAiEAuW484lsuEAsR8ESgJFebAcWm9y5NPOyG4zi4mcg6Fg4=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":192445,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbPnXaCRA9TVsSAnZWagAA484P/A/dNuliVSd3a5abTeBN\n4w4JJLHWJQluJUFOP7tcdApdc0cZ6jHp8mYXuI1ZP8U549UUaB18GLejLFOx\nBQ/8oE05ghOUEPFLPY7frkOamEu7b7qybQB682QlIVOheKFqUP0TOIZDxkNb\nLrmj9qalzfTZrZQ30w/8Qdv9+IKj4SUrlfF8AzL+b3Dj7+Ol+kG+Cadopnjw\nLkkkEEBir5Z92h1RRz/e1D2eDObd8GVMywRVPOYfP4wNj+ezoXgGDxdCvD1+\nzBNIunb8qkDUTlWBCumgAk5DfXHOoXQhdfm0xoGDOjhjI9XFDGhkIali/9cT\nDOJHc9CfmacfGkDBayvZwIMs+2oOHa4gMvx3NZ7ixtvYehwkysd6LoLiR4bY\npaiDq4VPVLyH2CdYyxJ0FRX1+eimrGKvkEo+a6Jt2rDJnO1/AKvpw7xrH8if\nuciFbuNKxZgNZv/twYGIoyGF1ef4oEhyfv9DAlCqAmyfvokchHRz9jdB9ReU\nGYrt9aJsYW6NFZCoajyWWO5wNonbt9e36GORFlmcPrt5WIA9jfHmCo3EI1by\niv8+VYrf1EmDH1RVSYAZ+E5xccNJ7XeaXslA38nwJ2uQRrrRVGqLDn2H9SBG\nBzD81S/BKzpbeFA1qPs1TqAOWqIOqP4GL0EYs9lxwEZ3BeLmoUG2wZcmvhWO\nsiIy\r\n=M/2/\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n## Connection Pools\n\n```javascript\nconst sql = require('mssql')\n\nconst pool1 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n\n    // Query\n\n    pool1.request() // or: new sql.Request(pool1)\n    .query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n})\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n\n    // Stored Procedure\n\n    pool2.request() // or: new sql.Request(pool2)\n    .input('input_parameter', sql.Int, 10)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\npool2.on('error', err => {\n    // ... error handler\n})\n```\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second.\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n## Sponsors\n\nDevelopment is sponsored by [Integromat](https://www.integromat.com/en/integrations/mssql).\n\n## License\n\nCopyright (c) 2013-2018 Patrik Simek\n\nThe MIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://img.shields.io/appveyor/ci/patriksimek/node-mssql-o4dhf/master.svg?style=flat-square&label=integration\n[appveyor-url]: https://ci.appveyor.com/project/patriksimek/node-mssql-o4dhf\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=4"},"gitHead":"4879641e8a488b67bdb05efbbd757511f31c14b5","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha test/common/cli.js","test-unit":"mocha test/common/unit.js","test-tedious":"mocha test/tedious","test-msnodesqlv8":"mocha test/msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.1.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"8.11.2","dependencies":{"debug":"^3.1.0","tedious":"^2.3.1","generic-pool":"^3.4.2"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.2.0_1530820058697_0.1737950856037982","host":"s3://npm-registry-packages"}},"4.2.1":{"name":"mssql","version":"4.2.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.2.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"c7133247e912d71185b09d3c2bae0f19345fcde6","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.2.1.tgz","fileCount":19,"integrity":"sha512-89mJcK/xgcsRdlCfEZxRsE93NKZnZJFSASy7Eiw4Bx6exvkGb9Kd1ey9d9/jODTFssoZ3U0OOFK3wabYMpJypQ==","signatures":[{"sig":"MEUCIHHmVxs2fFYecoKQxSh+5Z1ibuk/yf541/iGQSphfLi6AiEAqlI5twWGzG8sEtWtanqc0qZ9KbxwpHd4QZGs3vrB2Qw=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":192772,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbZ2ggCRA9TVsSAnZWagAA3HEP/Rv0MqXvUXCU27O2yhtj\nvIdGgY7Gsc/BO5aH2sHQsceI38n1e7wZYybkDZROwwPI+P5N+Ij+lk2xm3YY\nZbIadHwAgwjeN3y7E8KTTvC3PXwyaEO9n78N6V7iPQkVR24nepMotDBhoN45\nXCGVBvuhUouX/du6ihljga+xI11/IS8O1zkZJmvtJm6KpcCRS6XMcA6Mtgjm\nukVMJ+uOEoUSvRknUdMsI6GgHXFkp+0P27amHL1GNlp4A8/eectZoI9StgUw\ndFWNFtxVuKFBLRZW+MEhK5FBbBt0juR6nVJz/j16FIZCUoZqjDeJYqboWmGQ\ncSWp2HZQHCeXG4895ga8h8KeolJswiMUCYwDcE3R77ZgdrlFT91ijQVGCypd\nj068RRE7M88YIVzqL+kfwee2ZapNQL+yEw4uU8hbu76WqfXuPU1FDRZ2XdFN\n3CFdQ23R/F/J69zdxKthWnkrKO5mBTSPKUdkotu8wg25fhr8aOuPzLZsQePS\nw5Kjb3Q1w2+OTvPHarG6JAc035JAbaBSl3tvu91bzo2gHJaLTFO4Jr8BJmTy\njfq46v15R36LyH59XydAcZf5fyuCVbl9qQEkPGCdglW41dOHe+27QYobbDXI\nWcgmZlbrvp6SZg8NmN0zWf/GtDbJAo0BVrAc5UeG/Ugnpu7wAJMPjkHW4UMh\nG0Nj\r\n=5Lrw\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\nUse `@next` tag to install the most recent version with latest fixes and features.\n\n    npm install mssql@next\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n## Connection Pools\n\n```javascript\nconst sql = require('mssql')\n\nconst pool1 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n\n    // Query\n\n    pool1.request() // or: new sql.Request(pool1)\n    .query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n})\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n\n    // Stored Procedure\n\n    pool2.request() // or: new sql.Request(pool2)\n    .input('input_parameter', sql.Int, 10)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\npool2.on('error', err => {\n    // ... error handler\n})\n```\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second.\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n## Sponsors\n\nDevelopment is sponsored by [Integromat](https://www.integromat.com/en/integrations/mssql).\n\n## License\n\nCopyright (c) 2013-2018 Patrik Simek\n\nThe MIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://img.shields.io/appveyor/ci/patriksimek/node-mssql-o4dhf/master.svg?style=flat-square&label=integration\n[appveyor-url]: https://ci.appveyor.com/project/patriksimek/node-mssql-o4dhf\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=4"},"gitHead":"7f374a8d73b00b17aa5b5ea5621c4314fc6e2daa","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha test/common/cli.js","test-unit":"mocha test/common/unit.js","test-tedious":"mocha test/tedious","test-msnodesqlv8":"mocha test/msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.1.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"8.11.2","dependencies":{"debug":"^3.1.0","tedious":"^2.6.4","generic-pool":"^3.4.2"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.2.1_1533503519970_0.07286130781095235","host":"s3://npm-registry-packages"}},"4.2.2":{"name":"mssql","version":"4.2.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.2.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"98378427de9faf422430bad03c7919fb894ec490","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.2.2.tgz","fileCount":19,"integrity":"sha512-LmClNZAD8k/BmXnu0twrWSW0sQXkrOx8WssSB2wtgsdpFeQmBNfUQ+sr5rT037F388KLoN3lZX7nFARgWTSYHw==","signatures":[{"sig":"MEYCIQD1nXbPzChsLsJcHeCkeo63VkiJVafa2vy2IRpNuvUwkQIhANJdSH2RAjwn1Kc/6/w423DzbgCDnqZI2RiASDNZAFGk","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":192890,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJbx6ybCRA9TVsSAnZWagAAxBEQAIjLBH4kOWrNu1oOtWDi\nS+iNkI9KrixMfGzESJDs7fFrLrlPHTfVpa1B6BU9hpqiKQZvEEuqOO3cPum6\n8wlEyPrfOAg+JUVNXQ0KHNgr6+HJPlgyqKLADbzHmn++8/9HMwBDuDJLlwZM\n7v5hd27Mvub5gRM2VPocbCwJq0YRN5AbDXOt3CMxq9kMWI0OaOqN/UqjCGRP\nRaUg/FIErfydufdOHMlypAs6x3v1LF+MjAAkxyYyxIa5MwbIxpHtoiOgQwPZ\n4ce2CiahgTAjpCmpMMboT3qvn3fNOJJtX2NKiwWEbfgllSpVEx2vVqU02Qgf\n0GiGgeCBs6pBEhOWpNDo3oAES+D79ACadZq91ddhzoAuo5bOsF4gb9kVg54E\nhIxA16wMwrHqknk2Xrj6Q2y3Z7VAGU6tM14oxGp7J5kuhVhyqi0e8O52MXfw\nDSCfojyCHTy8F5kSIM1OW3Fmq70044qTFm7CM/r6kiDPegWqlDiVS/q9wLn+\nN9jBB+GRT8gt0HGZC8NYVS0g4XFNUMJamxluhj/G2xiJfOHApMcdh3EbhQqC\ncbQo8td30HpZRuhb8E9Z5WqRN8MkgvPf6Y4GdI8ntPqTZsDdbnxmk5uviVn7\nuTQ0pDxPA89mpaOgyDR0VSs32vjOFea2/Tt915M34JHFHqTL1X+8kVLmlapx\nE/ob\r\n=Iwts\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=4"},"gitHead":"49d710a3627a6606e791283769759806a6c20273","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha test/common/cli.js","test-unit":"mocha test/common/unit.js","test-tedious":"mocha test/tedious","test-msnodesqlv8":"mocha test/msnodesqlv8"},"_npmUser":{"name":"patriksimek","email":"patrik@patriksimek.cz"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"8.12.0","dependencies":{"debug":"^3.2.6","tedious":"^2.7.1","generic-pool":"^3.4.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.2.2_1539812506032_0.6629761954160209","host":"s3://npm-registry-packages"}},"4.2.3":{"name":"mssql","version":"4.2.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.2.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"5dc2500a1f0177d3b40f8b7bdc2ebf02f155160b","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.2.3.tgz","fileCount":19,"integrity":"sha512-GocHjqx2qaIQ/FwJTnLCoscrnbROCgSJfgpxoPun7rDpJkDS4b82sZ+lh/3hH+UuTC7T4f7VtJO5GLA6VyWfCw==","signatures":[{"sig":"MEQCIG5NE0ERXIF5ybPYlYoZ2OWJmpmMk5bhQSbdILUq2uqbAiAPgq39ME2bWWXwufjfGBg7MVPftc+CICc17/IgyZ0mQg==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":194552,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb4brICRA9TVsSAnZWagAAhvQP/3Lg7hoKHVdRgjES74Gm\nKb5nKDgH4cieSMJB+gSMna42HopjkHbpU7mlZC8zkIO2q9+iUlOboZLTMq40\n67ZIAF0kQbg2eHXMd94069xFK8bhLCpq5/dyRPMrpSdGF3qoAVhfkhLv94SR\nkTo9Oo1+lH4mkvOxVNAoxeydw4rOTL8Rli41iTbTA9xxrD0xdx4MZlcV8W+R\n5jQkXiFpDBL4+oAKUbz0WzmkC78oo2Nr5A/P9L+hcpUg9FTqRGMwFtNhOMU0\nGAMkgfOE3wE/35bVM1nSredy8MqYSKV/SpgRbtfqByrH58QzYVkWEuRfz2k+\nyO/sFc3LkY7j19sEfxdgB25z6m825Yp0UY+B6AoPWJkCLGq/V1ZeqA2do62s\nWMlwl2W5Z1ZiPzkNy9VePnO0AeXSbonvjHQtoam9Lb9oBhUoxOgbSp5uGIJP\nlFzjWp1+7oNWBzmpwM/ehZWU8QVhKiyETaULYuqLifcShImL9xBb7BYgdzMh\nyQWME2ATOkwFmlAQCn1Euok/ADuZQ0oEVU0gko1MaIhsjvHctVev0BBw0u9C\nDtzUjbpWGa4SWAYSkvmyc4yOZD818C66I2FILfqu2cfhEDQ69OY0EGYush67\nL+Frzp03jTfA8nss0Jqi1Ktk98EPvQno2toBgdc1U8Y0e5p1g0Cj9sSPMZBP\nprFG\r\n=tfW1\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=4"},"gitHead":"6a3d88eba974f6799c96c1d3d40a656a4c181cc6","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.13.0","dependencies":{"debug":"^3.2.6","tedious":"^2.7.1","generic-pool":"^3.4.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.2.3_1541520070758_0.887399059433829","host":"s3://npm-registry-packages"}},"4.3.0":{"name":"mssql","version":"4.3.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.3.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"1ff6d1392a3332236fefd66b48c3d44e9630ff80","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.3.0.tgz","fileCount":19,"integrity":"sha512-MpSwdLMbKfFL3DwjhgbJdFViU+ye9YR+op/t/CdhWwYdA90qWYjPyWbIzso/2xRfm7liYNkN5EZjAS9PWFLLZg==","signatures":[{"sig":"MEQCIBjMntff4b+qbb6ZerLL8uYKyDyBdKMMlNgCb3hdSXPNAiB6L4ERsTUcsw6uEhEEpqwDv5sC4N6ZrUFEdVFRM/725w==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":195470,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb9qHpCRA9TVsSAnZWagAA8LEP/1ejXsYyQHB7wrUMRbxJ\nDSSPwuV8xnxADmIbux1mejOJQUr4+bmXUxdrPflhSLeMz3+BzvAZshYcaTjw\nu8mFOqTA92pIZax2k8xI6SPlVoHZYE5H2QSdSICVh+tWw8TXZ+lXz/zlvzoq\nVDD+rReqKPbyVEJXYzDuAThta4UdlMkeoBzQyBxVCB/axufPzGE2Wi2kobAA\ngH865wNEKv5to7xBZPB/Mb6CNa0WyXZTCfIN7drhB545fV36L7ronIsB3raa\n3on/SLd6oFnPuWCayaAWRwRCgJF8idmKv4Bs5gxtlAorLvcaqzrhUbf0ag0h\n4eIJud9d89DgEE98l6N/eL+Swnc3MR3jhMpEY/+6YFUji4o/Iuu/qvNZQtml\nEaLKYRt/1DXcGQdCxh/atgR6oieCMZFcrB9Go2yaQaCtI+lHBFcq2jQLkACG\nL/ms8N7Z2hJchR03iwlz+fTsRJgT1BK2yvZHL2cTa4+nTJkAn0GmY2gkclXg\naIF3ej2g3VONE5MiKjBTOmzNnLLkbHse/6n/PvuBA0n1Vye1QCdXFqZGXbkE\n+M9ow9UBmNXqzmit7R+pvT3QKqTCGau+h0Cyy3VzTcyuMerL3/1dYz5SZcoU\nZth8puozn36x/JQZW1gnTCbwdDbAuQIYPcCjKB5S8c65xiMZDu7cT78oiMTS\nD8GJ\r\n=OWnN\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=4"},"gitHead":"7cb04a2825cfb6f29d9e1599eea44c1414beb651","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^2.7.1","generic-pool":"^3.4.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.3.0_1542889959900_0.9136293182173982","host":"s3://npm-registry-packages"}},"5.0.0-alpha.1":{"name":"mssql","version":"5.0.0-alpha.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.0-alpha.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"4586ffb728d5f516660d7ecfc5856e5ae3ba8cec","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.0-alpha.1.tgz","fileCount":19,"integrity":"sha512-ZG4vlI2CdmTNcyPK+NuhewAAzgIJ0pktcps80sbaRQyVtRpsh2UuiF55sH9kGnqF/AxzawnutsfmNKOVDG6HQA==","signatures":[{"sig":"MEUCIQDARp6oisz+bP7Iz1EePDLBsciCYPoZq3CyP+3R7UGIHQIgA8M837FCgC5g4PR60pkvDuG/xiyUMw6WuY5fvTB/BmM=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":195604,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJb9rwgCRA9TVsSAnZWagAAgIwP/i/qdJXTwnGeUlgqJk2o\nn3j54tcKs48Cvt9+sfh79ZqjicCFXzCfA7EPHrrt1zbrwWPvbjzDAkKIjdEZ\nJd8yViRrlrBEcJoNI76n04xf3ywVgqHppqk/7xcV87p3mKnipd1NrYY1J08N\nqiFAZtnwWEz4G1UiJq9htnT5PXOAtpr0rgj3Q3G51A0aKWaSINWuCvxGFt/P\noEc+ErcZ4WOtMrVSUpJNuTJD+d7dhssxV9ZTKitqtAhIvng1TIdE9U4tU27j\nN5kRva8lW4vSGza3vDB7tpMxR2JX/my9yZhqjW1aYgE/OfBIdOMzcx+zWYEt\neqVbNTF+e/7YBJGoK+FPU17YtacGekPLMMsai4iy7MGF69nhsooaZH9WeoRM\n+7aSWPrm2kVmNYh7oh6jFTjAqfiuUDsehbBnWLPU3WnRUNa6tsvyACAd+chJ\nm75UHaeeKAqF+gAemZuh8xSxDQqYNTwMbb77um+cC8Pfu1kxbmNf7rHxbyq6\n1CR76ArxbIfjhh8PJnAXmBzT3B42iSBnX9pIT7UzfGdwHeaieF4lQV5XbBKK\nsEotJM22AE7ZmHhD2aUaNcJUAwd29P9gGxPXWONh2tPTd8Npl0m6Gvf+n+L+\n1QNB1pjjXF4tkp1SSVdGh75kbC/ElI27CT9NHIQlh/p5vlZO+uarajt9FKSS\nlt14\r\n=GaLS\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"44cc6eba3bb8025e913ea3d6c2f96c688941da18","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^3.0.1","generic-pool":"^3.4.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.0-alpha.1_1542896671363_0.5839377849670122","host":"s3://npm-registry-packages"}},"5.0.0-alpha.2":{"name":"mssql","version":"5.0.0-alpha.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.0-alpha.2","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"d84b057aca7bc4204329d58fef8523737fa21789","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.0-alpha.2.tgz","fileCount":19,"integrity":"sha512-1b6my4WvFZTBTgunkKIYLD7Ikua3XuFViNvuGgKiyPy9n8UCJb9SiyqvyBEW/JOOA1DiiMc4e13eqozQHGO/mw==","signatures":[{"sig":"MEQCICqYVtG9e3fLQOct53GhJCtjqCRrHB3Z4omG7bZ9llMxAiBKHI5yxaNY1e1DtbmDFVGYGEJTZTUspfE1rEfcOT5s8Q==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":196930,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcMylACRA9TVsSAnZWagAAqswP/3XgxSdPElv4fNjaatIx\nPu3fJlI+nzfBeiEv9VIeDNlqZVuHd0Dh8LkUujXYy4n6ppqNrLZVZ7CW8/2r\netvInEFMWZqrOc4E1dOnPVEylCO7IIchWCl7HZIVhW2lAkIRWAe+seYzeANQ\neFGF3IZnEB8lb1bic8OL6KOKdXBCDfnF2KjVU2OcfeVsrA5ZvKayt1jaIjcr\nKhwxfv5mNm0ESV4RYDAEJTGgIhHtuUfSyQLCw2QG2tKKTlFMNrcOe/rntl6z\n96scgP5GHXYq+ABjuDC8ggN6zNnM/Rk+DKBpy59mPFi7dEaXPn2p67azfOyH\n2Am4uMIhA2g4zdfaFPzfrJJrMTPT4oMHAoTrsS7Gf+/puysp+hbHsiM4ILrp\nORFoGP+fxfhM4R85dMeAejFZO1oG/0guHqE0DasexAD3hYXmuEvI1hHmpngU\na9dOR4LwdpkvwzAP/P6IZ4OhYQTBdsH3rd8HlMzefk51xb3IP9jVEVjD1Y25\nLZr3PcMFSbebaVLEQ5HQzuaDFEj3X5oZh0He2tJnCtyNEi5aTPQDHMBAtqDh\nEBrqU3ReHJmFCTWgYISJRjmyuJfSshzHL0rUCmcsEDr/8ystLE9PKecPc2yI\n+kLnIxwH+fygbDdgtjkBxiGs/Us8iy++7vg8oIoS8UA/Hy9OVnIuEz8Cfa5u\njyJp\r\n=v/BG\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"2e6125f7b360e7db76c882cbb8a71e749c5dbfe5","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^4.1.1","generic-pool":"^3.4.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.0-alpha.2_1546856767300_0.10863387650858258","host":"s3://npm-registry-packages"}},"5.0.0-alpha.3":{"name":"mssql","version":"5.0.0-alpha.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.0-alpha.3","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"51a3a68e410edcbe21954b3ea0b314bac968b729","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.0-alpha.3.tgz","fileCount":20,"integrity":"sha512-sTCRi1Nz2XzIfaYLiqQV+4g7GWk5m2EoOEkaBiRadBQHVo+9yZWCxowhy9a7pFC00/L2AHkM7GBkua8o/ZOq7w==","signatures":[{"sig":"MEQCICwuXIJXui8i+g8qbQYVzKPJMk0nyU+IvISb7kGQETpdAiBhTdkOXtY2uJgsf7JaJZjgmKdWouZ47T1MuVf7Zch/Ug==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":199428,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcM2KhCRA9TVsSAnZWagAAolcP/RegEGIPVr+pm6p06g9c\nWfT8GEoEW8Dp5REA5LA/4frxeJFsKfaqC5skRH4FIeEadmj9izu87Y/pwYhJ\nfnmWVpmsXJX1g8nXvfjnaRYhun8dx59O39coHY9RuhvIOHxqQQbNnDtLLJgq\nxyKE04QYLP8NLeTR57U01PIfPFyiaQYjJa2OAjMYpHeiDlOunGXFLUSFFyC3\n70DJWv0az5NgSnAPi42qtgmbigmBs1EWWuR4SnwrrnHy8KmimykbwnMQ01Q1\nPlEQhdds6oBc9zpu2KY8cg4met5Gl2pOXTNvjtOGzTcN/QBoWkBFNF79zbGA\nHnmWr6UYH6MhZYa23yXyHJ1N9bJRUZt+stsHWFV8y38TH139QHH3CfMkXomy\n6GygO+H5FBO9J4d5dj45AxiBnokKhHuoztXPWoruEyDtmbiPyZhoEOs9QOfJ\nPcapLyZtGYALNDlaZMHOfXo+50K4wa5pp3VdqpOtSMIovVbTMZQWU/17VgEL\nm8OxIMoRZ3ZbzwpXMwosfp4JKVtAtCpsFNEwKiULKYJyWxFEWF6x1nCkFRtN\nNa+o9rp0t7UGuKNu8gu4YZLpQyd8rlYJf6t4IbUcu183D3RXf1tMxNX4UdrU\nB8lecvkc2fngnHr3PBN7IUMFszqjw5ixvM60dkFr3KetJ5Itt90tDMGYG7XP\nl2t6\r\n=bnlx\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  if (rowsToProcess.length < 15) {\n    rowsToProcess.push(row);\n  } else {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n});\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://img.shields.io/appveyor/ci/patriksimek/node-mssql-o4dhf/master.svg?style=flat-square&label=integration\n[appveyor-url]: https://ci.appveyor.com/project/patriksimek/node-mssql-o4dhf\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"949f6b23607e2e40d7cebeaf4b08bc9c807f2b04","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^4.1.1","generic-pool":"^3.4.2"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.0-alpha.3_1546871456449_0.2758080981845277","host":"s3://npm-registry-packages"}},"5.0.0-alhpa.4":{"name":"mssql","version":"5.0.0-alhpa.4","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.0-alhpa.4","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"2dfef1a2ddbe7a7b2fc0e7bba51258ae93b3bd7d","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.0-alhpa.4.tgz","fileCount":19,"integrity":"sha512-61inx1mbiF+/OdCalm19ahwClanSJ1dO0wgGFsXbh1c695fAdy0Xa/b+UYT4FwTnPFaj0daKXg9pByCVb5X10g==","signatures":[{"sig":"MEUCIQCK8kvB36p5IFlXGGpLjr/0n8+4MM+Hv4Ld7/7m2EAfGQIgO7GHEaVcmwx10lbpUy7lmJkFx0AABqIidyrLZfGybik=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":198304,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcQE/wCRA9TVsSAnZWagAAbdAQAJ+7VjIAmHK2X7B0smi9\n4F7lLZi1G1UEY2xHya4YjBch8oj3xATqUoATDbID2pyDUZdGoR0DdJwTtDAa\nBcddDY5DzBRl0mk/RO97lqxPBBRwD8Fbm7wKs12HoLBihqvKoP8GlWdF1T6x\nW4mvlBDdQRBUHjy0mzJq7cDaBEpG2tUsKq4utdpsBsQcEIg5nJZB+RX5h8jj\n6pfbLIrhqZqanUEnftB4589EnaX1zHFcarSVtv70EC/gA/uqPNdnd/x0jQuP\n01KmRIeeJpyro0FDupelIg8uav7aLG7w/bleAKvE5NktowmZn2TF11oFnv9a\nJ6jgahrIN/mwWrhk/xvIcSdaBa/JJuIMc+tovpYn/tocHQDEu2NHQ2nsgU4I\nNTyJPo/2R0F3K41wdztu6z33VpFDgCAbHyriWuNGTDAnPAgY0AiFRHxmuDLT\nAAa5D/elztskvlUQ0YncyEISSXi9BoH7FkOKbAf7XjbTMOkJgtlpAYoj3usq\nQN3T2l79AlWT12ByGbno8rrfFpnr9m1S9K+0FEuv8JOSCkXo0cdfPMTuTTJI\nc5m0fxC4llzo2zlHZoX1caSd3R7kLuNNQgEBeU7utHMfa/ge9MtXuUv1E43P\nnaCxZ6yifnxFunvzRFNh8SJ+3qkJaSNx60ExXuk9SjBXlBTk2tRQiObko+xf\nrE87\r\n=IXpU\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  if (rowsToProcess.length < 15) {\n    rowsToProcess.push(row);\n  } else {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n});\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://img.shields.io/appveyor/ci/patriksimek/node-mssql-o4dhf/master.svg?style=flat-square&label=integration\n[appveyor-url]: https://ci.appveyor.com/project/patriksimek/node-mssql-o4dhf\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"bdc050e6afd0e0f2e2e1a76a3316abe04dc5d199","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^4.1.1","generic-pool":"^3.4.2"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.0-alhpa.4_1547718639366_0.07488734907178007","host":"s3://npm-registry-packages"}},"5.0.0-alpha.5":{"name":"mssql","version":"5.0.0-alpha.5","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.0-alpha.5","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"60ad24b19894c887acd0ffc800ae096cb24c0b2f","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.0-alpha.5.tgz","fileCount":19,"integrity":"sha512-c/3lI240nFoJq0b7H2oBpGHfgbX+rW6nzAbzJnhfngEU95AUopUQ23f06z8STFyuI4/W7og9qIlZCakuBY8E0g==","signatures":[{"sig":"MEUCIHjV1q/ZY6Gdo+AiEZsALgtv7/vTd3me+WoI6T96T2/AAiEA3CH9Du7SKMYg39OXuAzplw2sRnDFd6p9HwNseDrtOPk=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":198610,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcUCkjCRA9TVsSAnZWagAA60IP/1dkqM1AMSE5LZIHtPiU\nutEF2T61baLQbjFgd1a6HascUM3j25JlsSBq8HNZRwYo+QYnuNBdmmLDg86S\nVgAg1U+ccpjuYyNmGk3Bd0twYNXcOcfa9kB7Zrn73jj7bMFi3LCTODBenzw7\ntjlv3T8N4GIpjQKqhUDKjpeMVAUwcCxs0Nerj5KdTw+CQCoI+16AiurD0KJm\nyPq5UlWNnzTqR/ScFqPNzPefdwiYEMdtv1XKQm6Y8EGISrbV2jKoaFsGyboX\nNLPEyO4FNCuznlhJYVz0DQi5d2MURJVt9GRkueuswaIP/ON2TwDzx5jXJacF\nifLYgzjdDE9pyKmlhyDAk9cv7LJs+VmuuTNyj0AXwkCGBrAJqCJRW9b1uHR4\nu/TbU0mSEDKu092sMi+kVOcM2QRvnLloSBz2+DdgCOyHufGs2XnDsmBimm3W\ndQVX34rusEuHcXLf96ytlbYm51F82ozkeCkUfF5ejrr1XZZiRW4PttX0ZBTP\n+VXpxk5sY6OLTzcl6ArzB5hHOkMrDcwK2pLebd4Rkt+XS8elUFdzmnVQG4s7\nFxfmcVbEgdTzu/iTBGvnZ51LWWebl87fbcEDyIPk+cX51XxUe9vFYCZHcPvl\nb/1NIiqdX5P3Ndgn+qEOMyFNbu7alMP6/LmQskg2G2aWxmBDN+CEhLRtn2Oy\nbcNR\r\n=cXm8\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n});\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://img.shields.io/appveyor/ci/patriksimek/node-mssql-o4dhf/master.svg?style=flat-square&label=integration\n[appveyor-url]: https://ci.appveyor.com/project/patriksimek/node-mssql-o4dhf\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"7290671db08d4f9a66cd7444258bf6c6b8d1397e","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^4.1.1","generic-pool":"^3.4.2"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.0-alpha.5_1548757282809_0.7594222502559647","host":"s3://npm-registry-packages"}},"5.0.0-beta.1":{"name":"mssql","version":"5.0.0-beta.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.0-beta.1","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"ead9e435aace356a7cce2ac95715d325bed57763","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.0-beta.1.tgz","fileCount":19,"integrity":"sha512-7tGkGv2vKSd1OSzMI9Ocs3KuVu5AOb0aPwhm9WIQD8E7HSZmSHlEsmXnG0nbluX6IWqdIrwMXrvGWR9FzZFn0w==","signatures":[{"sig":"MEUCIGdaIPAJsRCyq+yrfsnQl4Cj17+JikoSbiVrGMN5K3T9AiEAsz+5BGUAQZtopGW6jIv44cwfIx3bVMcLdt8dNEQ+F7s=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":198810,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcWFESCRA9TVsSAnZWagAAoaQP/ROW64kVNBFkz7FFY/An\n4bRF7mqWp1f4T77LXY2OwkfKToiwk2SB892J50YtDKjnxpycit8LZ4xOfcL0\nHGWk2UcvyY1LR+ZbD8Ynqh4RTOTV5jyOgiD1E8e7gzh3sVJdUZstxYDot9Xe\nGJY7HUwbf9SnCmsBKmEC/mQK+1Ce8BhwE1WM0yH+2dVw92G+UT57HqDY1ErN\nBaMvnvQP1yrvN09q66ctJKIAOHmA84MPHbRO7JIUWDMh3iR3Cz1BuZ/y0j6p\nAk/wLo2fRg43kThhnYBDakNRrxsDgXTH3qHG7pja0MtuLm7GnIjmrF/3W9gf\no6z1zkwWBuYWMF2FJv6k7SrU8iUpO+8mC0YsuiEJFIDUT75dqGN+zAZF0kfc\nPxZFyJK9tMQZ65p3BDengBX8mxjBQ567rgoAzfRoaYRu4lPr3Y10/s+XuT5M\n9BPbsA0bKXx6/m/GhcixaQT+eNZFcE9GrYPmlQRtadoV0ke4OWWQJONenq8q\ngfiufD6Syow5uAlVDxGBDpr1l5QQptiPJJlR1K9ostQxWGYnRKEEvU8pFZTW\n/jR/46WDnyDy98uBXWp9Qn13fYn2ziLLb812syw3q6nWFrekGOLb1GilVGpV\nRlPa1I4Hdv12EdVBEf++SsiXEp6MhiMQnIOfNMAxx1YTw6TF+9ycrM5S2aCG\nucRH\r\n=d6/u\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n});\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://img.shields.io/appveyor/ci/patriksimek/node-mssql-o4dhf/master.svg?style=flat-square&label=integration\n[appveyor-url]: https://ci.appveyor.com/project/patriksimek/node-mssql-o4dhf\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"d952794ca69cd933746938289f4f11ba62e0f1d7","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^4.1.1","generic-pool":"^3.6.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.0-beta.1_1549291793536_0.2067855059543724","host":"s3://npm-registry-packages"}},"4.3.1":{"name":"mssql","version":"4.3.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.3.1","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"e21e8d41c34a9fe6fe26c3b01d019ae9b6e563c5","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.3.1.tgz","fileCount":19,"integrity":"sha512-Us9eorAgcL1/5V6TCOAU+pr1zN0iIfO/tRKhMa5VhcaQiiMUOicp7bSigyS6I+IOTy7Yn57lVTxkyiGd+vnuNw==","signatures":[{"sig":"MEUCIQDgAuWw/iL8jwWqHSFIiUdRSJ/dujHI3EdOybNvIEnFIwIgQ6IKCYDzhPErROqxUj4iPuGPq31LGeMnK4L3cQUzYvc=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":195468,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcWIEsCRA9TVsSAnZWagAA+XwP/1S5Wkx5LxJ0d+zZAtGb\nXMdYBLYUfkeUKLb4e6e+5OuBmXZENBfsy48ER/8L5/r8vk1gEwiJW8hTQ5T0\n0gH2xK35qAeoHjiO+dRgNjgCOIaeiZil/eKnHmlBu+A/FxwLcrYLbGjXAsXJ\n7zDO+CsE/2lbKQv9mVvp8uWgZaQFctJtXIZai/xJFc7loch0TqOMGg7AT2Ko\nOh+Ih47FsZ88hOCWKrhyezy396rnujdg1W9alNtTOtNRngQ0H4qx5qAaUs/8\nMI4O6cnmtlQDS1WtkRIOnd7XQd56ekIEnPf8VelidUdcV8+ccbGaByTSOTUQ\nPLlkmnp09VroCqluRil+yBWKxSvx+BsHUsJSTaWBOYDSmstKUDlMxAFCY3Rf\nIQVmAZPfye3Itx0ZumsM0AxKEqvHq4F7NG8FONhRMDWjw07AKKe8Yp2PEQER\ng3OmN5sEF3hjXDUEKHaFkQCB89Gg2rgJNmTAOUjl2w1p3oP0zLM1Ww7wm+QT\nqZW2ns7CxOJLQzMg8e2R8NtJnvhJu3uJqvSTxro922MT2u4BYrakKQVf6WsI\n9ebRfC/tsLa0wFkHoffEcqJdnN+0zpKjb6iiUCPgb1lLITaEY+VLM3RtE8dt\n8Q2vr9nG37oin5jpJ4r2Riy+lQOwa/qF8LOVrGy0rqn/Mw9lj0mBqu7sresT\n46OX\r\n=CN1/\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=4"},"gitHead":"bb12e08a1636387a6a3d3558bff5854f3654c175","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^2.7.1","generic-pool":"^3.6"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.3.1_1549304107562_0.9703140394240881","host":"s3://npm-registry-packages"}},"4.3.2":{"name":"mssql","version":"4.3.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.3.2","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"2bebfe84ce30caefbf9a43e38ef6c7c9bfa53360","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.3.2.tgz","fileCount":19,"integrity":"sha512-FMC/nvEjR+yMkkyPsHCiswckT7EExoKuTj9uC1yohtJuySgodzPqkJX7q+tsZsZyK8mFYo7JfX+li6/Xf+Irbg==","signatures":[{"sig":"MEQCIE41I7uNSKkfXqCPXWTyCPzCwJvEeKi07eXhZHEEcOobAiB3qDVX3HpYrwJq+EeAwitzwzN8QEnk83mGJv/VeVeH8g==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":195468,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcZFCJCRA9TVsSAnZWagAAspwP/AxD6JlRbqM+Ijg3i0w3\nCk2tPoew3Ve4IH+6fTHb200R58D6T3kcOua9AXbE9nPP1na41Qt6GIBWgO6Y\nUU34yOEN8Zv8VDYL72EQImlhTwznIDKRiTnMpQkcpnDHkHg6Ba3FDYdtOpdA\n/M6MGmlZvoCBsVgcRz38QG0j249pa7uxsDtJYGXhp4VVdmIt4/iTTF0/daSK\nOrvhZO4eyV7lL0wKukFi7/pOeoMgeJWgl4Wbe62JbmLW/iUlgQJICymd6J17\nWltaYGO3qn3o2WfJpx6vd4apxlZGB7OPDpa78mOjH8ow9sICl9hXRu2lUbfz\n4tJ5Ybno36/azr13wD0ynf0OgHwfNcD20RW1XqKUrFxALT8l+tN485Csc2xn\nzchwr7aka08yIzGQd2G9m/6Y4RNJJBmHUvSKSWA+toJPNItSrxEi5GEt8Bw6\nu2EM+fCK8rBscG+vAxouNvy668lll6flsxuD/kqcDdS/DW/lPpOfM8K1ruhN\nMKppyFE9t8fKISqY/qYml+ftDgo6t4XUnk5XfXZIY+yT7kk62NqtB+/oREkH\nonyg4dyb3iSsajQsijCZDb/n4l9Hv0LAxjRuZ6pg8G6vkgs9Ej3eVOuio3pY\nhEa9yHhBFVLCO09EK94TA0/JTnNue/xHdiYz5h1nrmxA/2Cz9PWFydkSIRjl\nswt6\r\n=LI2z\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=4"},"gitHead":"93c336de97b96fc613a2ade87fc2c9f75cd01e0e","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.7.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.15.1","dependencies":{"debug":"^3.2.6","tedious":"^2.7.1","generic-pool":"^3.6"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.3.2_1550078088630_0.7114211223243807","host":"s3://npm-registry-packages"}},"4.3.3":{"name":"mssql","version":"4.3.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.3.3","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"72fae3b6ccdb5f1f6bf0b15ba615f2560c47a131","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.3.3.tgz","fileCount":19,"integrity":"sha512-RuCkUwlCrCCYYxkXhjLc09GcSaFtwaVUvgVVIhyEI8QQ9QspA1aiUDHxV45PkhCu8/phqvSbIvdBovc8GawaKA==","signatures":[{"sig":"MEUCIQDXMa8OxktbhoRiwWwGzOttM/GaS+JKYORoyIb8A3ImzQIgNgliY1uFeod4qzwpD0EHGQ11LYdIk1xxGERdfTyz6xo=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":197002,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcgOfbCRA9TVsSAnZWagAAOZ8P/ixmc5zaxdo5ZYy+BYTI\nfJBawjnlz8/9q10i8S9Tb9WiQkyRaclSeBL33L4V7yGE1FsyUvKaN3T8w+5P\nagkJuuHIrT3uGJXv4KUv1kknL15LjZytdby10i+AZa+YTkhvdlwfS0Vm3MUo\nKBQ+L23ofkUpGzVR+Rr6SGly7A81FhPDqLmNtfxq8/PXTB5segBMPqhgVBxq\nWdTNcZxH/0H2FVzenuZoL4eT08uyTQ2PWCzpxoDCEhLoR2xPie1jnRcc+bQr\nu1Rixz0ncedkPoEvUHV6g0aSeWgOD6mW6kS6sJRorkeY/bYdgRhqph1sYm2r\nfcId4rE4my3b0n03/4oRebiNSUMm5Q/Z1q49l3xpC+gzXBbvLSqLpt6AWpzH\n93R6AntoWJgUvReGvUuK4QiSpCtxLqs7Yv4BbOky9PXqUstrO4Tda0nu9C9x\nN36bSAdtJ6+aXCJUebrpxqgCs5SPWxZkz167uEGoY4THw/1790nN7J54uuZm\nkGyh4v3fVjzYjMwrGTHxsDkplnXZf0IUyCJXNlmmNRnAn5iMQOM3b/6DUN3F\ngUdCOfT5QiEpML+O6y9W8aNr6JImQqw/bomglQ0IoiheRcGlz6vWZbSfawaO\n5M83Z9qmuMefg/oYp4aVgGbzti62bJKmKnibMEDSVQClirH1mWKT7g1vmiKf\nG/+y\r\n=cugV\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=4"},"gitHead":"84d20fed0757a40da30e20b76ca5caa17461099f","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^2.7.1","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.3.3_1551951834608_0.8608906391037663","host":"s3://npm-registry-packages"}},"5.0.0":{"name":"mssql","version":"5.0.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.0","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"185420384e219bd52fa538ed1ef1eda0647f82ce","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.0.tgz","fileCount":19,"integrity":"sha512-KsQyis9zUB9VCg5k+XUn5ZOpJbY1IrbJz+511BsppwD8PQxT+NxwGzGTd8bQa0i76W+5ACPgDWKSBlljzfGdXQ==","signatures":[{"sig":"MEQCIGMLGeclqnmR1ZuAWQmOrR9Ab5i+76Ns7DFQdm5km6P2AiBPo7y2u/uWjRabZ9+oKZIlAA4UYdV48ZqIZgTdfJy0Lg==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":202611,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcgO6DCRA9TVsSAnZWagAAg1sQAJi4eNxvFXrZXpwtNwuV\nL1u0TUQCBEdYcfk5BbbOg02N9Glf5MahzlvFgMaH6zxCSoN/yhsCefIZGcAX\nufGF/zSmkUf3KIf7yV9nFXAhesFwWF5GfRg8e6o5teRCC5qkRAXpf1U2Woyg\nGqmzubOdizPCMLAdBljx1jnW5BCn/tPeJWtOx9/KLQFeNTgvwq8aTa+VnyKY\njn+fVcIXaqrmACAGD/n0pYcF1DFC8zs7Is1+WklJr2U1cYY2TRVGTuTXxFiq\n+hlDje09YlK1cPqRYgeCI/NhjsSktHVnNDi1berD/dR90RMaYEg1BcowqLck\ng6SC/VI65X3z9NyHHLMbrbwYhEpKgKxVmhmNQBIPsK7ff+zhSrjh4c0kSsuf\nniZbriyjr7srGKZIl5DYl01SnsQrBj5wrZdb6A+sih166dKOebv7ui2O1U9d\ngpSFPOUnQq4JIZki5ohji/QxUMa5R4xuxOdCtIpM/dxDb5pL2HOhfGoFa9n/\nwrfS7lJc1Lj9HBw6aRCsWGv6/ktKDQ2chUDFB5+4FN10VllXw9lmDr3G2dlp\nKyd85k/uiNJWFmGfIcolW7cfF1WxU224cfJf+i0XgtJm4Q9/3RWpEkxX1xOL\nPOgxU/0/m9THNoptTWTZI7NesnJuRvJ9iBMQB37VSWYBSWpC/kvfFeVSYpT5\nhesa\r\n=di0i\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"43401b4521276f927e72741640db87e3328ed247","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^4.2.0","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.0_1551953538007_0.06563834034493277","host":"s3://npm-registry-packages"}},"6.0.0-alpha.1":{"name":"mssql","version":"6.0.0-alpha.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.0.0-alpha.1","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"71bb56fca1816e235238ceffd64bcfb6a5a1e234","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.0.0-alpha.1.tgz","fileCount":19,"integrity":"sha512-aoyZq+B5PsfmZKdiiABD5uleGFs3d3utm64yMyLNo0bHyHRBkgu7Mv3Q78Il1YJXnPp6sAg0SHgi26CHGMmo6A==","signatures":[{"sig":"MEUCIQCXNrvB3wYXD5/a7P9XM2GkfkXXO70j4yCie+O8AJeYuwIgF4VtLh8Wq8zMQniIkkAJANpvdqwsRVWnd9DcdS3t5NE=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":203055,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcgVGgCRA9TVsSAnZWagAATCoP/jDxLDWBdtdmFvQOhiRl\n03X8Z1OFiWe8Ab6s857KjH+JtqTKrByRAXpNwNbDcJxlgs/94wIV7FhuPS41\nQ5P5ivDGyaBsPug1ImKYjAPCBDROg7cbjaa9wIDQorcO7upjdspSx2QpluCz\nSfqIoOil0oxQXBNWamr0aE0XklcWUi1ehs5kEzdbBkPC+oHTxvLzgwou6nez\n8kROu2lEgfNqGg7Di1My8NjFSmkTb+yaZIYuNAA1Vw9+aBKcBmtLfEOBg9zm\n+28yaAzeOJ+5cuVFzhB7BLToGkoNsvehRbfKJf478Su7cUksLs0tKq1KxC8R\nkcNTuM7mSC0nSGI8gw5icmmbW5NSctMRIauLRwT9OmVVd4kq9c421b5CQY94\nP/wxMH5sOPyKZMgyRRRzJ2GRetlbCFbTyt3Jfafcr95W1xmxMMqFsNj5ldyy\nJ54YegauhAItJZNdapU+p2t51O3C1//IbqHUBbzEod/ZjItfJftKtSWp7D7T\nf9PRMzOUrTB71yEGno/xkauqDQr2a1FaLbT8H9FnEdhluSA6iSj/Tf9mpB7l\naLPlBlhw8EYJQHb1vxGHzY5dSCFO7ezR8A/Pk8xZTAWr9pn/pZ55e/b/R+9n\n7mV1+W8awNC0U+hb0CWODuUUVbXG5v0hbkDD+Hv2+TnUPuQAZiI9oKCW2aAf\n0Nkx\r\n=x4Cz\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n}).connect();\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"a7aa163e480f8f91d4776ffbb497d7b3337abe05","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"tarn":"^1.1.4","debug":"^4","tedious":"^6"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^6","standard":"^12"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.0.0-alpha.1_1551978911623_0.5635354782073914","host":"s3://npm-registry-packages"}},"6.0.0-alpha.2":{"name":"mssql","version":"6.0.0-alpha.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.0.0-alpha.2","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"ba5b325cbff566bba58ea4c0e9ceb5c90e091b5a","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.0.0-alpha.2.tgz","fileCount":19,"integrity":"sha512-xrScNRceP/p5nxwXpRLPnx4vqCkdyqYAyodGxgcui4ebocXpLOUiSHuERZLnEwvsOHXpAnXjCVaUUespLXhJvQ==","signatures":[{"sig":"MEUCIG7Li4ksguFYMQbYlUp7trY+tc7+7ACl3QjBwui2byhMAiEA0x5z98gSyaEayICHNIAgBN/Pe0tODtP8ytNjgHRPqR4=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":203609,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcglAvCRA9TVsSAnZWagAAqSAP/16LGTZnfnqW4lPBXBh3\nR1e/PhNQAaDc1BYRiyVusfu7B2DIxAqRXVCsZWlxyb0w2wdnyPHWa/T5xQ+F\nJrSm9IOyHwxZywuvaPI3RYGRO9pjrwHWD5CQ91m/Qi9sgYaddm9jZXWJGVRQ\nFR5Lp5owyxFnW+B6wWW+F+u9YY8rHaKfXgW4YDzSFSNXfIfS6D+KuODL6QdM\nd2/HhcgfTJR4O7cW3WnkIkfONz31v99/Dl8FC2wx3KTdOvVnVVbr6b/7mJmW\n8AzkJbBB3xQCH/oyj+PcqasE76P4FPB1xeUAjvK+PNry2FcGoNf+TJWk00w1\nwMWtuwP3Ev5sUH6YajXpqFbBvvg/0Hp9o5O8fTsIodaNR1wRuaxu421ocyCK\n7yN5OTt8iH3IhIxjgT4z8dtU+umYeN5knDtBZhZu90CW4bdVo+BVpwmuOvLv\nN3Ij3AqtaJomubj/YYzjpLlP556gm6JgdLueQIylhjUnF4U3ZKE34raXr4fF\necECCFpKzScb41WvGhfDJjOkjqDp3u9UdwtCmoEIdQodJWary3KVMmIXXA26\n9t+LcUEpt2mktvUUoUBdbXOyZvrfe1hPaAE/+cC0gSgS0UOnT0yY0IYYnKt5\nrGQm0WkVQevlpd7S18yB1GTTBu/beIRKvVuTFzuJaqWGP5oFgpdl4Ze+TiWa\nREe5\r\n=Po6p\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"1232cd8ed78881ad90c10ecca0574fc7716b49d2","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"tarn":"^1.1.4","debug":"^4","tedious":"^6"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6","standard":"^12"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.0.0-alpha.2_1552044078600_0.031890098076430284","host":"s3://npm-registry-packages"}},"4.3.4":{"name":"mssql","version":"4.3.4","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.3.4","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"fbeb8929afb953ca88b65653825488c60e7256bc","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.3.4.tgz","fileCount":19,"integrity":"sha512-b0dapUZql8WHCxHBAvWTf1k33UGOdMXyseW6SAGhneK6Z0qpsnVHU4I3zK7sipZeIzwROOrfH8bkMgK4ArsddA==","signatures":[{"sig":"MEUCIQDrjggp8mSfWc14kwkqaO5TK6uUv8EiCXFFmps+dJu7HwIgOC8URGJ9+72Un4zDEQCVwhNKv5dgEG7owk50TJUeT/k=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":197113,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcgwahCRA9TVsSAnZWagAAluYP/AwLwtrUHzf4Ptu6HaGu\nKG+yZ9894KbiQAJslmamiidjBBuL3efUENEPSZ7TVzWdr5T1Gy9DM2iWBbIV\nFlOyuNx482Qkpg1aFNZie9dv93ipSDkYJLGIkMLsm/P2eZrnRoAUBliw/4NW\nEjDgbbfUfRkVIXymqumZqQW9GnfCBW4BmMC6HYUyRbWaCiqpK4/FcaXEOt/g\nmkEqLKWCRtlQ5Id0BB/GqfvomlV3c/D+2gGqWXS7wp3fYEIw1Nb9Lf9JbWvE\n2YBSa10GZybVVjsx2JC403KI3JJtViaRS6hp17/99V5JBfkvgu1WwvWHA7MB\nL0FhenZsNjFFev/ZxaAKSg4qxf9CH6coDjqv1SI36FJrAewvp1R4XoIO7o8i\n9xR+hnulg264MZ6X/ZTlMZ34rlpq1Pq5b1llTWYtcm0DjUXdLpwKMEaZhl9x\nx4xB8Ah6dNxsZQZqGQpKKir//V2rbyLSdFpjO7+Ytj5D1bDW3uuDdw8szHUQ\n+La5v7cOz4NaA/LqoGrBrnfclLFA1Ww4nyJgrwhQG39ZMiGATpthYMCsm4Fl\nMdy4KZXtfzMrhVbs6gVimOk2+0CtHTB9PN36jR6DMdWpzR1S9vb22rTgP98o\n5+7qs//Bh2Vt2PvWGUVGGb553qu0UNkMNK+rF2EztDQvi/UzEpxfwuvvrLiT\ntJgU\r\n=8gWT\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\nUse `@next` tag to install the most recent version with latest fixes and features.\n\n    npm install mssql@next\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n});\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://img.shields.io/appveyor/ci/patriksimek/node-mssql-o4dhf/master.svg?style=flat-square&label=integration\n[appveyor-url]: https://ci.appveyor.com/project/patriksimek/node-mssql-o4dhf\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=4"},"gitHead":"5acacb4edc2c23bb4b53ebc51e1d0404f650db08","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^2.7.1","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.3.4_1552090783485_0.7101041352136375","host":"s3://npm-registry-packages"}},"5.0.1":{"name":"mssql","version":"5.0.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.1","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"dfc63be687b9f0826fed162781a3fab4d0520a12","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.1.tgz","fileCount":19,"integrity":"sha512-aI60prpiAR8Sw3WgaXJJ0JSQL+x+iAusASXyHqxxQQvH3NVeQlzjQNSWq1w0VzTydrp4z/YCDL5SlFPBWnIRMA==","signatures":[{"sig":"MEYCIQCoNTGY1C/2/wmO8z218RXsfCMceq1UWew8gakhTVVnLwIhAKB7PFCuG0yc5naeSYpFEUigzlIcsEv8F4nicN0kfoZa","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":202875,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcgwflCRA9TVsSAnZWagAADlcP/R/GsV2aTDE9SJcKxpBE\n9amskUK0eMcMzFj5goNlH0J0YqY8NdHpzfUfzmEBBqWAtdx9JAi9Y/b7RrUX\nLLtgAH28MBklQpU1kGOX09IWQS3+4oJle6cD5JnCfsI522hh9rCukjPEIXn2\ndfsgVSOYoyFuULlwXomvlKoMwkLtvQeHDzdscKejJf+sSCdgmocxCmIIadVk\nytN22uty+/K36fatsRV1fOi/S1M3TdVAcDYp1jmMXrxE+UxzqNQB1NcyqOZK\nRJFhtPLu4iIliz+QJ2VOwglF/YXWbi0b5W/lY31wZvmZeKl5UwCLgE6Hjwyn\n/lc6Hd3ctTiU2L97g+JGwN2pxsiFQXx0EgEWTjvTt4Rhewy4jCWeVQ83K4i1\nLrJZQEl3HGifX/pP3JUcGCdJfRdUtUQbNQ/f11UyktqesrpWTayV0krS4+QK\ng+1JVepSqqeEyrIzTaP5ich3gesIDXzkxrPY5WTUFT3FlllYAINpR1Lo10Y0\nqVMOq4Pucvheh/c/6x84VG//ynmzZjR93CCKlRtaVH8bfhb6TrgsQ8lvf7Rg\ncP5vndeGnlbpapDdE6BHgEbjz5zwLf/YhqhMLVrhrEoSQI52PTcOpcoBqJdX\n6MiPqKc4RPyiTpIH1ejEUJoI7xb23y+AGFqccKJ3OzJy1Ydpgu59jAexD8qs\nQCQB\r\n=5InN\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"ec3494d1346dfcb7c97b3cea4472fc1f3e80d805","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^4.2.0","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.1_1552091108904_0.5358735186719585","host":"s3://npm-registry-packages"}},"6.0.0-alpha.3":{"name":"mssql","version":"6.0.0-alpha.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.0.0-alpha.3","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"cabc5815497cfb1c7c74e1c65d2cffc621ccfbf2","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.0.0-alpha.3.tgz","fileCount":19,"integrity":"sha512-PE4i2J5nk9ITx2W5UyKTNYTe8/SW3ZMZ6XHwjML3fNDKIfZtotWy5b3Fw/U8N2i7VaN08+bmta71yTiAJt+ExQ==","signatures":[{"sig":"MEYCIQD9DmqNfgwT4cBgc+s0RHwI5WgqjAcoDCKGbgNIX+WFOwIhAPt5QjHgLdaX/jnJ93c2B7SCgxijPKA22P+BDSGbYbCj","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":204051,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcgwijCRA9TVsSAnZWagAABYwP/RN9LeX6Y742C9n+0sWI\nCvIw9nCd9QSUwZ/tlCezBbFVsBumX6ekznqxHO3ueJoyxXolXNXz72aSyOIW\nllFApRh6OP1yJbVvW+CT3nRplYJaLRaFGhRGl4CiA4EQ16JW3eJCHKse89pW\naGiSu8OTx2TZXxv/Kfp9fYgupfiwYq9G+smlTfP+dwep4hHGFJXT8XmNdADd\ni6l7ixIoWR3iOiflLHizvZ5fLJ0or+bsTDAXdzjU/hAg+LZ6v4/Neud3Ixlt\nRgyiHL/XUshB89q7Vb87ScTzYwzGBasZnI5OonN8E7ToeRyGuwdB6ZwGJe0i\nD5F7ZzpOQPPerVo/2n3ngLtPj8f96eg+hsR7V6X2BbcsDTD9wTdkyjvBxZ4T\nj4VLLqOYe9E6FAqx9gtVA0Jw5D0scMuytBAV+fUX4RguJeMW+3Pdtj0f3PY7\nDrQMB/9922Uby3RaCeGtMlYed89LFYpmDK4sXe14EKXHcG7j6DiX5wAUq0fB\nckgxuv+K1lXd0JV6BqHzqr9AvALuujkNx63rAC+QluV4oEffdhpCrtCf6U3t\ncnQKxU9L7ImCJRMSAYn2SeegOZOljTE9hV5V0RcmggfgLDZqjEv7yi/QIBCU\nYcM+orN3B8ti47ZbP85lrBDSN0EnKaZBnYd/3mdWVdNP4YzBsqaeH46pnin3\nu0Ah\r\n=l28o\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n}).connect();\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"fd7999fb805f262be212c1952008d02ea18ec09e","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"tarn":"^1.1.4","debug":"^4","tedious":"^6"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^6","standard":"^12"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.0.0-alpha.3_1552091298192_0.9988728891954717","host":"s3://npm-registry-packages"}},"4.3.5":{"name":"mssql","version":"4.3.5","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.3.5","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"b044b308fb37685feca542edc0822b25bd890e4a","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.3.5.tgz","fileCount":19,"integrity":"sha512-eF+hwT/VUDiqDDWHDNPfM853+ha4wg7k2+vWxKLbkuN/A8WbPt+/y4pOqsUIH/T03u9hDU1sw8SZ4FS0l9sXig==","signatures":[{"sig":"MEUCICqVEHtqVlW7j3GOdsP6aqwQd+RLCqkgX2FzqZMrN79AAiEA7H5a9hsi0zzqak0gR1kIfnLKzeP9jrKqRTuRblJGAQk=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":197239,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcg733CRA9TVsSAnZWagAACzIP/R+ctu5RXRSutyRYuBzb\ndGkMk6Ruhjy66UIx+bP/j+qXo7Fy4H5u2ooLmAVurTdWW48FNrjhuWaWAvsZ\nqGfz3AvwgCue+mkxho++TAAG9d21rKf6jxKtf55ZzGWyD3sbTBFpO9VMYF6V\nx+3oAhtgOifR0eBWoGx4ddVWCgjb3ODTFRHk/u9TBqMPh7z7u2ZVSVR5Oy7s\n6hdXulaB0Naz4/6KQPwAO91ChS1QXdXTNIiJA5CKGW6DV3tPlFPlyfOOfxN/\n9WnJ9ii5y64HUD374Rwgg5QsFSUNyuXgP4VIQXCXBExRu4Sb+OMIY3h3XvcK\nnQHVGk82Y30C893bwuqSpB0UHnnmYWB9V9oR7cqKsEduKcLUbEpxEWQ9PJsV\njzvOQO3YsGNMq42dXk9Y64mdP1xD/RxTrwSggRRMnSZQE9KGJ0kyZy/tObMv\n4XW7TzQPOen1K5Qc4/2eYQjL0NnpnIvAWnCTtCkMLx+MUxuoGuqobLo5BSEW\n1DKzkS2VVEmtwwT9Y9aK1X0p4ZwxS0nQVnOCeI5pwHtM1ja431YOW4PfosHP\n70oYCFoSoysiRNSXFlecXf+2M30ktInkl9ZhiESVbegh7Qhydi9DZrPnvtbJ\nK/3zX64CB+1KtD80PFrnIaUKKd/RL3aV2+t69I/IhTKYlH+IP7aA/fPgxp0j\n9+bD\r\n=HyRh\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\nUse `@next` tag to install the most recent version with latest fixes and features.\n\n    npm install mssql@next\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n});\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://img.shields.io/appveyor/ci/patriksimek/node-mssql-o4dhf/master.svg?style=flat-square&label=integration\n[appveyor-url]: https://ci.appveyor.com/project/patriksimek/node-mssql-o4dhf\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=4"},"gitHead":"b25722458b7840c1b44d9dbcb8610aa6c42596ed","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^2.7.1","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.3.5_1552137718084_0.5629673938584052","host":"s3://npm-registry-packages"}},"5.0.2":{"name":"mssql","version":"5.0.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.2","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"d3a5b2ad02a7d21eda2f30d387272d8825fbbee2","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.2.tgz","fileCount":19,"integrity":"sha512-qSgDJLwTqCODNREozuuoDkQHzX3ZU9D7eMuAYVimfiIz64eB2wIRDR1FbBrIdgMIhUVQeDzVR6YN0z3cMSI9xw==","signatures":[{"sig":"MEQCIE3wSCm41dvjHwRH1VM1rH7sb9Yy+ltQGmop01lQsadFAiBZog6ljfl76aiJKoqLpthTecnrzSfuNpRepGcQ67wQsQ==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":202989,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcg75wCRA9TVsSAnZWagAAqkMP/1HZ3R6AvimDGGHTUZOM\nox2j/llUh3i0J+xtpIjUuTetVRP4d6TeOQGukBAotZPmxM6OqJdv7j1CWZ8Y\nL1ULN1RYyI5v2jPrmhEYrcX6S8Ll3fCdESORGiFmDOxQA8sT89f3LKX47Zom\nP1apTLa5L4rsUWCy/gInf6y+2pBh5CD7JzvZRKg9DktSbbinpSaL+7TTcpFr\ngxTrB8SkBZc/NiMR+4Q0pk/Vu/39uo69BvP9jOHteqCsyXVAfxeE9K4en7t7\nxshvDNZ/QqfC/NWZAwWh/b3KBVK5S0r7iL58xS4lzV163s3C6lEgzk0Q3lkW\nUng3DIbJorOrPy/rGeyy1M+BB4QC070z4HamnABNSZHz26sTgEY/KEqgr1sZ\ntYmHmpOSXCN/+dU0wgmir20DWu16uQ5VXJs3FfqQsADRzdkeVgqq9YBRHKSW\nJNj9LF8pHNGxtMVypSdDv+SiRUK3LgUf33hEge1tR7Lm6y5OpPH4kPOvlGw/\ntui7cByGBWYRyHSnsMvWhI8plRM4l4odBRCAzZFNXnsk/nvOBy80on6aCOJi\n7RUrAj5YL4ao9c+7iaLrc2XGE0OLhAfiPcHDPkXtsgIkms3hhuPHu5xOpVSf\nKCFToG5agLILk2AFIp24nfVaKfqtuU0gDNUkPZkUxCNFhC/NENnGAJiH3s0I\n3rU2\r\n=9Pqj\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"2dcde73d8832328de740efe3c425c4d1fb4869e4","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^4.2.0","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.2_1552137839066_0.6529907185231587","host":"s3://npm-registry-packages"}},"6.0.0-alpha.4":{"name":"mssql","version":"6.0.0-alpha.4","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.0.0-alpha.4","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"909eb401367ac99fde842239e7a2ce904feee82b","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.0.0-alpha.4.tgz","fileCount":19,"integrity":"sha512-qYjHze+A+R5ooUv8U57apt3hN9VLL9A25uZ4t7qIXcEcwkHMqP6b85ds2ecj5iAP/zkwYuNPwbLCgi0Cb4/2Pw==","signatures":[{"sig":"MEUCIQDBYOAdAf//tG2rfcxH8a/wImrt/SEHRO43asicz/3UUAIga6zCCgmhJYbvmpyDlzSBv85ddq5TA1JNkMF4aOtrgds=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":204232,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcg78ACRA9TVsSAnZWagAAlrsP/RYOM07iYOmsF3FWdEn6\n4Dn2UoAh+Ze9NkgB195AJE8iv0ybcjhDmZf5K++DjIsWm3uGnnlcEmMLXchw\n5eDiGx9GkQLqQueMNFSD11Sj56/J704pK41LSKsO/hWnm/sFeMEUhRoimRf1\nXZmj+eqddpWQscezAbaJ51xJEDWr2cZp7BwBqllOgyv2k7SRiaqM0q/MHOhi\n5TsKvBMStE4Pxm7iCfrv2+Ggq66+bJ3d2fxj8LLlTl0FCNsC0ENtMCz99U5p\nS4Z/jGiJ8dJ1zvGD9N4TA5LKEm3gykV/F/TfEbbjp4xrH258umPaoD92/Pm5\niNbb/K1El2Yxl61fmlgYRgssc6G+al5zWXn2oX9GZFiARo8La5eM1LPU3Yyi\nTtw1JHBktrs2mhaQnpLcT9h3phe9aubSWU2/T9El1GL1Bz4indwVsUW6JnUM\njkFcl+SU6aTXPpXRTeC0TYvJ9veovM/66mZFIOrV632Fs9L1LRG3Y+gjOaHe\nzojjSSJiwgP3Or9KbLfMKcHHen+3pT1XWgdjmZQiSdTcYY3+S94fXPOcqGmu\nVLm9QDGPPJ1EvBcZrQVAZ5vGlpoFwkrKRfK2wEZBLc+cIusENRebNpXuXn44\n2Hs+YtqRIXjt27djDTFKH/o6fmuSzCOkDCdOZnjo8p2lJGznGhsiBs+ZXY+X\nBFNd\r\n=eIF+\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n}).connect();\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"091674bff49e2e2d101f0fd9f389353ffcfa016d","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"tarn":"^1.1.4","debug":"^4","tedious":"^6"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^6","standard":"^12"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.0.0-alpha.4_1552137983732_0.21739932771256432","host":"s3://npm-registry-packages"}},"5.0.3":{"name":"mssql","version":"5.0.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.3","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"c13c47743ac7a8c1319e1904e8d6263b01b480fb","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.3.tgz","fileCount":20,"integrity":"sha512-glA7ojGBP8RYJa+XSoFNpquNYSQki4BQ9DMfXecy2cGa3nf2a3szamaualBANK1acXjXEXhheCX446vYN+LGYg==","signatures":[{"sig":"MEUCIQD5rRx81Nt1EDOHRganPy/6zibn+1Zug4c0zrA9WBrCrAIgDJQptDlevk6elaK13t/ay2yBlWaP9aX57o3yuTXn5pM=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":204857,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJciP0hCRA9TVsSAnZWagAAxP0P/RtPks/Po1Sl6lbgCCRB\nJFIY8dj63RBwFTLO2VVoJZ9+90gQiI9KuQPTnUvUD//Tvo4GnlCaKcdYUz3M\nT7xyRCCMkMilTmZCx/WBwhZmRhXgR1hLUvlNUY1KRwdkq5+Gi54w384A2Tgd\n14A+Q158b+AaVgmOHOJ+sGFkSqe+BPRKeDDUIp0uJhxfARosCIcYG+Tlyxwv\n+c/tfFUypeQ/VgZmiKLXzSae8s5RV8F8ueBAq/AybvQlit6STJ/V6qdrGNbP\nAQeVsmpwfJZRbz+QvoM3tD1APn24Abd9Hos9101ft3ycBu28C2ZmeksHFOpo\nn5zZO1U66LgpysbUNj6bHV/LsWnWp3+c+Uw1X4AD9PWwMQXq5uD0RklhHp9j\nFcbE38JU4mXEA2yPr0mAdDy2TCCGkqBECPFPo5ivRjuOObMvyr/7l9rDeIZ7\nL71pcHN6ZoaBedc3jF8nNDVlilsFUbNiL68QqZA0j6YlF+rIqCAsDxC2BVue\nxx76rQ5kOcO2nOAF2VcYsRo0DO1s4u+ZxFhc0r0rmwAr/DvWYVl1LZuMRTo8\ncwTlzcgTnzOMpgF43YM5CpN9jdcKiwLgDKu8U7vj544e5QotrXKFBpmUjBnx\nOYzgSWNqawJwsG1YLfGY8hKqVGKwUb9r/sAOerJI2VunvuN7+F1lqGUFpANO\nTA5A\r\n=qboc\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"d5f844ba115678146dd1e5785ad33cabaa5670e4","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^4.2.0","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.3_1552481568006_0.041196979734906325","host":"s3://npm-registry-packages"}},"6.0.0-alpha.5":{"name":"mssql","version":"6.0.0-alpha.5","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.0.0-alpha.5","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"4f73fd9e31f7af31aec7d0ef890ec1d6eaa01cb0","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.0.0-alpha.5.tgz","fileCount":20,"integrity":"sha512-RObrr8crVsjnMjJs0PPanzmJnzClNGb3tEsGonNJ87m9XVUduVTuf9rWRDGut1iqTgYxf/kHnZ9ixxU986vq6w==","signatures":[{"sig":"MEUCIQC3sGcBtg/uvDTCtfUNvax9cYBGNihrKKxcsQjZQVVUxQIgEcj4PuK1GPWIZlYyOM/lTic3v4hYw2e4PFvaLGW12Sg=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":209533,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJciP2rCRA9TVsSAnZWagAAS8cP+wbTuYNedA/GhAa5AMbT\nbhSMrmZ3XVOooTLTuIbt3Vu0HKwt/C+uBdawaorjtUsEUKwMLuUP1Zbe5Nrc\nBMkGQznpCpFRvcN3MsCJslca8Ft5baVqT+i0adF5B4u7zteBALUNrZFCTK0u\n8Kyw4mIVcX1zXrCR5EklUI3HoMWywXeS73WowRzMnHNpb7YWQgGMcFpgsid4\nMIYpUlnslnXiU6iP02NrBowbeVo6PMDTp3zCqGgtSi+CkvJxqiOvwpavARsb\nXURuQSWqQOMhilPj6p+FPpcemy5FemvA49czy1t8zIvLLom/OSiQsw1ekXJY\njpwipQu9lE4DDh43akK1o7siNP521pDVlx6BfktGu/Avov2oipaBjIPrYAD5\n9JW+ra3FVeJtxsZpVQIiuKY6UNpIRxhwluBUmmij1gwHWvJv30HDEBydS9wv\nTql8Be4jjGQdlQ57HRCpCR7Ar71n39YIkmIhPT7Nv6fGhMdynsiObqsiR3g+\nZzruLT0CARkRFih4WjODlHUhu4Hm2ecHNZA+mh69vgxt44ku9+QPnqth0h4C\nLnSlH2yRmpwZ9BlWGoA09iHjBP5zsrwQEbDotSjwdLZp+jeyg025RW2hiRE3\ntTFwuaNVVVNFQREV7yZS+XyMTYZzNxY2/pWhAT7ZSWkdtRYgN3ya7R88dooS\noAHR\r\n=zwtE\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"b056a1a2c11ef192553125268d2c3f785e643771","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"tarn":"^1.1.4","debug":"^4","tedious":"^6"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6","standard":"^12"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.0.0-alpha.5_1552481706911_0.9710146830103137","host":"s3://npm-registry-packages"}},"6.0.0-alpha.6":{"name":"mssql","version":"6.0.0-alpha.6","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.0.0-alpha.6","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"69b096d42b9eb6d455d1a1a9342c253b5f86a7ed","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.0.0-alpha.6.tgz","fileCount":20,"integrity":"sha512-xvNerJsXAZaVe9mu2kWbRtFYSxomBojfNfeWeNc3fhvx4eSm+CGuUcCtuR2w0C8aGeMeNx75j+3if0r0DKr/cw==","signatures":[{"sig":"MEUCIQDykYlAysY3M9Dctpt12zoRQIoRLt36Mx+e4804mwE6JQIgHK8GJ0FmvWs6CbRPbEz11t8gJdMZUsQv2ql6TKEjaDk=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":211006,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJci39/CRA9TVsSAnZWagAAqkYP/18cG/9tPO/7DtTE3PEG\n1WnFeZpJFs3nmOdqrrA1hyJPWdAas5E9WlunTdBAvGbbVbMpcCkEvmYal7oK\nN441UIfQy00g7kQfxcuqt4ExoEk99nP2yqBOZ/aGZNk3X+goQhWhICB2KzXk\nLAODMbI99xTcgBmEoBR0DekBW3VSmQ0x4ITyJ2dge1/ckU4DtsX0SWZ73+XK\n4FdyKz70ZVgNcGjOwSbYuIpdAEdYfL8IPP3kZumckFkCjNLPMMiY+ubs252u\nm0EACGuJZEWBTCcwHCYwlpJrhX7BtTxfZODgEbRJFgj3tp+kDI1Zzb4gj3GB\ngcUSFhmvaZjB9B+WvvTlD/hqUXwDlaqlrhisLGpc+9OeZ1rCzmZRKKF3JWIH\nvzHRasBHJh6aXjhI1qdu316gCaXtA5615GSTIQFovIGlaH6AN3WZnYm9ew7g\nJrl6csIfOMHYZdz7/6jgzqCd2q0KIvKfERXn0RkiveIAVsvHdw/EY6GpYguA\nFqj1wI6vEIdUx7NV9iNuYqJ2y4BJW5nPVJKb6Vw8I7A1PpqEVFHU8NmlpxD5\nrmxwsYQvuuUnbPfnMlsVDHDceeSKKPHWic5cfEcG/d+7Rbfq3Zc7UylAAbtK\nNfyxY8F27fEciTgVn3MWpfuJ0vZGrhOSRuT0SmtNvOOz5hIBfOPkPL29H6us\nWU2u\r\n=yqQM\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n}).connect();\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"9d7756c99e4cffe5f9510e2957d3cc3c12d86a8b","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"tarn":"^1.1.4","debug":"^4","tedious":"^6"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^6","standard":"^12"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.0.0-alpha.6_1552646014803_0.7861960996946824","host":"s3://npm-registry-packages"}},"6.0.0-alpha.7":{"name":"mssql","version":"6.0.0-alpha.7","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.0.0-alpha.7","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"618dc374c6f2223e8868022543cec0f4dd6851c7","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.0.0-alpha.7.tgz","fileCount":20,"integrity":"sha512-+4lRMaTAHNHteXyr4CzEJF5hxfkoh9stJQXHxcPA/3srTH40Q8FF+yGw4337bL23pGs+3KMJ11NGe1KmmOBaGg==","signatures":[{"sig":"MEUCIQDXV7VHPaqhxA/bRlI1YiLeiX/5YXSusV/iK1Ri4dvkJwIgN1yDYbweNMJBQJfKxL4cuf4L0llGrFMoiMW99P4Gmno=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":211010,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcmNGPCRA9TVsSAnZWagAA4LYQAJqg/YDUu5q+vrbuTPeo\nADfafwtF96oQg8XYbFcgEkP7Jf1TbQK0SgBAphXIPAWaltm9bJ7PI3vIvBLB\nhX05+P7nG9QjvSGZQtPLvIKWfuk6WzI+4BKZiBqaiFpPRjgA18M9Rfteu667\nGfOc4FPZBrJB1L+W48zCGKLOgDeCd24CfhwjaVI7RB2jgZ6S8JDTNo8h+Pq9\nv9+yQRuYDZH9p10Fz6hjB3ScmFhkorXuR9b8uheitn4Lx6SNJclDf6uYXMi8\nm24/CrlZcqTj6RWvDZzyHwvgWE8c15Hr8LrdjpMq+m2yz/jS2Cj0/k8V0tum\nPhVwKVvnVQPfIQAL+StKfsydfVrMCTdUfh63aSKtXhNmXDIiNm7+GpUfI9y0\nsv//h5ImC5qHY5+hs7JBNFjRnRjQNSt1KQA/qCI6feryPulcb1Dkv4o3+eJU\n4f7BKkOcl/xmucK3sJRsceK9UjVzVaYl0wYSF10P1ArTPtkp97DVtX56WypC\n7CVJjaY0XdyAtbEq3fccslOgeqQQQXNftCJQ3Ypfex74GOD6abwFfZAgQ6lu\nWUFEDqtHwROGmbq7iyQ9UeWgwhw7e8FyFOJ4fvSmy+Lwo9mQognHqgSXTqQv\nMjBhxnkU/aaPq7Bj8jyuzFpi5eIoneTwl/cqyBE0e5/FtP9EER2KAlkQ2LlT\n4JQX\r\n=2ymw\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n}).connect();\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"c806b42855d42bf8c1886e5d00decec459109416","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"tarn":"^1.1.4","debug":"^4","tedious":"^6.1.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^6","standard":"^12"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.0.0-alpha.7_1553518990913_0.4282702658781401","host":"s3://npm-registry-packages"}},"4.3.6":{"name":"mssql","version":"4.3.6","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.3.6","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"80477018b4f6bd581c751528e9a43e16995ed91d","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.3.6.tgz","fileCount":20,"integrity":"sha512-4ZgJ2VvM/Uo7LGvyFDXcIJjQ9koE2glJlKFO0dONDt4bAq+r/PQ0l4W3UIO/T6kss25e6DoUv6AE8ngwiepsrw==","signatures":[{"sig":"MEQCICKToyVpPXdcCbsvEViJeYNSxxw1IDpb9KkG1OyswbUQAiASjWkI3qF6wc4ejyhU9hpTFNiAm15SPlD/yfBVP3zUOA==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":198994,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcm1BcCRA9TVsSAnZWagAAoHAP/3YfSyd9X/6o8mcGoj24\nD0BNFhcqaoVWXdZ6wt6DJKjfV1fIJnEeQw67sqgFeE/uyWyBaIuheI9YyDgD\n0g5xA/EsH0a0hYBQmD4UTqoMevmQjXQh8vnIUNkMW0Y7WQjnmen35GsNRVE1\nHbo+DWeLGeBtpmSBLULzztRZDND8rQLMDia7B9VSV/KLHxf7fCRTGcdjmcxm\ngNaCg0S15trvM5vjhyNcmQGtT24cWhMvgmITaCGK/Ke8ZXBdTs5JgETujfem\n7PU3T2XMaX/rfKM91MingbMWe2UquboLiJDpvi9A4gxXUfQQrEbd3a/8ivyT\njoDwvvP+Ree3uTeqePl0M7bq1NnL2jxG/a6pBPVD5vVvzyLHzvcl3BlGaRVl\nYAn0p5BQRpTDNsf6TMQSahQIVsWuuJxoQYaSXAqCL50M3q8RUpkEnKjpTzfY\nh47X7WRRNgUh4FMLF/JW+cNJMa+SKjQPC0ZxLz2uyoEnYEBGh8/giXXcIE12\nMMXG5fs2j1Sm3ahsqRhu6tqb2C189FHdG3oVnccupmvxpH4S2p9RR98OHQjp\nJTZJhAVgO9Sep4a15EcU7QQhwF7NDmKezzcFKKdV1RjFoqpMIitwNpv5b9tO\nSMcavs19bJHm35XvUhiAvLEIyfBHjvkUqiR51FtllyREZ1Rg931tzJ3atiq6\nRFqu\r\n=KeO5\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\nUse `@next` tag to install the most recent version with latest fixes and features.\n\n    npm install mssql@next\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n});\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://img.shields.io/appveyor/ci/patriksimek/node-mssql-o4dhf/master.svg?style=flat-square&label=integration\n[appveyor-url]: https://ci.appveyor.com/project/patriksimek/node-mssql-o4dhf\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=4"},"gitHead":"1f85d75a8782de32e2bbe2d65e444071ef3a5346","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.15.3","dependencies":{"debug":"^3.2.6","tedious":"^2.7.1","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.3.6_1553682523926_0.7962215915288435","host":"s3://npm-registry-packages"}},"5.0.4":{"name":"mssql","version":"5.0.4","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.4","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"d5919dc2b0107c502c045bbd6dea20748b014c44","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.4.tgz","fileCount":20,"integrity":"sha512-HmQu0L3d6LNAff1Jzqum+Ew0qFCHjMgu6B9XlwjVcDn7d6KNLR5GORFZqXhruEcJBaJNK4zGUIOxHgRqFOwjvQ==","signatures":[{"sig":"MEUCIQCtviasqduR9OxxrbmE6gw+JB8HyhXrin+TbO/1L61Q1QIgM0w/bRW5+NXjrdtyvCUPYcvVceo3xHOeFs+smnQdh58=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":204745,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcm1ESCRA9TVsSAnZWagAAyS0P+gJ8bRMN/M/WZH8p3XBl\nQRLi1JNvKMr0hcBdu22XjFq6MWlSXnOAzbDAE2bwAVV82MUxIb2T1cD+yJ7K\nPEWcX4deiaR4YdfxQlTQ2Mf66I4IwqGtceEuf3+2lmk2vvkVTkyBPHnGAmdN\n+xh23oIo5Xiw0p50N5DzSxZIE3CFuFXCz/4Qq4H+7CmN4RT8OX40SJt3Iq9N\noMZgSmJfXTmuO1DDWcU79T+yDQkz5DU6RAKhFioWB6bGB+ZmzQYgcMyk1PTt\nDJIYygljy/qRWwtFA6jQmskQcykL8Zv3PgM8CfZtS35/V1g8mAOXpkhKrbvt\nBbxyUENZgdkSIvNeBORBmeRlNVvOCV2kLdNxVTF7iuxlsGubiR+XyxKBdjA0\nkUnT04ntMHo+lHXFFs/haau3k9O7iPNgkMjCeYERU4W54Nkfdsy6kQSM/Xsi\nFUT+Gd4jXXqu+dsyezYwYCaXujbnTJqp1PBjvyiPIF+6aTnw/vdkPlnnS2XT\nckhgPZoMD4XdKRZjXYXyI7bpLN7CmpOPRDLGh+y9h3zG3RXbbcN4xKfOTGE9\nnt01IEYZYeDDWkeJVLY0ov68r6vETeAhWB1oyaF6uaZY0eSSobfXTHeoDG+t\nJ5lWi+Pq+HU5mGtloGGFFesnw/J3xY87lWMsJOIC9nwOYKO3Qlxpi6gIWiOW\nBi+U\r\n=epXW\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"7559c99c42dc42f51d6fde5424490dbe36946333","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.15.3","dependencies":{"debug":"^3.2.6","tedious":"^4.2.0","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.4_1553682705325_0.1668798954266848","host":"s3://npm-registry-packages"}},"4.3.7":{"name":"mssql","version":"4.3.7","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.3.7","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"cfc60e6f48db7471172158b9878fbb9a910c98ca","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.3.7.tgz","fileCount":20,"integrity":"sha512-+cs1uBD2Hut6UNeCnJHUeikWKIEhMTlr8s1bOw2BaVTPcyau1fFUqt1rQRilEq/GsyGkkzrE+TKw0jlvbW5cWQ==","signatures":[{"sig":"MEQCIDuV0BD5TpJMRmKCgb4Zv5OVL1JGjARUnsyRsm7FdIY5AiBHD7x31mId6scq/XA75am7sy4UCm2kIL0rGv7fRdP04g==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":199183,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcnNWKCRA9TVsSAnZWagAAMYEP/3ZxDiq9agYwcajOEqEc\nkmjVMGofXJGuv5WKPDuzaYNz7uLYFlDfCtp/JsjL0uP/kdpDDhWK2BsC0g9C\ntwjtIbR+0oPyp4rGSLZzH9W8dvSOehOWXyiBQ+6W2JlnqHKlk+72mGZZNYLn\nLlV1LwoEoxMOcqEDdYj40Qm2zyq7CI7aya2+oO9MqytEeJioMVxV36D0JakN\n7NFw6bN00h+eJ/x8a4sd1Q0o8yyfs0BRPjfYbLxHLakUCvG8dzFuXI2+5gpS\nLPwFR4P7UDB0lpfOB6Eb/mHmRNWRmS2WGnVztExgQjhXjA+44xUr36hKIiAN\nSKUeZbH0VZm03yvRqhGN/48F5XVJlu4XjXWZs7781s8l+G4IbBXHfc9ozyYj\nfQA2Rr3HuMIHeqJePO7p3DhaLyXq5B5e44h+JeUdD7RenpnpZ9BB75qlMc6+\nGinL62BdbijeA3SjUfPvAZ0LYLQXln4UZDe1bW92me8JY0kPOirPraZW6rib\n+3EBrQMNbqg28JPss20a4KGUT1pqjy9lZTg8zAM8I85vwEwVKu3P7RdSd/Nu\nkUOsJE/6jeu7lj8eVC8b1qlhPyTCBQm6pSWfueZ1Y1eHIhPm7Mq0398ejO1Y\npSZBb/q8C3504hGrI3ya7d4AxLP6/Z9eNuTblRCj5GCJTD8+j2xBAGvC75NK\nCSjI\r\n=fz7j\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\nUse `@next` tag to install the most recent version with latest fixes and features.\n\n    npm install mssql@next\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n});\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://img.shields.io/appveyor/ci/patriksimek/node-mssql-o4dhf/master.svg?style=flat-square&label=integration\n[appveyor-url]: https://ci.appveyor.com/project/patriksimek/node-mssql-o4dhf\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=4"},"gitHead":"6fc04b13edd97d73e49acd3582ddba12187b2b00","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^2.7.1","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.3.7_1553782153939_0.02712324114579512","host":"s3://npm-registry-packages"}},"5.0.5":{"name":"mssql","version":"5.0.5","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.5","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"04909b5fcbd78834c67681beea036015b559e7fa","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.5.tgz","fileCount":20,"integrity":"sha512-RKkBhoajBW+79Lq9tDxlUTeu/w0xtg+kDC70h9xkKO3Otx5lcmyhH5Je2W2VwE54raWgXbhtXszH6dq9uszXqQ==","signatures":[{"sig":"MEQCIDKkuttDtb43IEVVzha668k2vjgWWjN6HabbvC/vQ7BCAiAfO+qkytKYhaBqGTdRi6BFJu+K1J5OdBUaOqeWsZqgEg==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":204934,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcnNXjCRA9TVsSAnZWagAAdq8P+gMJcpLOMxR65tBBO+O6\nmsBsp6L9nAuVp38NeKMzzbhNAGbUKRHOxNATAqPXXX9JnMdBpLVm+Pdkx3BK\nBfjxDPKDip9LzK/z04/EyeblhthvMZOyXCtpBwXdAlq0iHKe7364d+PgSzyX\ny9/N7x13wifCeNkZB70xROUun2UuKxAImq+rlqbtCeWiLAHORlLLSTbRBsLp\n5DFI0AjG7y9IKAFO80XfO/nW2ZoMBYn1HJY3nSmYej0LHaB6oAf8+fOeWvE+\nItjKVwDJId58Nnh9lbuuuGtcKyA6hLoTfDvF8rsxALuTGxnnzRRTfgu0RojS\npKkzz/VHhAEX4uN9j8mWqXxPVDpQIWcr6ZG+/6EJCabWxNL48/d0xzMvw/CR\nQ4Gz3LRvw4OYDXpgcbgfNvqcwGBfcZFCJLzgjg0t4bRczJhE/TpoF1TnLroy\ncFGOaE4M8v/kPvJyOc7hu+kXr3SPTHdtD4x3Og8ln0w7aCYDh3cPIr9ncOQz\nQc5cf6x6sV0x9kSw2fwTrrzPksc0qdtwaL/1CgGD142Eh1sPBEJPvGfij/xI\n9177EYIuWtcJZCTpEQJVlEP8oJzQJA+fF2PccKlob3/SboxT+52na5g//DNV\nJs1iDwXAZdPhu5GIJPHZ3YCZnu8QkdKwO63q/mV3nZ/Dhx/7QeJjAAU1XqRM\nG/Qx\r\n=fKEQ\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"4c850359705bc27c5bb192e25291f71fa6ce8f50","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^4.2.0","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.5_1553782242307_0.679509354229733","host":"s3://npm-registry-packages"}},"6.0.0-alpha.8":{"name":"mssql","version":"6.0.0-alpha.8","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.0.0-alpha.8","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"05a99428137faaaab9a5ddae648b6231b5b373a5","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.0.0-alpha.8.tgz","fileCount":20,"integrity":"sha512-n0AFbphDNZ0m0DaiGMCweCAJHUQ+NTdpUK/88+s1AsYWTfH2+WdHDPZAeWcmWKLfu8llObRDGydy55U9Nma14g==","signatures":[{"sig":"MEYCIQDRws6Scm/Kgr8xzauMzB4ETG5SQbKFTzlXCQ7H89BU9wIhAIZq/x+T81nAYhafQKOVKTY6KLQwzOuRPS+qgBXJK7Kh","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":210385,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJcnNZDCRA9TVsSAnZWagAAkhAQAIjINS43ERjXkD45OnMX\nJBaPU2ZiyfIloJQQTLf0Q8wxtcQzF3fNtaG63iRnBaWd39ZCrBUiJrNLtY8b\nMYwOjRJG4G+zpvSEFIhY3gbbqzOGl6xL/pKh3Gt14c6Cj2Kf0wjcimZkdXT/\nOoSK5RQyAA0EuwfBKNhlrCfvugAoC9/jxyJPS1w5nvtJ9AyLIKp3IaltXx3k\nKN9qZDzaIFpfnO1/xJENsQXxa444J11I9Bno0zgZ/S2vWtY92ADzDqxsbr8b\nfQeiYd6WxJ+ysTjGBNFnfnc5l52rucD2HFIOO1ibvPgAuSZhzs4FoqLp2NUY\ntbaR33s4ZJMalfX8SnbpMP/B7qmrSFF/iFRsOcrqX9cIelgdQYhWcCJ5LEbo\n3HCkIxYKjV4GhcBq0aX5kpf0fEEfsRcvNSTxv0racY99vnUCaMq/q1QOSL/K\nBncPjJNZP1QjmYlKHGLNMw58w2mrCZ0v+SIfuzDcuHZSSxuBUOs7mEzXnr2B\n2FpqUayrPLnPJ7uUbMwgJ1/XpbCduoNeioaET3ssXRG0SZVTYoxj59+qiDZz\nua9fs22gBjkM8j4qJ5qdKgD70LdPJLonfk9+xHWoS+ae+Fdq4FhXjy+BVUdZ\nmLojEcgL+9dxjNLPKe2g/f7FHKWYXN2GTBk1zU5E4Xwoo68pzV35+jASdrtF\n50qm\r\n=Dv58\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n}).connect();\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"69d6a662ed5fd6183e6a2bd3e424bd53a2f7784b","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"tarn":"^1.1.4","debug":"^4","tedious":"^6.1.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^6","standard":"^12"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.0.0-alpha.8_1553782339253_0.3340202751917827","host":"s3://npm-registry-packages"}},"5.0.6":{"name":"mssql","version":"5.0.6","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.0.6","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"5bfdcad884f011550ea673cb2e8d900782f59b78","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.0.6.tgz","fileCount":20,"integrity":"sha512-mkBeugMI3EWq9TWPedPZHwR2Zsujaoi5E9pYnfYP+PmN4HFYafx1yBQZzr4F2uPwM3n5tVuhop2jX0zq4glxuQ==","signatures":[{"sig":"MEUCIQDHBV2L84n8hVpY2yB/u1xy0xx09ZIRp16DhN/cESkdCAIgUxljP+65DIh9mNr/6WTi/S/p1dIEYG7dCj8G8MxzdvE=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":205160,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJctmSUCRA9TVsSAnZWagAAOTYP/RZmlrEEyfm/y3rKYKcv\n4IZp52ASMX+TVRvalr2Ylcu+3Jy7f1iZo6SgwdncQI6qiWWEPJluCl2N8AXd\nAICXmvGMLpCQIIQG2Lp63XbOrChwJVI7S0GMtrNTIn/Qj1lRe0Z9vzqFN9c7\nAGU7dJ2jVR15w7717iCtEI8BQ+l0//EeDf09vzsFj0ag3QAl9IpuhgpPVtf3\nP9Hw/BaPoAD8oD8C+rNUI1ljUyz8Hh2S7hwd9u325QAMzTXoWoC7DPMoCjNG\nFN16P6rpN/Wt8HW4xU3TTiuZTrD6SjwxA5kUy8sLF22tz9gPs0hn0M6A4m70\nlrPbA0oAd+pc9xuXUJlgnUZWzet0SGKbLLyPPT89acIInQCFz+oKKiCXcaw6\noMGKymxUDgNrVGvq/SsaZ4XDjq6CBIV2in+m90MgwnOtgGgrbtX2KHmi7T3E\n6ZEgNPrS019/r7plnih/Fefllojf3hH3qJfSyV09zxnwfNRaNAilVLfrahc9\nGf0n3m0IFGcaPr5NbUpRLHyHxIAi52no/7SMZI7rE0W0vWczguzChnQddG7S\n4CITjkpkt2/PFjbu3yvMWMW/G3F0sKMedN0KElUoCJRn4DfGDTKRo5ZAxCwZ\nCqzpBmAIGw2Z04XMnHVJMwDiSRLx5Rl1wOD5A2KnU5583i2Ux1ulXQ5///VJ\n1KlN\r\n=qkHo\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"0a5ca2b715a19aca65bf69da5097209b11d67c54","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^4.2.0","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.0.6_1555457171576_0.09588636261248262","host":"s3://npm-registry-packages"}},"5.1.0":{"name":"mssql","version":"5.1.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.1.0","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"a06d75866802a8e7e8b69df6a2dc7d2ada82bc4b","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.1.0.tgz","fileCount":20,"integrity":"sha512-eHrqRWCEBaXo48y2ZBaDleFvrWm2vYm6dNm1ci0XLYxm6kUb4KRsvjl74iKFhfYyuF9z6qzmTe/QmoQk+YVcVw==","signatures":[{"sig":"MEUCIQD+NMBJ8yWd7c9h2sJynVZNFBMhTQ+9PffSYchBax4qUwIgAidvt9uz3oNLtJnbQiAKmHQ/WPW0TBJrn6PkMgmpeyQ=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":205265,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJct2GbCRA9TVsSAnZWagAAY0MP/2ey/k1+eP8YvjOVkttO\nRs8mMJrNi1Z5sKSfVaw8UeHRPhIxmPD3LhiO81wRigd8n1uILjeY8RE/puCS\nt1D3TCP9FcITV38R2MM9I6sLkVH80fmZ02D/2q5vCnousxupLbpvEBthia71\n6i4RS5dnedIfAROol0Ey/5oRC5tFxLr9e2IUrTh/KQx4xqUlk/4bLZ7/NxYc\ncddj5deuEdeVqZVeWeL1+ygsqkBwJtHCDTltdDPHU23SsQBMD4rkmzcEulI3\nF+XTVT1Y6U+kykxWgtHrBqBKJIPc1ujuHveL2Gyj/8MZUINL5vyrr8ItOoFM\nT1nQixbB/pEq4Ym+30KmjDb7EbRuGBpmKHOJynDBf6xM1Bt91w1LjfQ0FRn3\n79LJM0XkrYW5PQCdeqfqxWwu85vVar8W+IA0ClhbIjTLNgz7cMBuieEzqhS5\nORBENRMizgdTJ3xL0Z6AwJJWDcZNpQmrkKU3r/ZGclDNdit2Xp/QWw21v+ON\nbJsraL12o74TI0Jt4L9ExLWG7QgI5LBizhTcdUxvFip2tBL4IGpQGwbshZPq\nRZwe9wNawlw/LNpA5kol+S+QiLBakJL9ja0x+rsGUSQBoPLdcTt3g8NpR3xa\nd8r69pZoNh6iC9jEHqkRstsMi+tGxTwMJsO/51XOLCL4syPVFf6bCO8Q4eOs\nqB3P\r\n=2Vn1\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"7286c5ac9e8a3bba813fa3f23de34bbeb06ce879","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"debug":"^3.2.6","tedious":"^4.2.0","generic-pool":"^3.6.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.1.0_1555521945779_0.1307351900607796","host":"s3://npm-registry-packages"}},"6.0.0-alpha.9":{"name":"mssql","version":"6.0.0-alpha.9","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.0.0-alpha.9","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"6238049e5f81b7175f3e0d58a9a63001df8f9f31","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.0.0-alpha.9.tgz","fileCount":20,"integrity":"sha512-SR/1MH5jQq/A4/3I44XkkQdiucPhOpxBc/lE7Z6k4NDgTxwWcVsoC/NnDdr9p+BZ1nJ4Cra8aUPCVrBciRw2Ug==","signatures":[{"sig":"MEUCIQCP8+6G7HHhgfjqaTWPbYayBoQOKVPmE3wbBXY/0YMd/wIgQTx97RL4Ut7J+QChHkQL2WVoXuiKiewMahzPMQFT7Tg=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":211030,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJct2JZCRA9TVsSAnZWagAAy9wQAKFZCjJCDbqcYdeECBh7\n1i8hbWlSLdrCT/4py8wVetKapuzStUWLIjJ+JF5HgDngo2Lzznlkr3xPC/va\n+DUFn7Fhh91mjir1R5kL0h13/zTvJf3zY+Qze7xEYib/vY2zD6yrPNS1vatc\nJVt8ySLt3HWm1OljMEqXVt6pstHgETUQWCBwPyRj1zrjUvzy+eZrlkHqi2HD\nC+1eBhlDejIaDBwQAJnHhDzHoHRpTU4GZfmv0ULJWLEMXK5xS1XJTzfBmZq5\nqen4NmYJzPhvd9TXTm7SrGXx0B6qtYrKikl1ZhhMw9PFg6wOp8wbx3H51l9H\nfjTnVwfyQKYqnszOEyN98ElVHUtxN7aXbLVJgm15i0FYCq+yc1kfgRyyv6Io\n99gUVgUkuxn+y7cvwnZE/niX3A5/5dHYVY8WQnO4DDQ0OiFDA9VXpN2i5PGK\nIwoggcWXZL31mH3H+dQ1JJPFvUL0DT0efTvwjsj9ZGtcKKhnSVvE8YIRsN8p\nFcB8+5/Ytk2/BIedGBFr7F66uyj+rvExjS3ULVQl1bsZ4gIVXD0dPzqd7wRJ\nbiq3a11dPyZGm1f38RkWMebQ03LMrkdcK9Cfw4ykTy8jdpeQnGMd0yXaP59C\n2D1fhiGgB4U2figWC09V4/aRVcKHEQdE0gVfpOz33BIQ3gv8LDgkS5v83x1E\nu9xJ\r\n=Na/a\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"41f374105f048a5a4fc682b88bc0a431104fae89","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"tarn":"^1.1.4","debug":"^4","tedious":"^6.1.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^6","standard":"^12"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.0.0-alpha.9_1555522136431_0.08498795994518216","host":"s3://npm-registry-packages"}},"6.0.0-beta.1":{"name":"mssql","version":"6.0.0-beta.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.0.0-beta.1","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"54260969f18715003a853023a3070ac4e5c30fb1","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.0.0-beta.1.tgz","fileCount":19,"integrity":"sha512-9PxTy/L8aHryj+tKo0clVRzEpJNZey1bWg9V8FBlc2VJukCwz09qNlJUuiMN6hEqJRxUUVDtlusadZh5TlorQw==","signatures":[{"sig":"MEUCIHk7Mlo1uWgf4SrsTtxc12gqDw9Y/v8uBLLabzysY1hsAiEAjNic3urYl8SrNZZsOIc9aeIfhb+6xaFOhLmXr7f2upQ=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":210405,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdSo4zCRA9TVsSAnZWagAAq7MP/3FqOXcpav6fBrK45aiz\nNjtrfL6uUptnk5pH8leKlX1mzcWrPf1OOahO9kgiGggzM+J8pfHrUWSisZcD\nhhKGLBNtklRgRNt6+41A79i3Gw8uvfOUVENlf8eVfd3l083NtRdJdN02Zcmw\nPnSyN7baADEIDtBtZ8wHOADuo4Llqd3Q8Z23tYRf43vLtQagdao5hZj2fgVZ\nf88B3xfRpyOZYL+otAa/Kspu8T8bXfZHjTLJBdeR0om+unG4P5Pmk1bTR8d7\n/eVxSJBgW2s5H7NX459l0YO2u5TZDOAcUMfSncy2zwg2pJ//PWCl+DSxlGo1\nzaVg5O4J6HQ0czBBH0sO+w53sNByj6TxL0yuvGjZSvcsNYbY8VPiD9tvB2eR\n51i8fdbMotErNfeSTO33KZ5pHlBJqlTriuVAXHCVilCiPT7tSWNyh1eXce+q\nqRzgx/fLgvaabqMd5aEDB8Zcvv20JFS7x7ZJoOYGgCVK58b6ri0jzi3irtvw\nfMhMxnylNn37AvHx+oOyzQSdhWeeO8t1vei0iUxp8M46g7Y90hbAnuLfJDtU\nLtyZasMZSQ78RqLmVZu57KrS/raOLHYATNfwJSQyrIN+8HNQudpUTsQFunk1\nKdVmw9uiGy09C/KUcffGCmHUZkF3yJ+6RPIPPTBvPjt5K7fIamAD18K21dhD\nugOm\r\n=lg/a\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"fd205a73f367b2e77193e5afed9b8dca19c6982f","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.6.0","dependencies":{"tarn":"^1.1.5","debug":"^4","tedious":"^6.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6.2.0","standard":"^12"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.0.0-beta.1_1565167154435_0.7549163950274396","host":"s3://npm-registry-packages"}},"6.0.0":{"name":"mssql","version":"6.0.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.0.0","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"e7f100b18d45327b8ea80bb75df436b14f2028a8","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.0.0.tgz","fileCount":19,"integrity":"sha512-r2o62C+liexxSQWK98mlocoJjbrneZ9p3+wXAoaMkcdsnaNwejymGuksf42ZpfxXG7Jl8cYA5PNaJ/tOr39haw==","signatures":[{"sig":"MEUCIAsW9+EarYqoqNtCe3hrEBeCEMJ6D0+OS3v4aWSaIr84AiEA1KgUIn03U2w8lXsO0vHIQIR1WEJmV2LrntIZA09aDNs=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":211373,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdwMLjCRA9TVsSAnZWagAA0QkP/Rj4TOy4vEH3D5UK4A3z\nLdrQBwX86T76AWR9xQA9KbUvHUBhVutWJ+pIr3KjJKf6MtyG8ulC0SbjJx0g\nHn7QGHlsj1OpmFaj1yCloQDNlwSwKoSJtX6f4h66fjHElHrqu/L2UgxgJHMr\nBxYA0eMCMFLb0jaXwLrAyVs7z/TaYRatO3lLWo7ncO1RCEyGeVKd9iSRvA64\n09+QOIBvldgWjf722iYQGhZvV+N3/K+LFifhtgnjOlkgW2UQjeT54bBYywWb\neX+GrIwySNFXpAtPWhBOxamzHNP7EZg62uIzDErCybAQQoxwVzZGAHDkBc/G\njAHxOA7eV5s4ESGhjONf1I+VoCtJL6iqM0WnGwPgjsUU5TXoEAYW81uKgiFF\nxKaDKMKHgaDsBDFl+Dz77xh88jdlpsOPGzoGXanksJsaPUhRj8nCR59Am5Bh\nq2fO0PJngvYWG+P5XGaAp8Od1Nn3J2G8pzSMfj9KVM8TAk3v0faJGTXqN4Qm\nehuaYPKrIKpYnJW5+TEDc3xinBcwtIoNyqles20CF5pYHOVoI4y/kQgQg0hd\neSehdsjlE8PzeuFsw8BkKLeJJziyVggJ8cwFGOyahxQeWUZTx9sCpWT3kYyK\n6ulzROuORvmIvw28hrzaY8VX3hGhW+am3rHFMWbfr3uUUCKwWTXfXLpWkCyW\neVzE\r\n=7xYK\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"6ad69cfb2ae8f3428a4692241198143f254557c0","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4","tedious":"^6.6.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6.2.2","standard":"^14"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.0.0_1572913890543_0.27949767868942077","host":"s3://npm-registry-packages"}},"6.0.1":{"name":"mssql","version":"6.0.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.0.1","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"3aab69b7c19dd1b304495f27b748535d0110b477","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.0.1.tgz","fileCount":37,"integrity":"sha512-7oPhbQjotFJBgMPlzLmPwWlnrryxrDltjCNCD9BK7Df7TA9wc6Mb/0Bcx04NJyHCMAhw8C/iWjbJoeDyUfRNUA==","signatures":[{"sig":"MEUCIG+stcumawF3d31oWJQNsuFqYeMqSDqxEoh7IIXSNarIAiEAmQvkLTLBlvXfGUUlVD8pbOK94NqJJC7tFbsBoLdpOyo=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":215420,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdzpEcCRA9TVsSAnZWagAAUBkP/RG/QwiAN7+4vWx7VvYy\nVuVNcxeTSaVlU7QrymQl0WTN4FBSzOdpnlQodtfuOilas0N6wcYBuIbbr0q4\nEjc5dEfe7OHcTOZNiVWPjG9zNIqavG98/vhGAEHCYeAUBaEWbCuQj4w5bY8h\nH/gdlz2iZItLwtCnpS7ZN9X7nJyR9KaGGXcssHGA0lqW72vuuhRi7C9fldOe\nPDJlaRYo9qwXB+qaoThNwcboSDliJQMEiARdVeWWhb+IJOfkdFYc9BcOfc22\neVHJrjw0k5/qxkq/COB6Xua33LZtRw9Q7Cn1sSGeoILVLNkJou9uRzsrpLyn\nL02OFA8JJ+BpnI+aj3i/TirayiV3lFCXuEGb2RpWpoPGqm2X65uwlWOxEkT3\nlkIUfKj0/A4N+15PaR5AoR+81CWkKG6eK+SREyBCR/qdpTcHwa8ws7F2K7Le\nOwIuW1EM1O95y8vDiBZ38X6vsttNMDLrO1O5syBbhjptfmi82+qtVZe2d9Z8\nYquwQX4fOaqAAdIZ/K18OKkSNv9u/ajLl3lbf7JdAhsM1MMqp3p7OxJUWon0\nn65c07q1PC/hmhlk3jVkg0jhACdx916XWEMl5C8q3K5rxi0ilnsHkF5wccjq\nRvGNnXi0URiGVaomx52oVuxgjZM3zyphbCLhQX1R0aBw2+kVENfHDbevzX4f\nTxrO\r\n=AXid\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"f643c2cc22e899b11ec9878d8bfc64859c3f25a9","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4","tedious":"^6.6.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6.2.2","standard":"^14"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.0.1_1573818651490_0.9167578628865027","host":"s3://npm-registry-packages"}},"6.1.0":{"name":"mssql","version":"6.1.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.1.0","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"78ef99c6ef2901cba848bd527228aa446c3dde83","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.1.0.tgz","fileCount":37,"integrity":"sha512-tlzqjnWkV2Ra5TuPh/Snmp1CF/+yDJOPjQ2yoVzdvl0vQePPFITSLQCBLRydNbg8sR6HXQFEIQL9mPaCA3oO0Q==","signatures":[{"sig":"MEUCIQCmuIXn/62jgAOdln5vKHiUgzbZeuscziy1BClYpbjB/QIgWcl51v1w6XzG3prCt8zip9W/N6ml7HPS0Tmm+3gbkhI=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":228797,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeSqkHCRA9TVsSAnZWagAA75MP+QE7fWbWfUji3O6Jby33\nMMgVQ4lT0WBx/hhqoiMxewL4Kt2lk5bRP6f+nfDzOuRpr8c/uXut6Y8QTDj4\n1ngM5AEr1NOdJ0S0xIKIF6BSNkDj3TfhxED9fqDAK9JLOi4s2+ufhURRme8K\nh++KJsbLbx+yfrA+alXptNNXGRWQeGuCllNN5YYv+H99ym46UsiIytKZ1G02\nAvhGq1KPS/TTPd9SAG5SFp68SZOSvP/q+zNoB0bZ1+Vy+DB6riLzPM5kkIQy\nlFLIqtqjPjTGfxGo1eHWjoySzuDQhivLl/zJTQl1QGoo4tRJHx3rvdZ/uvcn\nagW5vyF1s5ErcKYFfInmDxxY3ZXh/V+5JM6gV7vNDUF8S1KIcAcx8LU8EIcU\nMuPt0J3vmVo8DRfdVP8RMy0L1VdUgr4agwDcs6EEFx3i8DP69ElWYBa3D4N8\nl6HcL8ykCC+ppSj4i6vwHDrSy52thqYjb+avBnJKsoDZxTQZBZdiTPty80xk\n5PgcRQL7rX7XcB7OWQzj9J2DxH59lxwOQwHHszj/xLuSfu5qKzHewP9qa1XW\nOZE3rGmhHZ6to7l1+swdFgGyueyNPZXpx6Ly6iYH/dOOTCpFdnecQXrKEtND\nsJvPVpftfggSAVIis0h6qaX/v1hzzU2AFACy6UdAm3PTsVFTw66i4C+l24qw\nCB8y\r\n=QvE2\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"91bbbbbd55f6773c23c74fa46fcb50372ffd7f72","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4","tedious":"^6.6.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6.2.2","standard":"^14"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.1.0_1581951239033_0.16468804149711724","host":"s3://npm-registry-packages"}},"4.3.8":{"name":"mssql","version":"4.3.8","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.3.8","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"5cf11720da2614a16c7dc096d9dd4afa23e93355","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.3.8.tgz","fileCount":18,"integrity":"sha512-LCEebLVEDXavPubfdAKYLnZwa3zOmts7Qo/TOsLJySagCDNu6vh9ntaY4YEgXst2PDKh9T6usNQhgbIj4ZAjrg==","signatures":[{"sig":"MEUCIGvxEtXN6X23Ws2Lg3llGQ/lfaliuTa7zm6mulJ55cB5AiEAxu256CL+SgUbo/arGIHg6qxLiA8WOHgB/umHtSLapbI=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":202412,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJebAbuCRA9TVsSAnZWagAALfQQAJ9t9MEw+iNeotAqRdvq\nv2m/lWCzmGqER2IFz01cCUOg8y70Rep7FbIwmydNcVKQcjHsmRGq+vWEbAna\nXZOY9lAszGqlJSh+hFjs7ZzV19iKZWYyN7q4b6/Jkpt6qiprybbYfeGIIhvA\nsTGkO02kRQim8JWqxzowogdwX0FrIXI0MtdhqFRps5mQm61Ps9ZufwU4rei9\nhsbD9dqbd9SlDK0OvTescHuoXW3cDSlvzCwf1TYwg9PeGALHeR2QraTuYfT5\nFqg9hKhCq7Re8bfQRSbPLChtlYN9xhOzhRUamapUTqYyo6zUATYzZgWObZlg\nXomf5mjk+UwHkNxwyd037S+hFvLk+5qY4Tl2CHk5Rq2EBeG0nidw/Nlf8lGy\nFnpD/cpP2u3qLrdmqJ0nC25pQsFc2TAytAF6FueHyWiTrIN5Lt2wHUpzlXV4\n+htXcxhGwtXAjpAbLNmyd84DwmonOJGoKSXtTLxJMtAbyzVcT0GqjNtvqN2I\nuWveW1774QbKlyRwTsnrC9zzSrjRGk64KAvVN0DgUozZzEhTumeYSi73c84L\nO+DCDb1nqt8jjfSNP3qTOrYIoTLRiG8aWy6sV2NA8SknthdzojJ0+0/kbBuv\nEyghKKIjpuIVFLznDPjbuSB+edE2jyO0tRZ+TEf7thkn3/Ti2drs4NJOzhJB\nW/Fz\r\n=ke/X\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\r\n\r\nMicrosoft SQL Server client for Node.js\r\n\r\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nSupported TDS drivers:\r\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\r\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\r\n\r\n## Installation\r\n\r\n    npm install mssql\r\n\r\nUse `@next` tag to install the most recent version with latest fixes and features.\r\n\r\n    npm install mssql@next\r\n\r\n## Quick Example\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nasync () => {\r\n    try {\r\n        await sql.connect('mssql://username:password@localhost/database')\r\n        const result = await sql.query`select * from mytable where id = ${value}`\r\n        console.dir(result)\r\n    } catch (err) {\r\n        // ... error checks\r\n    }\r\n}\r\n```\r\n\r\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\r\n\r\n## Documentation\r\n\r\n### Examples\r\n\r\n* [Async/Await](#asyncawait)\r\n* [Promises](#promises)\r\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\r\n* [Callbacks](#callbacks)\r\n* [Streaming](#streaming)\r\n* [Connection Pools](#connection-pools)\r\n\r\n### Configuration\r\n\r\n* [General](#general-same-for-all-drivers)\r\n* [Formats](#formats)\r\n\r\n### Drivers\r\n\r\n* [Tedious](#tedious)\r\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\r\n\r\n### Connections\r\n\r\n* [ConnectionPool](#connections-1)\r\n* [connect](#connect-callback)\r\n* [close](#close)\r\n\r\n### Requests\r\n\r\n* [Request](#request)\r\n* [execute](#execute-procedure-callback)\r\n* [input](#input-name-type-value)\r\n* [output](#output-name-type-value)\r\n* [pipe](#pipe-stream)\r\n* [query](#query-command-callback)\r\n* [batch](#batch-batch-callback)\r\n* [bulk](#bulk-table-callback)\r\n* [cancel](#cancel)\r\n\r\n### Transactions\r\n\r\n* [Transaction](#transaction)\r\n* [begin](#begin-isolationlevel-callback)\r\n* [commit](#commit-callback)\r\n* [rollback](#rollback-callback)\r\n\r\n### Prepared Statements\r\n\r\n* [PreparedStatement](#prepared-statement)\r\n* [input](#input-name-type)\r\n* [output](#output-name-type)\r\n* [prepare](#prepare-statement-callback)\r\n* [execute](#execute-values-callback)\r\n* [unprepare](#unprepare-callback)\r\n\r\n### Other\r\n\r\n* [CLI](#cli)\r\n* [Geography and Geometry](#geography-and-geometry)\r\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\r\n* [Affected Rows](#affected-rows)\r\n* [JSON support](#json-support)\r\n* [Errors](#errors)\r\n* [Informational messages](#informational-messages)\r\n* [Metadata](#metadata)\r\n* [Data Types](#data-types)\r\n* [SQL injection](#sql-injection)\r\n* [Known Issues](#known-issues)\r\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\r\n* [3.x to 4.x changes](#3x-to-4x-changes)\r\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\r\n\r\n## Examples\r\n\r\n### Config\r\n\r\n```javascript\r\nconst config = {\r\n    user: '...',\r\n    password: '...',\r\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\r\n    database: '...',\r\n\r\n    options: {\r\n        encrypt: true // Use this if you're on Windows Azure\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Async/Await\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\n(async function () {\r\n    try {\r\n        let pool = await sql.connect(config)\r\n        let result1 = await pool.request()\r\n            .input('input_parameter', sql.Int, value)\r\n            .query('select * from mytable where id = @input_parameter')\r\n            \r\n        console.dir(result1)\r\n    \r\n        // Stored procedure\r\n        \r\n        let result2 = await pool.request()\r\n            .input('input_parameter', sql.Int, value)\r\n            .output('output_parameter', sql.VarChar(50))\r\n            .execute('procedure_name')\r\n        \r\n        console.dir(result2)\r\n    } catch (err) {\r\n        // ... error checks\r\n    }\r\n})()\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\n### Promises\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nsql.connect(config).then(pool => {\r\n    // Query\r\n    \r\n    return pool.request()\r\n    .input('input_parameter', sql.Int, value)\r\n    .query('select * from mytable where id = @input_parameter')\r\n}).then(result => {\r\n    console.dir(result)\r\n    \r\n    // Stored procedure\r\n    \r\n    return pool.request()\r\n    .input('input_parameter', sql.Int, value)\r\n    .output('output_parameter', sql.VarChar(50))\r\n    .execute('procedure_name')\r\n}).then(result => {\r\n    console.dir(result)\r\n}).catch(err => {\r\n    // ... error checks\r\n})\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\r\n\r\n### ES6 Tagged template literals\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nsql.connect(config).then(() => {\r\n    return sql.query`select * from mytable where id = ${value}`\r\n}).then(result => {\r\n    console.dir(result)\r\n}).catch(err => {\r\n    // ... error checks\r\n})\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\nAll values are automatically sanitized against sql injection.\r\n\r\n### Callbacks\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nsql.connect(config, err => {\r\n    // ... error checks\r\n\r\n    // Query\r\n\r\n    new sql.Request().query('select 1 as number', (err, result) => {\r\n        // ... error checks\r\n\r\n        console.dir(result)\r\n    })\r\n\r\n    // Stored Procedure\r\n\r\n    new sql.Request()\r\n    .input('input_parameter', sql.Int, value)\r\n    .output('output_parameter', sql.VarChar(50))\r\n    .execute('procedure_name', (err, result) => {\r\n        // ... error checks\r\n\r\n        console.dir(result)\r\n    })\r\n})\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\n### Streaming\r\n\r\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nsql.connect(config, err => {\r\n    // ... error checks\r\n\r\n    const request = new sql.Request()\r\n    request.stream = true // You can set streaming differently for each request\r\n    request.query('select * from verylargetable') // or request.execute(procedure)\r\n\r\n    request.on('recordset', columns => {\r\n        // Emitted once for each recordset in a query\r\n    })\r\n\r\n    request.on('row', row => {\r\n        // Emitted for each row in a recordset\r\n    })\r\n\r\n    request.on('error', err => {\r\n        // May be emitted multiple times\r\n    })\r\n\r\n    request.on('done', result => {\r\n        // Always emitted as the last one\r\n    })\r\n})\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\n## Connection Pools\r\n\r\nUsing a single connection pool for your application/service is recommended.\r\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\r\nestablished before returning. From that point, you're able to acquire connections as normal:  \r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\n// async/await style:\r\nconst pool1 = new sql.ConnectionPool(config).connect();\r\n\r\npool1.on('error', err => {\r\n    // ... error handler\r\n})\r\n\r\nasync function messageHandler() {\r\n    await pool1; // ensures that the pool has been created\r\n    try {\r\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\r\n    \tconst result = request.query('select 1 as number')\r\n    \tconsole.dir(result)\r\n    \treturn result;\r\n\t} catch (err) {\r\n        console.error('SQL error', err);\r\n\t}\r\n}\r\n\r\n// promise style:\r\nconst pool2 = new sql.ConnectionPool(config, err => {\r\n    // ... error checks\r\n});\r\n\r\npool2.on('error', err => {\r\n    // ... error handler\r\n})\r\n\r\nfunction runStoredProcedure() {\r\n    return pool2.then((pool) => {\r\n\t\tpool.request() // or: new sql.Request(pool2)\r\n\t\t.input('input_parameter', sql.Int, 10)\r\n\t\t.output('output_parameter', sql.VarChar(50))\r\n\t\t.execute('procedure_name', (err, result) => {\r\n\t\t\t// ... error checks\r\n\t\t\tconsole.dir(result)\r\n\t\t})\r\n    });\r\n}\r\n```\r\n\r\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\r\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\r\n\r\n**ES6 Tagged template literals**\r\n\r\n```javascript\r\nnew sql.ConnectionPool(config).connect().then(pool => {\r\n    return pool.query`select * from mytable where id = ${value}`\r\n}).then(result => {\r\n    console.dir(result)\r\n}).catch(err => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\nAll values are automatically sanitized against sql injection.\r\n\r\n## Configuration\r\n\r\n```javascript\r\nconst config = {\r\n    user: '...',\r\n    password: '...',\r\n    server: 'localhost',\r\n    database: '...',\r\n    pool: {\r\n        max: 10,\r\n        min: 0,\r\n        idleTimeoutMillis: 30000\r\n    }\r\n}\r\n```\r\n\r\n### General (same for all drivers)\r\n\r\n- **user** - User name to use for authentication.\r\n- **password** - Password to use for authentication.\r\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\r\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\r\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\r\n- **database** - Database to connect to (default: dependent on server configuration).\r\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\r\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\r\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\r\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\r\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\r\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\r\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\r\n\r\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\r\n\r\n### Formats\r\n\r\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\r\n\r\n##### Classic Connection String\r\n\r\n```\r\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\r\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\r\n```\r\n\r\n##### Connection String URI\r\n\r\n```\r\nmssql://username:password@localhost:1433/database?encrypt=true\r\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\r\n```\r\n\r\n## Drivers\r\n\r\n### Tedious\r\n\r\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\r\n\r\n**Extra options:**\r\n\r\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\r\n```js\r\nrequire('mssql').connect(...config, beforeConnect: conn => {\r\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\r\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\r\n}})\r\n```\r\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\r\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\r\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\r\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\r\n- **options.appName** - Application name used for SQL server logging.\r\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\r\n\r\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\r\n\r\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\r\n\r\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\r\n\r\n**Extra options:**\r\n\r\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\r\n- **connectionString** - Connection string (default: see below).\r\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\r\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\r\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\r\n\r\nDefault connection string when connecting to port:\r\n```\r\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\r\n```\r\n\r\nDefault connection string when connecting to named instance:\r\n```\r\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\r\n```\r\n\r\n## Connections\r\n\r\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\r\n\r\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\r\n\r\n```javascript\r\nconst pool = new sql.ConnectionPool({ /* config */ })\r\n```\r\n\r\n### Events\r\n\r\n- **error(err)** - Dispatched on connection error.\r\n\r\n---------------------------------------\r\n\r\n### connect ([callback])\r\n\r\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\r\n\r\n__Arguments__\r\n\r\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst pool = new sql.ConnectionPool({\r\n    user: '...',\r\n    password: '...',\r\n    server: 'localhost',\r\n    database: '...'\r\n})\r\n\r\npool.connect(err => {\r\n    // ...\r\n})\r\n```\r\n\r\n__Errors__\r\n- ELOGIN (`ConnectionError`) - Login failed.\r\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\r\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\r\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\r\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\r\n- ESOCKET (`ConnectionError`) - Socket error.\r\n\r\n---------------------------------------\r\n\r\n### close()\r\n\r\nClose all active connections in the pool.\r\n\r\n__Example__\r\n\r\n```javascript\r\npool.close()\r\n```\r\n\r\n## Request\r\n\r\n```javascript\r\nconst request = new sql.Request(/* [pool or transaction] */)\r\n```\r\n\r\nIf you omit pool/transaction argument, global pool is used instead.\r\n\r\n### Events\r\n\r\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\r\n- **row(row)** - Dispatched when new row is parsed.\r\n- **done(returnValue)** - Dispatched when request is complete.\r\n- **error(err)** - Dispatched on error.\r\n- **info(message)** - Dispatched on informational message.\r\n\r\n---------------------------------------\r\n\r\n### execute (procedure, [callback])\r\n\r\nCall a stored procedure.\r\n\r\n__Arguments__\r\n\r\n- **procedure** - Name of the stored procedure to be executed.\r\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.input('input_parameter', sql.Int, value)\r\nrequest.output('output_parameter', sql.Int)\r\nrequest.execute('procedure_name', (err, result) => {\r\n    // ... error checks\r\n\r\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\r\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\r\n    console.log(result.recordset) // first recordset from result.recordsets\r\n    console.log(result.returnValue) // procedure return value\r\n    console.log(result.output) // key/value collection of output values\r\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\r\n\r\n    // ...\r\n})\r\n```\r\n\r\n__Errors__\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- ENOCONN (`RequestError`) - No connection is specified for that request.\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\r\n\r\n---------------------------------------\r\n\r\n### input (name, [type], value)\r\n\r\nAdd an input parameter to the request.\r\n\r\n__Arguments__\r\n\r\n- **name** - Name of the input parameter without @ char.\r\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\r\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\r\n\r\n__Example__\r\n\r\n```javascript\r\nrequest.input('input_parameter', value)\r\nrequest.input('input_parameter', sql.Int, value)\r\n```\r\n\r\n__JS Data Type To SQL Data Type Map__\r\n\r\n- `String` -> `sql.NVarChar`\r\n- `Number` -> `sql.Int`\r\n- `Boolean` -> `sql.Bit`\r\n- `Date` -> `sql.DateTime`\r\n- `Buffer` -> `sql.VarBinary`\r\n- `sql.Table` -> `sql.TVP`\r\n\r\nDefault data type for unknown object is `sql.NVarChar`.\r\n\r\nYou can define your own type map.\r\n\r\n```javascript\r\nsql.map.register(MyClass, sql.Text)\r\n```\r\n\r\nYou can also overwrite the default type map.\r\n\r\n```javascript\r\nsql.map.register(Number, sql.BigInt)\r\n```\r\n\r\n__Errors__ (synchronous)\r\n- EARGS (`RequestError`) - Invalid number of arguments.\r\n- EINJECT (`RequestError`) - SQL injection warning.\r\n\r\n---------------------------------------\r\n\r\n### output (name, type, [value])\r\n\r\nAdd an output parameter to the request.\r\n\r\n__Arguments__\r\n\r\n- **name** - Name of the output parameter without @ char.\r\n- **type** - SQL data type of output parameter.\r\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\r\n\r\n__Example__\r\n\r\n```javascript\r\nrequest.output('output_parameter', sql.Int)\r\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\r\n```\r\n\r\n__Errors__ (synchronous)\r\n- EARGS (`RequestError`) - Invalid number of arguments.\r\n- EINJECT (`RequestError`) - SQL injection warning.\r\n\r\n---------------------------------------\r\n\r\n### pipe (stream)\r\n\r\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\r\n\r\n__Arguments__\r\n\r\n- **stream** - Writable stream in object mode.\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.pipe(stream)\r\nrequest.query('select * from mytable')\r\nstream.on('error', err => {\r\n    // ...\r\n})\r\nstream.on('finish', () => {\r\n    // ...\r\n})\r\n```\r\n\r\n---------------------------------------\r\n\r\n### query (command, [callback])\r\n\r\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\r\n\r\n__Arguments__\r\n\r\n- **command** - T-SQL command to be executed.\r\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('select 1 as number', (err, result) => {\r\n    // ... error checks\r\n\r\n    console.log(result.recordset[0].number) // return 1\r\n\r\n    // ...\r\n})\r\n```\r\n\r\n__Errors__\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n- ENOCONN (`RequestError`) - No connection is specified for that request.\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\r\n    // ... error checks\r\n\r\n    console.log(result.recordset[0].number) // return 1\r\n    console.log(result.recordsets[0][0].number) // return 1\r\n    console.log(result.recordsets[1][0].number) // return 2\r\n})\r\n```\r\n\r\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\r\n\r\n---------------------------------------\r\n\r\n### batch (batch, [callback])\r\n\r\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\r\n\r\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\r\n\r\n__Arguments__\r\n\r\n- **batch** - T-SQL command to be executed.\r\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\n__Errors__\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n- ENOCONN (`RequestError`) - No connection is specified for that request.\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\r\n\r\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\r\n\r\n---------------------------------------\r\n\r\n### bulk (table, [callback])\r\n\r\nPerform a bulk insert.\r\n\r\n__Arguments__\r\n\r\n- **table** - `sql.Table` instance.\r\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\r\ntable.create = true\r\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\r\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\r\ntable.rows.add(777, 'test')\r\n\r\nconst request = new sql.Request()\r\nrequest.bulk(table, (err, result) => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\n**IMPORTANT**: Always indicate whether the column is nullable or not!\r\n\r\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\r\n\r\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\r\n\r\n__Errors__\r\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n- ENOCONN (`RequestError`) - No connection is specified for that request.\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\r\n\r\n---------------------------------------\r\n\r\n### cancel()\r\n\r\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\r\n    console.log(err instanceof sql.RequestError)  // true\r\n    console.log(err.message)                      // Cancelled.\r\n    console.log(err.code)                         // ECANCEL\r\n\r\n    // ...\r\n})\r\n\r\nrequest.cancel()\r\n```\r\n\r\n## Transaction\r\n\r\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction(/* [pool] */)\r\n```\r\n\r\nIf you omit connection argument, global connection is used instead.\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction(/* [pool] */)\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n\r\n    const request = new sql.Request(transaction)\r\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\r\n        // ... error checks\r\n\r\n        transaction.commit(err => {\r\n            // ... error checks\r\n\r\n            console.log(\"Transaction committed.\")\r\n        })\r\n    })\r\n})\r\n```\r\n\r\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\r\n\r\n__Aborted transactions__\r\n\r\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction(/* [pool] */)\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n\r\n    let rolledBack = false\r\n\r\n    transaction.on('rollback', aborted => {\r\n        // emited with aborted === true\r\n\r\n        rolledBack = true\r\n    })\r\n\r\n    new sql.Request(transaction)\r\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\r\n        // insert should fail because of invalid value\r\n\r\n        if (err) {\r\n            if (!rolledBack) {\r\n                transaction.rollback(err => {\r\n                    // ... error checks\r\n                })\r\n            }\r\n        } else {\r\n            transaction.commit(err => {\r\n                // ... error checks\r\n            })\r\n        }\r\n    })\r\n})\r\n```\r\n\r\n### Events\r\n\r\n- **begin** - Dispatched when transaction begin.\r\n- **commit** - Dispatched on successful commit.\r\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\r\n\r\n---------------------------------------\r\n\r\n### begin ([isolationLevel], [callback])\r\n\r\nBegin a transaction.\r\n\r\n__Arguments__\r\n\r\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\r\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction()\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\r\n\r\n---------------------------------------\r\n\r\n### commit ([callback])\r\n\r\nCommit a transaction.\r\n\r\n__Arguments__\r\n\r\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction()\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n\r\n    transaction.commit(err => {\r\n        // ... error checks\r\n    })\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\r\n\r\n---------------------------------------\r\n\r\n### rollback ([callback])\r\n\r\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\r\n\r\n__Arguments__\r\n\r\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction()\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n\r\n    transaction.rollback(err => {\r\n        // ... error checks\r\n    })\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\r\n\r\n## Prepared Statement\r\n\r\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement(/* [pool] */)\r\n```\r\n\r\nIf you omit the connection argument, the global connection is used instead.\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement(/* [pool] */)\r\nps.input('param', sql.Int)\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n\r\n    ps.execute({param: 12345}, (err, result) => {\r\n        // ... error checks\r\n\r\n        ps.unprepare(err => {\r\n            // ... error checks\r\n\r\n        })\r\n    })\r\n})\r\n```\r\n\r\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\r\n\r\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\r\n\r\n---------------------------------------\r\n\r\n### input (name, type)\r\n\r\nAdd an input parameter to the prepared statement.\r\n\r\n__Arguments__\r\n\r\n- **name** - Name of the input parameter without @ char.\r\n- **type** - SQL data type of input parameter.\r\n\r\n__Example__\r\n\r\n```javascript\r\nps.input('input_parameter', sql.Int)\r\nps.input('input_parameter', sql.VarChar(50))\r\n```\r\n\r\n__Errors__ (synchronous)\r\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\r\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\r\n\r\n---------------------------------------\r\n\r\n### output (name, type)\r\n\r\nAdd an output parameter to the prepared statement.\r\n\r\n__Arguments__\r\n\r\n- **name** - Name of the output parameter without @ char.\r\n- **type** - SQL data type of output parameter.\r\n\r\n__Example__\r\n\r\n```javascript\r\nps.output('output_parameter', sql.Int)\r\nps.output('output_parameter', sql.VarChar(50))\r\n```\r\n\r\n__Errors__ (synchronous)\r\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\r\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\r\n\r\n---------------------------------------\r\n\r\n### prepare (statement, [callback])\r\n\r\nPrepare a statement.\r\n\r\n__Arguments__\r\n\r\n- **statement** - T-SQL statement to prepare.\r\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement()\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n\r\n---------------------------------------\r\n\r\n### execute (values, [callback])\r\n\r\nExecute a prepared statement.\r\n\r\n__Arguments__\r\n\r\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\r\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement()\r\nps.input('param', sql.Int)\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n\r\n    ps.execute({param: 12345}, (err, result) => {\r\n        // ... error checks\r\n\r\n        console.log(result.recordset[0].value) // return 12345\r\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\r\n        \r\n        ps.unprepare(err => {\r\n            // ... error checks\r\n        })\r\n    })\r\n})\r\n```\r\n\r\nYou can also stream executed request.\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement()\r\nps.input('param', sql.Int)\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n\r\n    ps.stream = true\r\n    const request = ps.execute({param: 12345})\r\n\r\n    request.on('recordset', columns => {\r\n        // Emitted once for each recordset in a query\r\n    })\r\n\r\n    request.on('row', row => {\r\n        // Emitted for each row in a recordset\r\n    })\r\n\r\n    request.on('error', err => {\r\n        // May be emitted multiple times\r\n    })\r\n\r\n    request.on('done', result => {\r\n        // Always emitted as the last one\r\n        \r\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\r\n        \r\n        ps.unprepare(err => {\r\n            // ... error checks\r\n        })\r\n    })\r\n})\r\n```\r\n\r\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\r\n\r\n__Errors__\r\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n\r\n---------------------------------------\r\n\r\n### unprepare ([callback])\r\n\r\nUnprepare a prepared statement.\r\n\r\n__Arguments__\r\n\r\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement()\r\nps.input('param', sql.Int)\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n\r\n    ps.unprepare(err => {\r\n        // ... error checks\r\n\r\n    })\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\r\n\r\n## CLI\r\n\r\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\r\n\r\n__Setup__\r\n\r\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\r\n\r\n```json\r\n{\r\n    \"user\": \"...\",\r\n    \"password\": \"...\",\r\n    \"server\": \"localhost\",\r\n    \"database\": \"...\"\r\n}\r\n```\r\n\r\n__Example__\r\n\r\n```shell\r\necho \"select * from mytable\" | mssql /path/to/config\r\n```\r\nResults in:\r\n```json\r\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\r\n```\r\n\r\nYou can also query for multiple recordsets.\r\n\r\n```shell\r\necho \"select * from mytable; select * from myothertable\" | mssql\r\n```\r\nResults in:\r\n```json\r\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\r\n```\r\n\r\nIf you omit config path argument, mssql will try to load it from current working directory.\r\n\r\n## Geography and Geometry\r\n\r\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\r\n\r\n```sql\r\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\r\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\r\n```\r\n\r\nResults in:\r\n\r\n```javascript\r\n{ srid: 4326,\r\n  version: 1,\r\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\r\n  figures: [ { attribute: 1, pointOffset: 0 } ],\r\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\r\n  segments: [] }\r\n\r\n{ srid: 0,\r\n  version: 1,\r\n  points:\r\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\r\n     { x: 20, y: 180, z: NaN, m: NaN },\r\n     { x: 180, y: 180, z: NaN, m: NaN } ],\r\n  figures: [ { attribute: 1, pointOffset: 0 } ],\r\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\r\n  segments: [] }\r\n```\r\n\r\n## Table-Valued Parameter (TVP)\r\n\r\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\r\n\r\n```sql\r\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\r\n```\r\n\r\nNext we will need a stored procedure.\r\n\r\n```sql\r\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\r\n```\r\n\r\nNow let's go back to our Node.js app.\r\n\r\n```javascript\r\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\r\n\r\n// Columns must correspond with type we have created in database.\r\ntvp.columns.add('a', sql.VarChar(50))\r\ntvp.columns.add('b', sql.Int)\r\n\r\n// Add rows\r\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\r\n```\r\n\r\nYou can send table as a parameter to stored procedure.\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.input('tvp', tvp)\r\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\r\n    // ... error checks\r\n\r\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\r\n})\r\n```\r\n\r\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\r\n\r\n## Affected Rows\r\n\r\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\r\n\r\n__Example using Promises__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\r\n    console.log(result.rowsAffected)\r\n})\r\n```\r\n\r\n__Example using callbacks__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\r\n    console.log(result.rowsAffected)\r\n})\r\n```\r\n\r\n__Example using streaming__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.stream = true\r\nrequest.query('update myAwesomeTable set awesomness = 100')\r\nrequest.on('done', result => {\r\n    console.log(result.rowsAffected)\r\n})\r\n```\r\n\r\n## JSON support\r\n\r\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\r\n\r\nExample\r\n```sql\r\nSELECT\r\n    1 AS 'a.b.c',\r\n    2 AS 'a.b.d',\r\n    3 AS 'a.x',\r\n    4 AS 'a.y'\r\nFOR JSON PATH\r\n```\r\n\r\nResults in:\r\n```javascript\r\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\r\n```\r\n\r\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\r\n```javascript\r\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\r\n```\r\n\r\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\r\n\r\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\r\n\r\n## Errors\r\n\r\nThere are 4 types of errors you can handle:\r\n\r\n- **ConnectionError** - Errors related to connections and connection pool.\r\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\r\n- **RequestError** - Errors related to queries and stored procedures execution.\r\n- **PreparedStatementError** - Errors related to prepared statements.\r\n\r\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\r\n\r\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\r\n\r\n### Error Codes\r\n\r\nEach known error has `name`, `code` and `message` properties.\r\n\r\nName | Code | Message\r\n:--- | :--- | :---\r\n`ConnectionError` | ELOGIN | Login failed.\r\n`ConnectionError` | ETIMEOUT | Connection timeout.\r\n`ConnectionError` | EDRIVER | Unknown driver.\r\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\r\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\r\n`ConnectionError` | ENOTOPEN | Connection not yet open.\r\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\r\n`ConnectionError` | ESOCKET | Socket error.\r\n`ConnectionError` | ECONNCLOSED | Connection is closed.\r\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\r\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\r\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\r\n`TransactionError` | EABORT | Transaction has been aborted.\r\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\r\n`RequestError` | ECANCEL | Cancelled.\r\n`RequestError` | ETIMEOUT | Request timeout.\r\n`RequestError` | EARGS | Invalid number of arguments.\r\n`RequestError` | EINJECT | SQL injection warning.\r\n`RequestError` | ENOCONN | No connection is specified for that request.\r\n`PreparedStatementError` | EARGS | Invalid number of arguments.\r\n`PreparedStatementError` | EINJECT | SQL injection warning.\r\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\r\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\r\n\r\n### Detailed SQL Errors\r\n\r\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\r\n\r\n- **err.number** - The error number.\r\n- **err.state** - The error state, used as a modifier to the number.\r\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\r\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\r\n- **err.serverName** - The server name.\r\n- **err.procName** - The stored procedure name.\r\n\r\n## Informational messages\r\n\r\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.on('info', info => {\r\n    console.dir(info)\r\n})\r\nrequest.query('print \\'Hello world.\\';', (err, result) => {\r\n    // ...\r\n})\r\n```\r\n\r\nStructure of informational message:\r\n\r\n- **info.message** - Message.\r\n- **info.number** - The message number.\r\n- **info.state** - The message state, used as a modifier to the number.\r\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\r\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\r\n- **info.serverName** - The server name.\r\n- **info.procName** - The stored procedure name.\r\n\r\n## Metadata\r\n\r\nRecordset metadata are accessible through the `recordset.columns` property.\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\r\n    console.dir(result.recordset.columns)\r\n\r\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\r\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\r\n})\r\n```\r\n\r\nColumns structure for example above:\r\n\r\n```javascript\r\n{\r\n    first: {\r\n        index: 0,\r\n        name: 'first',\r\n        length: 17,\r\n        type: [sql.Decimal],\r\n        scale: 4,\r\n        precision: 18,\r\n        nullable: true,\r\n        caseSensitive: false\r\n        identity: false\r\n        readOnly: true\r\n    },\r\n    second: {\r\n        index: 1,\r\n        name: 'second',\r\n        length: 4,\r\n        type: [sql.VarChar],\r\n        nullable: false,\r\n        caseSensitive: false\r\n        identity: false\r\n        readOnly: true\r\n    }\r\n}\r\n```\r\n\r\n## Data Types\r\n\r\nYou can define data types with length/precision/scale:\r\n\r\n```javascript\r\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\r\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\r\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\r\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\r\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\r\n\r\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\r\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\r\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\r\n\r\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\r\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\r\n```\r\n\r\nList of supported data types:\r\n\r\n```\r\nsql.Bit\r\nsql.BigInt\r\nsql.Decimal ([precision], [scale])\r\nsql.Float\r\nsql.Int\r\nsql.Money\r\nsql.Numeric ([precision], [scale])\r\nsql.SmallInt\r\nsql.SmallMoney\r\nsql.Real\r\nsql.TinyInt\r\n\r\nsql.Char ([length])\r\nsql.NChar ([length])\r\nsql.Text\r\nsql.NText\r\nsql.VarChar ([length])\r\nsql.NVarChar ([length])\r\nsql.Xml\r\n\r\nsql.Time ([scale])\r\nsql.Date\r\nsql.DateTime\r\nsql.DateTime2 ([scale])\r\nsql.DateTimeOffset ([scale])\r\nsql.SmallDateTime\r\n\r\nsql.UniqueIdentifier\r\n\r\nsql.Variant\r\n\r\nsql.Binary\r\nsql.VarBinary ([length])\r\nsql.Image\r\n\r\nsql.UDT\r\nsql.Geography\r\nsql.Geometry\r\n```\r\n\r\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\r\n\r\n## SQL injection\r\n\r\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.input('myval', sql.VarChar, '-- commented')\r\nrequest.query('select @myval as myval', (err, result) => {\r\n    console.dir(result)\r\n})\r\n```\r\n\r\n## Known issues\r\n\r\n### Tedious\r\n\r\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\r\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\r\n\r\n### msnodesqlv8\r\n\r\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\r\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\r\n\r\n## 3.x to 4.x changes\r\n\r\n- Library & tests are rewritten to ES6.\r\n- `Connection` was renamed to `ConnectionPool`.\r\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\r\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\r\n- Affected rows are now returned as an array. A separate number for each SQL statement.\r\n- Directive `multiple: true` was removed.\r\n- `Transaction` and `PreparedStatement` internal queues was removed.\r\n- ConnectionPool no longer emits `connect` and `close` events.\r\n- Removed verbose and debug mode.\r\n- Removed support for `tds` and `msnodesql` drivers.\r\n- Removed support for Node versions lower than 4.\r\n\r\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\r\n[npm-url]: https://www.npmjs.com/package/mssql\r\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\r\n[downloads-url]: https://www.npmjs.com/package/mssql\r\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\r\n[david-url]: https://david-dm.org/tediousjs/node-mssql\r\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\r\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\r\n[appveyor-image]: https://img.shields.io/appveyor/ci/patriksimek/node-mssql-o4dhf/master.svg?style=flat-square&label=integration\r\n[appveyor-url]: https://ci.appveyor.com/project/patriksimek/node-mssql-o4dhf\r\n\r\n[tedious-url]: https://www.npmjs.com/package/tedious\r\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\r\n","engines":{"node":">=4"},"gitHead":"e4d5e1b8e79f7cc23a1cfc0af1099e809e4362c2","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"debug":"^3.2.6","tedious":"^2.7.1","generic-pool":"^3.7.1"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.3.8_1584137966451_0.8725573346333437","host":"s3://npm-registry-packages"}},"5.1.1":{"name":"mssql","version":"5.1.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.1.1","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"e2ddb859fd3c4a086e7b7ef953a8d7d5467a5486","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.1.1.tgz","fileCount":18,"integrity":"sha512-1UcknF7D4YfnrfMzR+FYUUswEREB110z1nD0Ncydt+6PT9Joj2w4xAJCQ1fSeKIeM4NrlZjQOaCTw5qU1zmZQA==","signatures":[{"sig":"MEYCIQCNewaIEYFEIUzhBBhlruOQTLLym67IfvaXbWH6w0Z3LAIhAOwtzGNYmbyA8StNxMZg9ClJSYZgjznghEBSIJrBmDem","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":208737,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJebAfDCRA9TVsSAnZWagAAi7kP/1zj9gh+XGd33KLjsYov\n+9JvXj3Wz01j2JVyb3EyXOmK44Sw/ybtYAtd8LejbY4CfMpyF/aB+mj4FQ3J\nV5jgaaNHUi3IpqdocZJNxbAUfT4QpgiIg1hcWM0PG1VThNPvIYY8cruTWGZD\nWu4pflyZn08IMltupwBIr/GanOkCIfJJ3P8YA/hXsR50TaJ5Z+E2J5yfGeTc\n+kDz8DYyqpa/zj97j4Lzyd9+V1Q2+VfVlaYujCdn+YxsKRVJ0mu7DhikAJeA\nYcUjB0mEBvlxQqKFuN34siPvM3juQZFuuSDz9E4S5ZipogVcUF5/BT5uDqwP\nEqzAyYeY4x2tKu4TsWuZs4jkUT7hOSFp4TM9Kne3dV69klGsXnFw3fSx7uvB\nOxvb7mMfEKvPLU5e7fNRuo88kI0Gpy6ya7O6ehwVWIG8et+s+QCRixJ8wIAq\nVi+l8kgyVDtrKv30uJotgnWItekMPWPdsnB2qiDiHzBB04wfMKB5kUVXGGSC\nhvmZ4zPTn+PnUmWR9wrU72J7Rq8xuAZL9g545FuzxoZLV1iBJ4IH6ObNThQb\nFc3NllHAdGtEH2db2kfg4Je+uHNqaFQDPCrGRgwpHO1iScKPgdBnI8BXrIE9\nX+p1ZPIeNbWNw+J9tQLzBqORENkTaO6wgxzLANfNrfL6c8YAb6GceN3xl2LM\nComD\r\n=69xu\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\r\n\r\nMicrosoft SQL Server client for Node.js\r\n\r\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nSupported TDS drivers:\r\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\r\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\r\n\r\n## Installation\r\n\r\n    npm install mssql\r\n\r\n## Quick Example\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nasync () => {\r\n    try {\r\n        await sql.connect('mssql://username:password@localhost/database')\r\n        const result = await sql.query`select * from mytable where id = ${value}`\r\n        console.dir(result)\r\n    } catch (err) {\r\n        // ... error checks\r\n    }\r\n}\r\n```\r\n\r\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\r\n\r\n## Documentation\r\n\r\n### Examples\r\n\r\n* [Async/Await](#asyncawait)\r\n* [Promises](#promises)\r\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\r\n* [Callbacks](#callbacks)\r\n* [Streaming](#streaming)\r\n* [Connection Pools](#connection-pools)\r\n\r\n### Configuration\r\n\r\n* [General](#general-same-for-all-drivers)\r\n* [Formats](#formats)\r\n\r\n### Drivers\r\n\r\n* [Tedious](#tedious)\r\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\r\n\r\n### Connections\r\n\r\n* [ConnectionPool](#connections-1)\r\n* [connect](#connect-callback)\r\n* [close](#close)\r\n\r\n### Requests\r\n\r\n* [Request](#request)\r\n* [execute](#execute-procedure-callback)\r\n* [input](#input-name-type-value)\r\n* [output](#output-name-type-value)\r\n* [pipe](#pipe-stream)\r\n* [query](#query-command-callback)\r\n* [batch](#batch-batch-callback)\r\n* [bulk](#bulk-table-callback)\r\n* [cancel](#cancel)\r\n\r\n### Transactions\r\n\r\n* [Transaction](#transaction)\r\n* [begin](#begin-isolationlevel-callback)\r\n* [commit](#commit-callback)\r\n* [rollback](#rollback-callback)\r\n\r\n### Prepared Statements\r\n\r\n* [PreparedStatement](#prepared-statement)\r\n* [input](#input-name-type)\r\n* [output](#output-name-type)\r\n* [prepare](#prepare-statement-callback)\r\n* [execute](#execute-values-callback)\r\n* [unprepare](#unprepare-callback)\r\n\r\n### Other\r\n\r\n* [CLI](#cli)\r\n* [Geography and Geometry](#geography-and-geometry)\r\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\r\n* [Affected Rows](#affected-rows)\r\n* [JSON support](#json-support)\r\n* [Errors](#errors)\r\n* [Informational messages](#informational-messages)\r\n* [Metadata](#metadata)\r\n* [Data Types](#data-types)\r\n* [SQL injection](#sql-injection)\r\n* [Known Issues](#known-issues)\r\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\r\n* [3.x to 4.x changes](#3x-to-4x-changes)\r\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\r\n\r\n## Examples\r\n\r\n### Config\r\n\r\n```javascript\r\nconst config = {\r\n    user: '...',\r\n    password: '...',\r\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\r\n    database: '...',\r\n\r\n    options: {\r\n        encrypt: true // Use this if you're on Windows Azure\r\n    }\r\n}\r\n```\r\n\r\n\r\n### Async/Await\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\n(async function () {\r\n    try {\r\n        let pool = await sql.connect(config)\r\n        let result1 = await pool.request()\r\n            .input('input_parameter', sql.Int, value)\r\n            .query('select * from mytable where id = @input_parameter')\r\n            \r\n        console.dir(result1)\r\n    \r\n        // Stored procedure\r\n        \r\n        let result2 = await pool.request()\r\n            .input('input_parameter', sql.Int, value)\r\n            .output('output_parameter', sql.VarChar(50))\r\n            .execute('procedure_name')\r\n        \r\n        console.dir(result2)\r\n    } catch (err) {\r\n        // ... error checks\r\n    }\r\n})()\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\n### Promises\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nsql.connect(config).then(pool => {\r\n    // Query\r\n    \r\n    return pool.request()\r\n    .input('input_parameter', sql.Int, value)\r\n    .query('select * from mytable where id = @input_parameter')\r\n}).then(result => {\r\n    console.dir(result)\r\n    \r\n    // Stored procedure\r\n    \r\n    return pool.request()\r\n    .input('input_parameter', sql.Int, value)\r\n    .output('output_parameter', sql.VarChar(50))\r\n    .execute('procedure_name')\r\n}).then(result => {\r\n    console.dir(result)\r\n}).catch(err => {\r\n    // ... error checks\r\n})\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\r\n\r\n### ES6 Tagged template literals\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nsql.connect(config).then(() => {\r\n    return sql.query`select * from mytable where id = ${value}`\r\n}).then(result => {\r\n    console.dir(result)\r\n}).catch(err => {\r\n    // ... error checks\r\n})\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\nAll values are automatically sanitized against sql injection.\r\n\r\n### Callbacks\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nsql.connect(config, err => {\r\n    // ... error checks\r\n\r\n    // Query\r\n\r\n    new sql.Request().query('select 1 as number', (err, result) => {\r\n        // ... error checks\r\n\r\n        console.dir(result)\r\n    })\r\n\r\n    // Stored Procedure\r\n\r\n    new sql.Request()\r\n    .input('input_parameter', sql.Int, value)\r\n    .output('output_parameter', sql.VarChar(50))\r\n    .execute('procedure_name', (err, result) => {\r\n        // ... error checks\r\n\r\n        console.dir(result)\r\n    })\r\n})\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\n### Streaming\r\n\r\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nsql.connect(config, err => {\r\n    // ... error checks\r\n\r\n    const request = new sql.Request()\r\n    request.stream = true // You can set streaming differently for each request\r\n    request.query('select * from verylargetable') // or request.execute(procedure)\r\n\r\n    request.on('recordset', columns => {\r\n        // Emitted once for each recordset in a query\r\n    })\r\n\r\n    request.on('row', row => {\r\n        // Emitted for each row in a recordset\r\n    })\r\n\r\n    request.on('error', err => {\r\n        // May be emitted multiple times\r\n    })\r\n\r\n    request.on('done', result => {\r\n        // Always emitted as the last one\r\n    })\r\n})\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\r\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\r\n an example of managing rows in batches of 15:\r\n\r\n```javascript\r\nlet rowsToProcess = [];\r\nrequest.on('row', row => {\r\n  rowsToProcess.push(row);\r\n  if (rowsToProcess.length >= 15) {\r\n    request.pause();\r\n    processRows();\r\n  }\r\n});\r\nrequest.on('done', () => {\r\n    processRows();\r\n});\r\n\r\nfunction processRows() {\r\n  // process rows\r\n  rowsToProcess = [];\r\n  request.resume();\r\n}\r\n```\r\n\r\n## Connection Pools\r\n\r\nUsing a single connection pool for your application/service is recommended.\r\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\r\nestablished before returning. From that point, you're able to acquire connections as normal:  \r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\n// async/await style:\r\nconst pool1 = new sql.ConnectionPool(config).connect();\r\n\r\npool1.on('error', err => {\r\n    // ... error handler\r\n})\r\n\r\nasync function messageHandler() {\r\n    await pool1; // ensures that the pool has been created\r\n    try {\r\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\r\n    \tconst result = request.query('select 1 as number')\r\n    \tconsole.dir(result)\r\n    \treturn result;\r\n\t} catch (err) {\r\n        console.error('SQL error', err);\r\n\t}\r\n}\r\n\r\n// promise style:\r\nconst pool2 = new sql.ConnectionPool(config, err => {\r\n    // ... error checks\r\n}).connect();\r\n\r\npool2.on('error', err => {\r\n    // ... error handler\r\n})\r\n\r\nfunction runStoredProcedure() {\r\n    return pool2.then((pool) => {\r\n\t\tpool.request() // or: new sql.Request(pool2)\r\n\t\t.input('input_parameter', sql.Int, 10)\r\n\t\t.output('output_parameter', sql.VarChar(50))\r\n\t\t.execute('procedure_name', (err, result) => {\r\n\t\t\t// ... error checks\r\n\t\t\tconsole.dir(result)\r\n\t\t})\r\n    });\r\n}\r\n```\r\n\r\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\r\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\r\n\r\n**ES6 Tagged template literals**\r\n\r\n```javascript\r\nnew sql.ConnectionPool(config).connect().then(pool => {\r\n    return pool.query`select * from mytable where id = ${value}`\r\n}).then(result => {\r\n    console.dir(result)\r\n}).catch(err => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\nAll values are automatically sanitized against sql injection.\r\n\r\n## Configuration\r\n\r\n```javascript\r\nconst config = {\r\n    user: '...',\r\n    password: '...',\r\n    server: 'localhost',\r\n    database: '...',\r\n    pool: {\r\n        max: 10,\r\n        min: 0,\r\n        idleTimeoutMillis: 30000\r\n    }\r\n}\r\n```\r\n\r\n### General (same for all drivers)\r\n\r\n- **user** - User name to use for authentication.\r\n- **password** - Password to use for authentication.\r\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\r\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\r\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\r\n- **database** - Database to connect to (default: dependent on server configuration).\r\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\r\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\r\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\r\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\r\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\r\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\r\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\r\n\r\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\r\n\r\n### Formats\r\n\r\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\r\n\r\n##### Classic Connection String\r\n\r\n```\r\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\r\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\r\n```\r\n\r\n##### Connection String URI\r\n\r\n```\r\nmssql://username:password@localhost:1433/database?encrypt=true\r\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\r\n```\r\n\r\n## Drivers\r\n\r\n### Tedious\r\n\r\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\r\n\r\n**Extra options:**\r\n\r\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\r\n```js\r\nrequire('mssql').connect(...config, beforeConnect: conn => {\r\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\r\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\r\n}})\r\n```\r\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\r\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\r\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\r\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\r\n- **options.appName** - Application name used for SQL server logging.\r\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\r\n\r\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\r\n\r\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\r\n\r\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\r\n\r\n**Extra options:**\r\n\r\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\r\n- **connectionString** - Connection string (default: see below).\r\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\r\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\r\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\r\n\r\nDefault connection string when connecting to port:\r\n```\r\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\r\n```\r\n\r\nDefault connection string when connecting to named instance:\r\n```\r\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\r\n```\r\n\r\n## Connections\r\n\r\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\r\n\r\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\r\n\r\n```javascript\r\nconst pool = new sql.ConnectionPool({ /* config */ })\r\n```\r\n\r\n### Events\r\n\r\n- **error(err)** - Dispatched on connection error.\r\n\r\n---------------------------------------\r\n\r\n### connect ([callback])\r\n\r\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\r\n\r\n__Arguments__\r\n\r\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst pool = new sql.ConnectionPool({\r\n    user: '...',\r\n    password: '...',\r\n    server: 'localhost',\r\n    database: '...'\r\n})\r\n\r\npool.connect(err => {\r\n    // ...\r\n})\r\n```\r\n\r\n__Errors__\r\n- ELOGIN (`ConnectionError`) - Login failed.\r\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\r\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\r\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\r\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\r\n- ESOCKET (`ConnectionError`) - Socket error.\r\n\r\n---------------------------------------\r\n\r\n### close()\r\n\r\nClose all active connections in the pool.\r\n\r\n__Example__\r\n\r\n```javascript\r\npool.close()\r\n```\r\n\r\n## Request\r\n\r\n```javascript\r\nconst request = new sql.Request(/* [pool or transaction] */)\r\n```\r\n\r\nIf you omit pool/transaction argument, global pool is used instead.\r\n\r\n### Events\r\n\r\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\r\n- **row(row)** - Dispatched when new row is parsed.\r\n- **done(returnValue)** - Dispatched when request is complete.\r\n- **error(err)** - Dispatched on error.\r\n- **info(message)** - Dispatched on informational message.\r\n\r\n---------------------------------------\r\n\r\n### execute (procedure, [callback])\r\n\r\nCall a stored procedure.\r\n\r\n__Arguments__\r\n\r\n- **procedure** - Name of the stored procedure to be executed.\r\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.input('input_parameter', sql.Int, value)\r\nrequest.output('output_parameter', sql.Int)\r\nrequest.execute('procedure_name', (err, result) => {\r\n    // ... error checks\r\n\r\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\r\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\r\n    console.log(result.recordset) // first recordset from result.recordsets\r\n    console.log(result.returnValue) // procedure return value\r\n    console.log(result.output) // key/value collection of output values\r\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\r\n\r\n    // ...\r\n})\r\n```\r\n\r\n__Errors__\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- ENOCONN (`RequestError`) - No connection is specified for that request.\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\r\n\r\n---------------------------------------\r\n\r\n### input (name, [type], value)\r\n\r\nAdd an input parameter to the request.\r\n\r\n__Arguments__\r\n\r\n- **name** - Name of the input parameter without @ char.\r\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\r\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\r\n\r\n__Example__\r\n\r\n```javascript\r\nrequest.input('input_parameter', value)\r\nrequest.input('input_parameter', sql.Int, value)\r\n```\r\n\r\n__JS Data Type To SQL Data Type Map__\r\n\r\n- `String` -> `sql.NVarChar`\r\n- `Number` -> `sql.Int`\r\n- `Boolean` -> `sql.Bit`\r\n- `Date` -> `sql.DateTime`\r\n- `Buffer` -> `sql.VarBinary`\r\n- `sql.Table` -> `sql.TVP`\r\n\r\nDefault data type for unknown object is `sql.NVarChar`.\r\n\r\nYou can define your own type map.\r\n\r\n```javascript\r\nsql.map.register(MyClass, sql.Text)\r\n```\r\n\r\nYou can also overwrite the default type map.\r\n\r\n```javascript\r\nsql.map.register(Number, sql.BigInt)\r\n```\r\n\r\n__Errors__ (synchronous)\r\n- EARGS (`RequestError`) - Invalid number of arguments.\r\n- EINJECT (`RequestError`) - SQL injection warning.\r\n\r\n---------------------------------------\r\n\r\n### output (name, type, [value])\r\n\r\nAdd an output parameter to the request.\r\n\r\n__Arguments__\r\n\r\n- **name** - Name of the output parameter without @ char.\r\n- **type** - SQL data type of output parameter.\r\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\r\n\r\n__Example__\r\n\r\n```javascript\r\nrequest.output('output_parameter', sql.Int)\r\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\r\n```\r\n\r\n__Errors__ (synchronous)\r\n- EARGS (`RequestError`) - Invalid number of arguments.\r\n- EINJECT (`RequestError`) - SQL injection warning.\r\n\r\n---------------------------------------\r\n\r\n### pipe (stream)\r\n\r\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\r\n\r\n__Arguments__\r\n\r\n- **stream** - Writable stream in object mode.\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.pipe(stream)\r\nrequest.query('select * from mytable')\r\nstream.on('error', err => {\r\n    // ...\r\n})\r\nstream.on('finish', () => {\r\n    // ...\r\n})\r\n```\r\n\r\n---------------------------------------\r\n\r\n### query (command, [callback])\r\n\r\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\r\n\r\n__Arguments__\r\n\r\n- **command** - T-SQL command to be executed.\r\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('select 1 as number', (err, result) => {\r\n    // ... error checks\r\n\r\n    console.log(result.recordset[0].number) // return 1\r\n\r\n    // ...\r\n})\r\n```\r\n\r\n__Errors__\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n- ENOCONN (`RequestError`) - No connection is specified for that request.\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\r\n    // ... error checks\r\n\r\n    console.log(result.recordset[0].number) // return 1\r\n    console.log(result.recordsets[0][0].number) // return 1\r\n    console.log(result.recordsets[1][0].number) // return 2\r\n})\r\n```\r\n\r\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\r\n\r\n---------------------------------------\r\n\r\n### batch (batch, [callback])\r\n\r\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\r\n\r\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\r\n\r\n__Arguments__\r\n\r\n- **batch** - T-SQL command to be executed.\r\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\n__Errors__\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n- ENOCONN (`RequestError`) - No connection is specified for that request.\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\r\n\r\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\r\n\r\n---------------------------------------\r\n\r\n### bulk (table, [options,] [callback])\r\n\r\nPerform a bulk insert.\r\n\r\n__Arguments__\r\n\r\n- **table** - `sql.Table` instance.\r\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\r\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\r\ntable.create = true\r\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\r\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\r\ntable.rows.add(777, 'test')\r\n\r\nconst request = new sql.Request()\r\nrequest.bulk(table, (err, result) => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\n**IMPORTANT**: Always indicate whether the column is nullable or not!\r\n\r\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\r\n\r\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\r\n\r\n__Errors__\r\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n- ENOCONN (`RequestError`) - No connection is specified for that request.\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\r\n\r\n---------------------------------------\r\n\r\n### cancel()\r\n\r\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\r\n    console.log(err instanceof sql.RequestError)  // true\r\n    console.log(err.message)                      // Cancelled.\r\n    console.log(err.code)                         // ECANCEL\r\n\r\n    // ...\r\n})\r\n\r\nrequest.cancel()\r\n```\r\n\r\n## Transaction\r\n\r\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction(/* [pool] */)\r\n```\r\n\r\nIf you omit connection argument, global connection is used instead.\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction(/* [pool] */)\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n\r\n    const request = new sql.Request(transaction)\r\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\r\n        // ... error checks\r\n\r\n        transaction.commit(err => {\r\n            // ... error checks\r\n\r\n            console.log(\"Transaction committed.\")\r\n        })\r\n    })\r\n})\r\n```\r\n\r\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\r\n\r\n__Aborted transactions__\r\n\r\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction(/* [pool] */)\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n\r\n    let rolledBack = false\r\n\r\n    transaction.on('rollback', aborted => {\r\n        // emited with aborted === true\r\n\r\n        rolledBack = true\r\n    })\r\n\r\n    new sql.Request(transaction)\r\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\r\n        // insert should fail because of invalid value\r\n\r\n        if (err) {\r\n            if (!rolledBack) {\r\n                transaction.rollback(err => {\r\n                    // ... error checks\r\n                })\r\n            }\r\n        } else {\r\n            transaction.commit(err => {\r\n                // ... error checks\r\n            })\r\n        }\r\n    })\r\n})\r\n```\r\n\r\n### Events\r\n\r\n- **begin** - Dispatched when transaction begin.\r\n- **commit** - Dispatched on successful commit.\r\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\r\n\r\n---------------------------------------\r\n\r\n### begin ([isolationLevel], [callback])\r\n\r\nBegin a transaction.\r\n\r\n__Arguments__\r\n\r\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\r\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction()\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\r\n\r\n---------------------------------------\r\n\r\n### commit ([callback])\r\n\r\nCommit a transaction.\r\n\r\n__Arguments__\r\n\r\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction()\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n\r\n    transaction.commit(err => {\r\n        // ... error checks\r\n    })\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\r\n\r\n---------------------------------------\r\n\r\n### rollback ([callback])\r\n\r\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\r\n\r\n__Arguments__\r\n\r\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction()\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n\r\n    transaction.rollback(err => {\r\n        // ... error checks\r\n    })\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\r\n\r\n## Prepared Statement\r\n\r\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement(/* [pool] */)\r\n```\r\n\r\nIf you omit the connection argument, the global connection is used instead.\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement(/* [pool] */)\r\nps.input('param', sql.Int)\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n\r\n    ps.execute({param: 12345}, (err, result) => {\r\n        // ... error checks\r\n\r\n        // release the connection after queries are executed\r\n        ps.unprepare(err => {\r\n            // ... error checks\r\n\r\n        })\r\n    })\r\n})\r\n```\r\n\r\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\r\n\r\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\r\n\r\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\r\n\r\n---------------------------------------\r\n\r\n### input (name, type)\r\n\r\nAdd an input parameter to the prepared statement.\r\n\r\n__Arguments__\r\n\r\n- **name** - Name of the input parameter without @ char.\r\n- **type** - SQL data type of input parameter.\r\n\r\n__Example__\r\n\r\n```javascript\r\nps.input('input_parameter', sql.Int)\r\nps.input('input_parameter', sql.VarChar(50))\r\n```\r\n\r\n__Errors__ (synchronous)\r\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\r\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\r\n\r\n---------------------------------------\r\n\r\n### output (name, type)\r\n\r\nAdd an output parameter to the prepared statement.\r\n\r\n__Arguments__\r\n\r\n- **name** - Name of the output parameter without @ char.\r\n- **type** - SQL data type of output parameter.\r\n\r\n__Example__\r\n\r\n```javascript\r\nps.output('output_parameter', sql.Int)\r\nps.output('output_parameter', sql.VarChar(50))\r\n```\r\n\r\n__Errors__ (synchronous)\r\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\r\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\r\n\r\n---------------------------------------\r\n\r\n### prepare (statement, [callback])\r\n\r\nPrepare a statement.\r\n\r\n__Arguments__\r\n\r\n- **statement** - T-SQL statement to prepare.\r\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement()\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n\r\n---------------------------------------\r\n\r\n### execute (values, [callback])\r\n\r\nExecute a prepared statement.\r\n\r\n__Arguments__\r\n\r\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\r\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement()\r\nps.input('param', sql.Int)\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n\r\n    ps.execute({param: 12345}, (err, result) => {\r\n        // ... error checks\r\n\r\n        console.log(result.recordset[0].value) // return 12345\r\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\r\n        \r\n        ps.unprepare(err => {\r\n            // ... error checks\r\n        })\r\n    })\r\n})\r\n```\r\n\r\nYou can also stream executed request.\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement()\r\nps.input('param', sql.Int)\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n\r\n    ps.stream = true\r\n    const request = ps.execute({param: 12345})\r\n\r\n    request.on('recordset', columns => {\r\n        // Emitted once for each recordset in a query\r\n    })\r\n\r\n    request.on('row', row => {\r\n        // Emitted for each row in a recordset\r\n    })\r\n\r\n    request.on('error', err => {\r\n        // May be emitted multiple times\r\n    })\r\n\r\n    request.on('done', result => {\r\n        // Always emitted as the last one\r\n        \r\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\r\n        \r\n        ps.unprepare(err => {\r\n            // ... error checks\r\n        })\r\n    })\r\n})\r\n```\r\n\r\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\r\n\r\n__Errors__\r\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n\r\n---------------------------------------\r\n\r\n### unprepare ([callback])\r\n\r\nUnprepare a prepared statement.\r\n\r\n__Arguments__\r\n\r\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement()\r\nps.input('param', sql.Int)\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n\r\n    ps.unprepare(err => {\r\n        // ... error checks\r\n\r\n    })\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\r\n\r\n## CLI\r\n\r\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\r\n\r\n__Setup__\r\n\r\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\r\n\r\n```json\r\n{\r\n    \"user\": \"...\",\r\n    \"password\": \"...\",\r\n    \"server\": \"localhost\",\r\n    \"database\": \"...\"\r\n}\r\n```\r\n\r\n__Example__\r\n\r\n```shell\r\necho \"select * from mytable\" | mssql /path/to/config\r\n```\r\nResults in:\r\n```json\r\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\r\n```\r\n\r\nYou can also query for multiple recordsets.\r\n\r\n```shell\r\necho \"select * from mytable; select * from myothertable\" | mssql\r\n```\r\nResults in:\r\n```json\r\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\r\n```\r\n\r\nIf you omit config path argument, mssql will try to load it from current working directory.\r\n\r\n## Geography and Geometry\r\n\r\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\r\n\r\n```sql\r\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\r\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\r\n```\r\n\r\nResults in:\r\n\r\n```javascript\r\n{ srid: 4326,\r\n  version: 1,\r\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\r\n  figures: [ { attribute: 1, pointOffset: 0 } ],\r\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\r\n  segments: [] }\r\n\r\n{ srid: 0,\r\n  version: 1,\r\n  points:\r\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\r\n     { x: 20, y: 180, z: NaN, m: NaN },\r\n     { x: 180, y: 180, z: NaN, m: NaN } ],\r\n  figures: [ { attribute: 1, pointOffset: 0 } ],\r\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\r\n  segments: [] }\r\n```\r\n\r\n## Table-Valued Parameter (TVP)\r\n\r\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\r\n\r\n```sql\r\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\r\n```\r\n\r\nNext we will need a stored procedure.\r\n\r\n```sql\r\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\r\n```\r\n\r\nNow let's go back to our Node.js app.\r\n\r\n```javascript\r\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\r\n\r\n// Columns must correspond with type we have created in database.\r\ntvp.columns.add('a', sql.VarChar(50))\r\ntvp.columns.add('b', sql.Int)\r\n\r\n// Add rows\r\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\r\n```\r\n\r\nYou can send table as a parameter to stored procedure.\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.input('tvp', tvp)\r\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\r\n    // ... error checks\r\n\r\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\r\n})\r\n```\r\n\r\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\r\n\r\n## Affected Rows\r\n\r\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\r\n\r\n__Example using Promises__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\r\n    console.log(result.rowsAffected)\r\n})\r\n```\r\n\r\n__Example using callbacks__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\r\n    console.log(result.rowsAffected)\r\n})\r\n```\r\n\r\n__Example using streaming__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.stream = true\r\nrequest.query('update myAwesomeTable set awesomness = 100')\r\nrequest.on('done', result => {\r\n    console.log(result.rowsAffected)\r\n})\r\n```\r\n\r\n## JSON support\r\n\r\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\r\n\r\nExample\r\n```sql\r\nSELECT\r\n    1 AS 'a.b.c',\r\n    2 AS 'a.b.d',\r\n    3 AS 'a.x',\r\n    4 AS 'a.y'\r\nFOR JSON PATH\r\n```\r\n\r\nResults in:\r\n```javascript\r\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\r\n```\r\n\r\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\r\n```javascript\r\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\r\n```\r\n\r\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\r\n\r\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\r\n\r\n## Errors\r\n\r\nThere are 4 types of errors you can handle:\r\n\r\n- **ConnectionError** - Errors related to connections and connection pool.\r\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\r\n- **RequestError** - Errors related to queries and stored procedures execution.\r\n- **PreparedStatementError** - Errors related to prepared statements.\r\n\r\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\r\n\r\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\r\n\r\n### Error Codes\r\n\r\nEach known error has `name`, `code` and `message` properties.\r\n\r\nName | Code | Message\r\n:--- | :--- | :---\r\n`ConnectionError` | ELOGIN | Login failed.\r\n`ConnectionError` | ETIMEOUT | Connection timeout.\r\n`ConnectionError` | EDRIVER | Unknown driver.\r\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\r\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\r\n`ConnectionError` | ENOTOPEN | Connection not yet open.\r\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\r\n`ConnectionError` | ESOCKET | Socket error.\r\n`ConnectionError` | ECONNCLOSED | Connection is closed.\r\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\r\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\r\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\r\n`TransactionError` | EABORT | Transaction has been aborted.\r\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\r\n`RequestError` | ECANCEL | Cancelled.\r\n`RequestError` | ETIMEOUT | Request timeout.\r\n`RequestError` | EARGS | Invalid number of arguments.\r\n`RequestError` | EINJECT | SQL injection warning.\r\n`RequestError` | ENOCONN | No connection is specified for that request.\r\n`PreparedStatementError` | EARGS | Invalid number of arguments.\r\n`PreparedStatementError` | EINJECT | SQL injection warning.\r\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\r\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\r\n\r\n### Detailed SQL Errors\r\n\r\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\r\n\r\n- **err.number** - The error number.\r\n- **err.state** - The error state, used as a modifier to the number.\r\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\r\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\r\n- **err.serverName** - The server name.\r\n- **err.procName** - The stored procedure name.\r\n\r\n## Informational messages\r\n\r\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.on('info', info => {\r\n    console.dir(info)\r\n})\r\nrequest.query('print \\'Hello world.\\';', (err, result) => {\r\n    // ...\r\n})\r\n```\r\n\r\nStructure of informational message:\r\n\r\n- **info.message** - Message.\r\n- **info.number** - The message number.\r\n- **info.state** - The message state, used as a modifier to the number.\r\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\r\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\r\n- **info.serverName** - The server name.\r\n- **info.procName** - The stored procedure name.\r\n\r\n## Metadata\r\n\r\nRecordset metadata are accessible through the `recordset.columns` property.\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\r\n    console.dir(result.recordset.columns)\r\n\r\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\r\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\r\n})\r\n```\r\n\r\nColumns structure for example above:\r\n\r\n```javascript\r\n{\r\n    first: {\r\n        index: 0,\r\n        name: 'first',\r\n        length: 17,\r\n        type: [sql.Decimal],\r\n        scale: 4,\r\n        precision: 18,\r\n        nullable: true,\r\n        caseSensitive: false\r\n        identity: false\r\n        readOnly: true\r\n    },\r\n    second: {\r\n        index: 1,\r\n        name: 'second',\r\n        length: 4,\r\n        type: [sql.VarChar],\r\n        nullable: false,\r\n        caseSensitive: false\r\n        identity: false\r\n        readOnly: true\r\n    }\r\n}\r\n```\r\n\r\n## Data Types\r\n\r\nYou can define data types with length/precision/scale:\r\n\r\n```javascript\r\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\r\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\r\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\r\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\r\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\r\n\r\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\r\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\r\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\r\n\r\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\r\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\r\n```\r\n\r\nList of supported data types:\r\n\r\n```\r\nsql.Bit\r\nsql.BigInt\r\nsql.Decimal ([precision], [scale])\r\nsql.Float\r\nsql.Int\r\nsql.Money\r\nsql.Numeric ([precision], [scale])\r\nsql.SmallInt\r\nsql.SmallMoney\r\nsql.Real\r\nsql.TinyInt\r\n\r\nsql.Char ([length])\r\nsql.NChar ([length])\r\nsql.Text\r\nsql.NText\r\nsql.VarChar ([length])\r\nsql.NVarChar ([length])\r\nsql.Xml\r\n\r\nsql.Time ([scale])\r\nsql.Date\r\nsql.DateTime\r\nsql.DateTime2 ([scale])\r\nsql.DateTimeOffset ([scale])\r\nsql.SmallDateTime\r\n\r\nsql.UniqueIdentifier\r\n\r\nsql.Variant\r\n\r\nsql.Binary\r\nsql.VarBinary ([length])\r\nsql.Image\r\n\r\nsql.UDT\r\nsql.Geography\r\nsql.Geometry\r\n```\r\n\r\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\r\n\r\n## SQL injection\r\n\r\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.input('myval', sql.VarChar, '-- commented')\r\nrequest.query('select @myval as myval', (err, result) => {\r\n    console.dir(result)\r\n})\r\n```\r\n\r\n## Known issues\r\n\r\n### Tedious\r\n\r\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\r\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\r\n\r\n### msnodesqlv8\r\n\r\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\r\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\r\n\r\n## 3.x to 4.x changes\r\n\r\n- Library & tests are rewritten to ES6.\r\n- `Connection` was renamed to `ConnectionPool`.\r\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\r\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\r\n- Affected rows are now returned as an array. A separate number for each SQL statement.\r\n- Directive `multiple: true` was removed.\r\n- `Transaction` and `PreparedStatement` internal queues was removed.\r\n- ConnectionPool no longer emits `connect` and `close` events.\r\n- Removed verbose and debug mode.\r\n- Removed support for `tds` and `msnodesql` drivers.\r\n- Removed support for Node versions lower than 4.\r\n\r\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\r\n[npm-url]: https://www.npmjs.com/package/mssql\r\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\r\n[downloads-url]: https://www.npmjs.com/package/mssql\r\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\r\n[david-url]: https://david-dm.org/tediousjs/node-mssql\r\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\r\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\r\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\r\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\r\n\r\n[tedious-url]: https://www.npmjs.com/package/tedious\r\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\r\n","engines":{"node":">=6"},"gitHead":"81118ad70086fe037a1ead8271941aa1ec3bee74","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"debug":"^3.2.6","tedious":"^4.2.0","generic-pool":"^3.7.1"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.1.1_1584138179406_0.24404147336925575","host":"s3://npm-registry-packages"}},"6.2.0":{"name":"mssql","version":"6.2.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.2.0","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"44af82701ffadf979baa0275b77a9ddb776f00c3","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.2.0.tgz","fileCount":36,"integrity":"sha512-C1WcvpiyGGoNyA+rNae/87V4O47S1P75zqmITutxzamocccY8BsZA+cljXJvpnYbbGlmMB5eoSaVUSqR9NyLCg==","signatures":[{"sig":"MEUCIQC2Sze8U09yEAILfaOYWfhIvD63CpyqPDaOgPI/OlN3oQIgWqqdBm0+hrp+PqA9IKfD98m2qADog+G9FHmHCQW/gLc=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":235419,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJebAoRCRA9TVsSAnZWagAAcZ4P/jwAm2OkmJ2jwMZZlTZJ\nfsE2xwPBzDsHRUb65DRIVuT4yO/KWup477KStAupMMI5WTzxvDpTZMjIOzQ6\n2bsuso3pKCVwxH2cmStSoJrZ55g45niScltXQTN1R63h9rLhlap9nJ5cPlil\n41eiSwfAWz7VFWckdfryV/RDTwmGwS1vq7OOE1iAsWlcc9pdCowKZMMIlhM2\nZQw+ZNIpiSbCHvSIuKbtd5AHlO1U3vaNTTGt93RM5Fbp9I25ZNRlfKfZw/8O\nIJemdQ/QzHpqguFE1LLUqCsbCe2nodxTKgCPu5cHhlonmYdudWJvMvcFT0at\nbZm8JG8ezBLvnj290MrA4a9YZDr9h9esQQdd5rsXijj1e1zPsbqBE6Z9VpHu\ngDz66YIVzPxvqOCKuVMCfFmx2nPLGapoZhCDFNRXQI5nesEtA8ymIj03xt8G\nrr1/JuD1kg38KLPCqpdGYZiNS32Dok3HEKo0ebhn4YOb36dqOLFFVe1HjA/D\nKocun8nv1qC34tuET187aUH2iUlCzLDYPnCfws62KBlvUipHlq9uxWtEzrGj\nSXDBYE1mjFWqFQsxVzt4uJEA3Xc6CLIQfg8F5b3jn9FfYN7YdcbXxxRXvbNN\nNysV4CkqGlaBnrZOpYFSkBOSVpAiLx9QuKqUyXgh+ljgt3J6c5rxT7qVp0T+\nQl72\r\n=1+gV\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"32fc7fcaa75d9e6ce92b31140575d2a0dc90c650","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4","tedious":"^6.6.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6.2.2","standard":"^14"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.2.0_1584138769370_0.4849666076356738","host":"s3://npm-registry-packages"}},"7.0.0-alpha.1":{"name":"mssql","version":"7.0.0-alpha.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.0.0-alpha.1","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"b55037c11e441605a8dc93a64c197301335de8cc","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.0.0-alpha.1.tgz","fileCount":36,"integrity":"sha512-acP/FZUvYjvvOzSrAyJlQHxd01mw/OnGenzKZNXgEbTRzYqbunyUhuL37j/EGUQLyeWXQBaASrkUsVG/gLr90g==","signatures":[{"sig":"MEYCIQD21+G0Xse39aloiahAik3KQcBx9zlcteS3kRHcjGOEHwIhAKMG8KjaU987wdg2gqO3+1P9DRSsicmZykTDIwKMHx5m","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":235513,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJebAscCRA9TVsSAnZWagAAPBIP/16rY5ngfNlSRTmgIgzz\nkngH4JVHnJjZVQNgvigraRhothGeywMAaq6tuxQWD1OBzBZW6AwT4w1K1x0o\nF4jOx/G12685yFJ4iHStX+RGZq8O1IcFlHKK4CZsSnRIOvIBva+s6c8mVmyU\nz9I9wQSVWH2aNNm+i065UAPOad2XU/2UJ00SEdtwu0Pdm3M39UNTcKiwpkM/\nWfgQOaRCzLmOEKrQ88SAnk/jDmMps3lZksHJvNqXvi1s66ilyidjJzrJJZgK\nqlWcTR3/TFzauraRCRWDFUKR0AgS8NbC0SujOQOzMmUcSsWG/vVCFcym1SUz\nla5l2cB8DZZnr4a0DxZMLNTwL/6Ab7H8BNvlm2Kcbdrn9DhfYiKNnkvATerQ\nJuvn4Dpjtb8dF+uXdTVwWkChsgEyjSuecYy8exizvh5+8xgeBe6JJtVvr1IO\nUz944FMuRfmWvvTyWIfNZD0wophPx1hHm7wejqXjGOjVKVewmq+tCFwspErx\n+ODuZM0bCMgHFhqo3grX4+NVrh42+psIVcyuyv0CS9rXntxV4XEAAWr8u0Ts\nElCHdCizDB1CsB+alcAIvhFl3VS53qfHnxUGAnu3x2ywvMbs7i9SlqSIKdJP\npRH/ne9r+dMACH6fj/KRTRhwE9h0KyN00DrC5Ni33VjAknOWCZcnhZm0eeA/\nFp88\r\n=+x4c\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\r\n\r\nMicrosoft SQL Server client for Node.js\r\n\r\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\r\n\r\nSupported TDS drivers:\r\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\r\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\r\n\r\n## Installation\r\n\r\n    npm install mssql\r\n\r\n## Quick Example\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nasync () => {\r\n    try {\r\n        // make sure that any items are correctly URL encoded in the connection string\r\n        await sql.connect('mssql://username:password@localhost/database')\r\n        const result = await sql.query`select * from mytable where id = ${value}`\r\n        console.dir(result)\r\n    } catch (err) {\r\n        // ... error checks\r\n    }\r\n}\r\n```\r\n\r\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\r\n\r\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\r\n\r\n## Documentation\r\n\r\n### Examples\r\n\r\n* [Async/Await](#asyncawait)\r\n* [Promises](#promises)\r\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\r\n* [Callbacks](#callbacks)\r\n* [Streaming](#streaming)\r\n* [Connection Pools](#connection-pools)\r\n\r\n### Configuration\r\n\r\n* [General](#general-same-for-all-drivers)\r\n* [Formats](#formats)\r\n\r\n### Drivers\r\n\r\n* [Tedious](#tedious)\r\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\r\n\r\n### Connections\r\n\r\n* [Pool Management](#pool-management)\r\n* [ConnectionPool](#connections-1)\r\n* [connect](#connect-callback)\r\n* [close](#close)\r\n\r\n### Requests\r\n\r\n* [Request](#request)\r\n* [execute](#execute-procedure-callback)\r\n* [input](#input-name-type-value)\r\n* [output](#output-name-type-value)\r\n* [pipe](#pipe-stream)\r\n* [query](#query-command-callback)\r\n* [batch](#batch-batch-callback)\r\n* [bulk](#bulk-table-options-callback)\r\n* [cancel](#cancel)\r\n\r\n### Transactions\r\n\r\n* [Transaction](#transaction)\r\n* [begin](#begin-isolationlevel-callback)\r\n* [commit](#commit-callback)\r\n* [rollback](#rollback-callback)\r\n\r\n### Prepared Statements\r\n\r\n* [PreparedStatement](#prepared-statement)\r\n* [input](#input-name-type)\r\n* [output](#output-name-type)\r\n* [prepare](#prepare-statement-callback)\r\n* [execute](#execute-values-callback)\r\n* [unprepare](#unprepare-callback)\r\n\r\n### Other\r\n\r\n* [CLI](#cli)\r\n* [Geography and Geometry](#geography-and-geometry)\r\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\r\n* [Affected Rows](#affected-rows)\r\n* [JSON support](#json-support)\r\n* [Errors](#errors)\r\n* [Informational messages](#informational-messages)\r\n* [Metadata](#metadata)\r\n* [Data Types](#data-types)\r\n* [SQL injection](#sql-injection)\r\n* [Known Issues](#known-issues)\r\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\r\n* [5.x to 6.x changes](#5x-to-6x-changes)\r\n* [4.x to 5.x changes](#4x-to-5x-changes)\r\n* [3.x to 4.x changes](#3x-to-4x-changes)\r\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\r\n\r\n## Examples\r\n\r\n### Config\r\n\r\n```javascript\r\nconst config = {\r\n    user: '...',\r\n    password: '...',\r\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\r\n    database: '...',\r\n}\r\n```\r\n\r\n\r\n### Async/Await\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\n(async function () {\r\n    try {\r\n        let pool = await sql.connect(config)\r\n        let result1 = await pool.request()\r\n            .input('input_parameter', sql.Int, value)\r\n            .query('select * from mytable where id = @input_parameter')\r\n            \r\n        console.dir(result1)\r\n    \r\n        // Stored procedure\r\n        \r\n        let result2 = await pool.request()\r\n            .input('input_parameter', sql.Int, value)\r\n            .output('output_parameter', sql.VarChar(50))\r\n            .execute('procedure_name')\r\n        \r\n        console.dir(result2)\r\n    } catch (err) {\r\n        // ... error checks\r\n    }\r\n})()\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\n### Promises\r\n\r\n#### Queries\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n\r\nsql.connect(config).then(pool => {\r\n    // Query\r\n    \r\n    return pool.request()\r\n        .input('input_parameter', sql.Int, value)\r\n        .query('select * from mytable where id = @input_parameter')\r\n}).then(result => {\r\n    console.dir(result)\r\n}).catch(err => {\r\n  // ... error checks\r\n});\r\n```\r\n\r\n#### Stored procedures\r\n\r\n```js\r\nconst sql = require('mssql')\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n\r\nsql.connect(config).then(pool => {\r\n    \r\n    // Stored procedure\r\n    \r\n    return pool.request()\r\n        .input('input_parameter', sql.Int, value)\r\n        .output('output_parameter', sql.VarChar(50))\r\n        .execute('procedure_name')\r\n}).then(result => {\r\n    console.dir(result)\r\n}).catch(err => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\r\n\r\n### ES6 Tagged template literals\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nsql.connect(config).then(() => {\r\n    return sql.query`select * from mytable where id = ${value}`\r\n}).then(result => {\r\n    console.dir(result)\r\n}).catch(err => {\r\n    // ... error checks\r\n})\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\nAll values are automatically sanitized against sql injection. \r\nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\r\ne.g. Column names cannot be passed/set in statements using variables.\r\n\r\n### Callbacks\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nsql.connect(config, err => {\r\n    // ... error checks\r\n\r\n    // Query\r\n\r\n    new sql.Request().query('select 1 as number', (err, result) => {\r\n        // ... error checks\r\n\r\n        console.dir(result)\r\n    })\r\n\r\n    // Stored Procedure\r\n\r\n    new sql.Request()\r\n    .input('input_parameter', sql.Int, value)\r\n    .output('output_parameter', sql.VarChar(50))\r\n    .execute('procedure_name', (err, result) => {\r\n        // ... error checks\r\n\r\n        console.dir(result)\r\n    })\r\n\r\n    // Using template literal\r\n\r\n    const request = new sql.Request()\r\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\r\n        // ... error checks\r\n        console.dir(result)\r\n    })\r\n})\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\n### Streaming\r\n\r\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\nsql.connect(config, err => {\r\n    // ... error checks\r\n\r\n    const request = new sql.Request()\r\n    request.stream = true // You can set streaming differently for each request\r\n    request.query('select * from verylargetable') // or request.execute(procedure)\r\n\r\n    request.on('recordset', columns => {\r\n        // Emitted once for each recordset in a query\r\n    })\r\n\r\n    request.on('row', row => {\r\n        // Emitted for each row in a recordset\r\n    })\r\n\r\n    request.on('error', err => {\r\n        // May be emitted multiple times\r\n    })\r\n\r\n    request.on('done', result => {\r\n        // Always emitted as the last one\r\n    })\r\n})\r\n\r\nsql.on('error', err => {\r\n    // ... error handler\r\n})\r\n```\r\n\r\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\r\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\r\n an example of managing rows in batches of 15:\r\n\r\n```javascript\r\nlet rowsToProcess = [];\r\nrequest.on('row', row => {\r\n  rowsToProcess.push(row);\r\n  if (rowsToProcess.length >= 15) {\r\n    request.pause();\r\n    processRows();\r\n  }\r\n});\r\nrequest.on('done', () => {\r\n    processRows();\r\n});\r\n\r\nfunction processRows() {\r\n  // process rows\r\n  rowsToProcess = [];\r\n  request.resume();\r\n}\r\n```\r\n\r\n## Pool Management\r\n\r\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\r\nas this library uses connection pooling extensively.\r\n\r\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\r\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\r\n(as would be the case in something like PHP, where one process handles one request).\r\n\r\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\r\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\r\n\r\n### The Global Connection (Pool)\r\n\r\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\r\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\r\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\r\nit will resolve to the connected pool. For example:\r\n\r\n```js\r\nconst sql = require('mssql')\r\n\r\n// run a query against the global connection pool\r\nfunction runQuery(query) {\r\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\r\n  return sql.connect().then((pool) => {\r\n    return pool.query(query)\r\n  })\r\n}\r\n\r\n```\r\n\r\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\r\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\r\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\r\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\r\n\r\n```js\r\nconst sql = require('mssql')\r\n\r\n(() => {\r\n  sql.connect().then(pool => {\r\n    return pool.query('SELECT 1')\r\n  }).then(result => {\r\n    // do something with result\r\n  }).then(() => {\r\n    return sql.close()\r\n  })\r\n})()\r\n```\r\n\r\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\r\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\r\nanother SQL query.\r\n\r\n### Advanced Pool Management\r\n\r\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\r\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\r\nmanagement.\r\n\r\nThat could look something like this:\r\n\r\n```js\r\nconst { ConnectionPool } = require('mssql')\r\nconst POOLS = {}\r\n\r\nfunction createPool(config, name) {\r\n  if (getPool(name)) {\r\n    throw new Error('Pool with this name already exists')\r\n  }\r\n  return POOLS[name] = (new ConnectionPool(config)).connect()\r\n}\r\n\r\nfunction closePool(name) {\r\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\r\n    const pool = POOLS[name];\r\n    delete POOLS[name];\r\n    return pool.close()\r\n  }\r\n}\r\n\r\nfunction getPool(name) {\r\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\r\n    return POOLS[name]\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  closePool,\r\n  createPool,\r\n  getPool\r\n}\r\n```\r\n\r\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\r\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\r\nyour application is shutting down.\r\n\r\n## Connection Pools\r\n\r\nUsing a single connection pool for your application/service is recommended.\r\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\r\nestablished before returning. From that point, you're able to acquire connections as normal:  \r\n\r\n```javascript\r\nconst sql = require('mssql')\r\n\r\n// async/await style:\r\nconst pool1 = new sql.ConnectionPool(config);\r\nconst pool1Connect = pool1.connect();\r\n\r\npool1.on('error', err => {\r\n    // ... error handler\r\n})\r\n\r\nasync function messageHandler() {\r\n    await pool1Connect; // ensures that the pool has been created\r\n    try {\r\n        const request = pool1.request(); // or: new sql.Request(pool1)\r\n        const result = await request.query('select 1 as number')\r\n        console.dir(result)\r\n        return result;\r\n    } catch (err) {\r\n        console.error('SQL error', err);\r\n    }\r\n}\r\n\r\n// promise style:\r\nconst pool2 = new sql.ConnectionPool(config)\r\nconst pool2Connect = pool2.connect()\r\n\r\npool2.on('error', err => {\r\n    // ... error handler\r\n})\r\n\r\nfunction runStoredProcedure() {\r\n    return pool2Connect.then((pool) => {\r\n        pool.request() // or: new sql.Request(pool2)\r\n        .input('input_parameter', sql.Int, 10)\r\n        .output('output_parameter', sql.VarChar(50))\r\n        .execute('procedure_name', (err, result) => {\r\n            // ... error checks\r\n            console.dir(result)\r\n        })\r\n    }).catch(err => {\r\n        // ... error handler\r\n    })\r\n}\r\n```\r\n\r\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\r\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\r\n\r\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\r\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\r\nclose when your application is shutting down.\r\n\r\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\r\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\r\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\r\n\r\n**ES6 Tagged template literals**\r\n\r\n```javascript\r\nnew sql.ConnectionPool(config).connect().then(pool => {\r\n    return pool.query`select * from mytable where id = ${value}`\r\n}).then(result => {\r\n    console.dir(result)\r\n}).catch(err => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\nAll values are automatically sanitized against sql injection.\r\n\r\n### Managing connection pools\r\n\r\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\r\nof a single pool this library exposes a set of functions to access a single global connection. eg:\r\n\r\n```js\r\n// as part of your application's boot process\r\n\r\nconst sql = require('mssql')\r\nconst poolPromise = sql.connect()\r\n\r\n// during your applications runtime\r\n\r\npoolPromise.then(() => {\r\n  return sql.query('SELECT 1')\r\n}).then(result => {\r\n  console.dir(result)\r\n})\r\n\r\n// when your application exits\r\npoolPromise.then(() => {\r\n  return sql.close()\r\n})\r\n```\r\n\r\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\r\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\r\ncan hold references to the pools for you. For example:\r\n\r\n```js\r\nconst sql = require('mssql')\r\n\r\nconst pools = {}\r\n\r\n// manage a set of pools by name (config will be required to create the pool)\r\n// a pool will be removed when it is closed\r\nasync function getPool(name, config) {\r\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\r\n    const pool = new sql.ConnectionPool(config)\r\n    const close = pool.close.bind(pool)\r\n    pool.close = (...args) => {\r\n      delete pools[name]\r\n      return close(...args)\r\n    }\r\n    await pool.connect()\r\n    pools[name] = pool\r\n  }\r\n  return pools[name]\r\n}\r\n\r\n// close all pools\r\nfunction closeAll() {\r\n  return Promise.all(Object.values(pools).map((pool) => {\r\n    return pool.close()\r\n  }))\r\n}\r\n\r\nmodule.exports = {\r\n  closeAll,\r\n  getPool\r\n}\r\n```\r\n\r\nYou can then use this library file in your code to get a connected pool when you need it:\r\n\r\n```js\r\nconst { getPool } = require('./path/to/file')\r\n\r\n// run a query\r\nasync function runQuery(query, config) {\r\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\r\n  const pool = await getPool('default', config)\r\n  const result = await pool.request().query(query)\r\n  return result\r\n}\r\n```\r\n\r\n## Configuration\r\n\r\n```javascript\r\nconst config = {\r\n    user: '...',\r\n    password: '...',\r\n    server: 'localhost',\r\n    database: '...',\r\n    pool: {\r\n        max: 10,\r\n        min: 0,\r\n        idleTimeoutMillis: 30000\r\n    }\r\n}\r\n```\r\n\r\n### General (same for all drivers)\r\n\r\n- **user** - User name to use for authentication.\r\n- **password** - Password to use for authentication.\r\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\r\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\r\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\r\n- **database** - Database to connect to (default: dependent on server configuration).\r\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\r\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\r\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\r\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\r\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\r\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\r\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\r\n\r\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\r\n\r\n### Formats\r\n\r\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\r\n\r\n##### Classic Connection String\r\n\r\n```\r\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\r\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\r\n```\r\n\r\n##### Connection String URI\r\n\r\n```\r\nmssql://username:password@localhost:1433/database?encrypt=true\r\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\r\n```\r\n\r\n## Drivers\r\n\r\n### Tedious\r\n\r\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\r\n\r\n**Extra options:**\r\n\r\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\r\n```js\r\nrequire('mssql').connect(...config, beforeConnect: conn => {\r\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\r\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\r\n}})\r\n```\r\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\r\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\r\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\r\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\r\n- **options.appName** - Application name used for SQL server logging.\r\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\r\n\r\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\r\n\r\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\r\n\r\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\r\n\r\n**Extra options:**\r\n\r\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\r\n- **connectionString** - Connection string (default: see below).\r\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\r\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\r\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\r\n\r\nDefault connection string when connecting to port:\r\n```\r\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\r\n```\r\n\r\nDefault connection string when connecting to named instance:\r\n```\r\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\r\n```\r\n\r\n## Connections\r\n\r\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\r\n\r\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\r\n\r\n```javascript\r\nconst pool = new sql.ConnectionPool({ /* config */ })\r\n```\r\n\r\n### Events\r\n\r\n- **error(err)** - Dispatched on connection error.\r\n\r\n---------------------------------------\r\n\r\n### connect ([callback])\r\n\r\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\r\n\r\n__Arguments__\r\n\r\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst pool = new sql.ConnectionPool({\r\n    user: '...',\r\n    password: '...',\r\n    server: 'localhost',\r\n    database: '...'\r\n})\r\n\r\npool.connect(err => {\r\n    // ...\r\n})\r\n```\r\n\r\n__Errors__\r\n- ELOGIN (`ConnectionError`) - Login failed.\r\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\r\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\r\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\r\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\r\n- ESOCKET (`ConnectionError`) - Socket error.\r\n\r\n---------------------------------------\r\n\r\n### close()\r\n\r\nClose all active connections in the pool.\r\n\r\n__Example__\r\n\r\n```javascript\r\npool.close()\r\n```\r\n\r\n## Request\r\n\r\n```javascript\r\nconst request = new sql.Request(/* [pool or transaction] */)\r\n```\r\n\r\nIf you omit pool/transaction argument, global pool is used instead.\r\n\r\n### Events\r\n\r\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\r\n- **row(row)** - Dispatched when new row is parsed.\r\n- **done(returnValue)** - Dispatched when request is complete.\r\n- **error(err)** - Dispatched on error.\r\n- **info(message)** - Dispatched on informational message.\r\n\r\n---------------------------------------\r\n\r\n### execute (procedure, [callback])\r\n\r\nCall a stored procedure.\r\n\r\n__Arguments__\r\n\r\n- **procedure** - Name of the stored procedure to be executed.\r\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.input('input_parameter', sql.Int, value)\r\nrequest.output('output_parameter', sql.Int)\r\nrequest.execute('procedure_name', (err, result) => {\r\n    // ... error checks\r\n\r\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\r\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\r\n    console.log(result.recordset) // first recordset from result.recordsets\r\n    console.log(result.returnValue) // procedure return value\r\n    console.log(result.output) // key/value collection of output values\r\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\r\n\r\n    // ...\r\n})\r\n```\r\n\r\n__Errors__\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- ENOCONN (`RequestError`) - No connection is specified for that request.\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\r\n\r\n---------------------------------------\r\n\r\n### input (name, [type], value)\r\n\r\nAdd an input parameter to the request.\r\n\r\n__Arguments__\r\n\r\n- **name** - Name of the input parameter without @ char.\r\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\r\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\r\n\r\n__Example__\r\n\r\n```javascript\r\nrequest.input('input_parameter', value)\r\nrequest.input('input_parameter', sql.Int, value)\r\n```\r\n\r\n__JS Data Type To SQL Data Type Map__\r\n\r\n- `String` -> `sql.NVarChar`\r\n- `Number` -> `sql.Int`\r\n- `Boolean` -> `sql.Bit`\r\n- `Date` -> `sql.DateTime`\r\n- `Buffer` -> `sql.VarBinary`\r\n- `sql.Table` -> `sql.TVP`\r\n\r\nDefault data type for unknown object is `sql.NVarChar`.\r\n\r\nYou can define your own type map.\r\n\r\n```javascript\r\nsql.map.register(MyClass, sql.Text)\r\n```\r\n\r\nYou can also overwrite the default type map.\r\n\r\n```javascript\r\nsql.map.register(Number, sql.BigInt)\r\n```\r\n\r\n__Errors__ (synchronous)\r\n- EARGS (`RequestError`) - Invalid number of arguments.\r\n- EINJECT (`RequestError`) - SQL injection warning.\r\n\r\n---------------------------------------\r\n\r\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\r\n\r\n### output (name, type, [value])\r\n\r\nAdd an output parameter to the request.\r\n\r\n__Arguments__\r\n\r\n- **name** - Name of the output parameter without @ char.\r\n- **type** - SQL data type of output parameter.\r\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\r\n\r\n__Example__\r\n\r\n```javascript\r\nrequest.output('output_parameter', sql.Int)\r\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\r\n```\r\n\r\n__Errors__ (synchronous)\r\n- EARGS (`RequestError`) - Invalid number of arguments.\r\n- EINJECT (`RequestError`) - SQL injection warning.\r\n\r\n---------------------------------------\r\n\r\n### pipe (stream)\r\n\r\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\r\n\r\n__Arguments__\r\n\r\n- **stream** - Writable stream in object mode.\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.pipe(stream)\r\nrequest.query('select * from mytable')\r\nstream.on('error', err => {\r\n    // ...\r\n})\r\nstream.on('finish', () => {\r\n    // ...\r\n})\r\n```\r\n\r\n---------------------------------------\r\n\r\n### query (command, [callback])\r\n\r\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\r\n\r\n__Arguments__\r\n\r\n- **command** - T-SQL command to be executed.\r\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('select 1 as number', (err, result) => {\r\n    // ... error checks\r\n\r\n    console.log(result.recordset[0].number) // return 1\r\n\r\n    // ...\r\n})\r\n```\r\n\r\n__Errors__\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n- ENOCONN (`RequestError`) - No connection is specified for that request.\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\r\n    // ... error checks\r\n\r\n    console.log(result.recordset[0].number) // return 1\r\n    console.log(result.recordsets[0][0].number) // return 1\r\n    console.log(result.recordsets[1][0].number) // return 2\r\n})\r\n```\r\n\r\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\r\n\r\n---------------------------------------\r\n\r\n### batch (batch, [callback])\r\n\r\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\r\n\r\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\r\n\r\n__Arguments__\r\n\r\n- **batch** - T-SQL command to be executed.\r\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\n__Errors__\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n- ENOCONN (`RequestError`) - No connection is specified for that request.\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\r\n\r\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\r\n\r\n---------------------------------------\r\n\r\n### bulk (table, [options,] [callback])\r\n\r\nPerform a bulk insert.\r\n\r\n__Arguments__\r\n\r\n- **table** - `sql.Table` instance.\r\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\r\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\r\ntable.create = true\r\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\r\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\r\ntable.rows.add(777, 'test')\r\n\r\nconst request = new sql.Request()\r\nrequest.bulk(table, (err, result) => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\n**IMPORTANT**: Always indicate whether the column is nullable or not!\r\n\r\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\r\n\r\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\r\n\r\n__Errors__\r\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n- ENOCONN (`RequestError`) - No connection is specified for that request.\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\r\n\r\n---------------------------------------\r\n\r\n### cancel()\r\n\r\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\r\n    console.log(err instanceof sql.RequestError)  // true\r\n    console.log(err.message)                      // Cancelled.\r\n    console.log(err.code)                         // ECANCEL\r\n\r\n    // ...\r\n})\r\n\r\nrequest.cancel()\r\n```\r\n\r\n## Transaction\r\n\r\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction(/* [pool] */)\r\n```\r\n\r\nIf you omit connection argument, global connection is used instead.\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction(/* [pool] */)\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n\r\n    const request = new sql.Request(transaction)\r\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\r\n        // ... error checks\r\n\r\n        transaction.commit(err => {\r\n            // ... error checks\r\n\r\n            console.log(\"Transaction committed.\")\r\n        })\r\n    })\r\n})\r\n```\r\n\r\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\r\n\r\n__Aborted transactions__\r\n\r\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction(/* [pool] */)\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n\r\n    let rolledBack = false\r\n\r\n    transaction.on('rollback', aborted => {\r\n        // emited with aborted === true\r\n\r\n        rolledBack = true\r\n    })\r\n\r\n    new sql.Request(transaction)\r\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\r\n        // insert should fail because of invalid value\r\n\r\n        if (err) {\r\n            if (!rolledBack) {\r\n                transaction.rollback(err => {\r\n                    // ... error checks\r\n                })\r\n            }\r\n        } else {\r\n            transaction.commit(err => {\r\n                // ... error checks\r\n            })\r\n        }\r\n    })\r\n})\r\n```\r\n\r\n### Events\r\n\r\n- **begin** - Dispatched when transaction begin.\r\n- **commit** - Dispatched on successful commit.\r\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\r\n\r\n---------------------------------------\r\n\r\n### begin ([isolationLevel], [callback])\r\n\r\nBegin a transaction.\r\n\r\n__Arguments__\r\n\r\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\r\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction()\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\r\n\r\n---------------------------------------\r\n\r\n### commit ([callback])\r\n\r\nCommit a transaction.\r\n\r\n__Arguments__\r\n\r\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction()\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n\r\n    transaction.commit(err => {\r\n        // ... error checks\r\n    })\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\r\n\r\n---------------------------------------\r\n\r\n### rollback ([callback])\r\n\r\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\r\n\r\n__Arguments__\r\n\r\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst transaction = new sql.Transaction()\r\ntransaction.begin(err => {\r\n    // ... error checks\r\n\r\n    transaction.rollback(err => {\r\n        // ... error checks\r\n    })\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\r\n\r\n## Prepared Statement\r\n\r\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement(/* [pool] */)\r\n```\r\n\r\nIf you omit the connection argument, the global connection is used instead.\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement(/* [pool] */)\r\nps.input('param', sql.Int)\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n\r\n    ps.execute({param: 12345}, (err, result) => {\r\n        // ... error checks\r\n\r\n        // release the connection after queries are executed\r\n        ps.unprepare(err => {\r\n            // ... error checks\r\n\r\n        })\r\n    })\r\n})\r\n```\r\n\r\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\r\n\r\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\r\n\r\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\r\n\r\n---------------------------------------\r\n\r\n### input (name, type)\r\n\r\nAdd an input parameter to the prepared statement.\r\n\r\n__Arguments__\r\n\r\n- **name** - Name of the input parameter without @ char.\r\n- **type** - SQL data type of input parameter.\r\n\r\n__Example__\r\n\r\n```javascript\r\nps.input('input_parameter', sql.Int)\r\nps.input('input_parameter', sql.VarChar(50))\r\n```\r\n\r\n__Errors__ (synchronous)\r\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\r\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\r\n\r\n---------------------------------------\r\n\r\n### output (name, type)\r\n\r\nAdd an output parameter to the prepared statement.\r\n\r\n__Arguments__\r\n\r\n- **name** - Name of the output parameter without @ char.\r\n- **type** - SQL data type of output parameter.\r\n\r\n__Example__\r\n\r\n```javascript\r\nps.output('output_parameter', sql.Int)\r\nps.output('output_parameter', sql.VarChar(50))\r\n```\r\n\r\n__Errors__ (synchronous)\r\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\r\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\r\n\r\n---------------------------------------\r\n\r\n### prepare (statement, [callback])\r\n\r\nPrepare a statement.\r\n\r\n__Arguments__\r\n\r\n- **statement** - T-SQL statement to prepare.\r\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement()\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\r\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\r\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\r\n\r\n---------------------------------------\r\n\r\n### execute (values, [callback])\r\n\r\nExecute a prepared statement.\r\n\r\n__Arguments__\r\n\r\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\r\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement()\r\nps.input('param', sql.Int)\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n\r\n    ps.execute({param: 12345}, (err, result) => {\r\n        // ... error checks\r\n\r\n        console.log(result.recordset[0].value) // return 12345\r\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\r\n        \r\n        ps.unprepare(err => {\r\n            // ... error checks\r\n        })\r\n    })\r\n})\r\n```\r\n\r\nYou can also stream executed request.\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement()\r\nps.input('param', sql.Int)\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n\r\n    ps.stream = true\r\n    const request = ps.execute({param: 12345})\r\n\r\n    request.on('recordset', columns => {\r\n        // Emitted once for each recordset in a query\r\n    })\r\n\r\n    request.on('row', row => {\r\n        // Emitted for each row in a recordset\r\n    })\r\n\r\n    request.on('error', err => {\r\n        // May be emitted multiple times\r\n    })\r\n\r\n    request.on('done', result => {\r\n        // Always emitted as the last one\r\n        \r\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\r\n        \r\n        ps.unprepare(err => {\r\n            // ... error checks\r\n        })\r\n    })\r\n})\r\n```\r\n\r\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\r\n\r\n__Errors__\r\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\r\n- ETIMEOUT (`RequestError`) - Request timeout.\r\n- EREQUEST (`RequestError`) - *Message from SQL Server*\r\n- ECANCEL (`RequestError`) - Cancelled.\r\n\r\n---------------------------------------\r\n\r\n### unprepare ([callback])\r\n\r\nUnprepare a prepared statement.\r\n\r\n__Arguments__\r\n\r\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\r\n\r\n__Example__\r\n\r\n```javascript\r\nconst ps = new sql.PreparedStatement()\r\nps.input('param', sql.Int)\r\nps.prepare('select @param as value', err => {\r\n    // ... error checks\r\n\r\n    ps.unprepare(err => {\r\n        // ... error checks\r\n\r\n    })\r\n})\r\n```\r\n\r\n__Errors__\r\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\r\n\r\n## CLI\r\n\r\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\r\n\r\n__Setup__\r\n\r\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\r\n\r\n```json\r\n{\r\n    \"user\": \"...\",\r\n    \"password\": \"...\",\r\n    \"server\": \"localhost\",\r\n    \"database\": \"...\"\r\n}\r\n```\r\n\r\n__Example__\r\n\r\n```shell\r\necho \"select * from mytable\" | mssql /path/to/config\r\n```\r\nResults in:\r\n```json\r\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\r\n```\r\n\r\nYou can also query for multiple recordsets.\r\n\r\n```shell\r\necho \"select * from mytable; select * from myothertable\" | mssql\r\n```\r\nResults in:\r\n```json\r\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\r\n```\r\n\r\nIf you omit config path argument, mssql will try to load it from current working directory.\r\n\r\n## Geography and Geometry\r\n\r\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\r\n\r\n```sql\r\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\r\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\r\n```\r\n\r\nResults in:\r\n\r\n```javascript\r\n{ srid: 4326,\r\n  version: 1,\r\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\r\n  figures: [ { attribute: 1, pointOffset: 0 } ],\r\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\r\n  segments: [] }\r\n\r\n{ srid: 0,\r\n  version: 1,\r\n  points:\r\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\r\n     { x: 20, y: 180, z: NaN, m: NaN },\r\n     { x: 180, y: 180, z: NaN, m: NaN } ],\r\n  figures: [ { attribute: 1, pointOffset: 0 } ],\r\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\r\n  segments: [] }\r\n```\r\n\r\n## Table-Valued Parameter (TVP)\r\n\r\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\r\n\r\n```sql\r\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\r\n```\r\n\r\nNext we will need a stored procedure.\r\n\r\n```sql\r\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\r\n```\r\n\r\nNow let's go back to our Node.js app.\r\n\r\n```javascript\r\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\r\n\r\n// Columns must correspond with type we have created in database.\r\ntvp.columns.add('a', sql.VarChar(50))\r\ntvp.columns.add('b', sql.Int)\r\n\r\n// Add rows\r\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\r\n```\r\n\r\nYou can send table as a parameter to stored procedure.\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.input('tvp', tvp)\r\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\r\n    // ... error checks\r\n\r\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\r\n})\r\n```\r\n\r\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\r\n\r\n## Affected Rows\r\n\r\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\r\n\r\n__Example using Promises__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\r\n    console.log(result.rowsAffected)\r\n})\r\n```\r\n\r\n__Example using callbacks__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\r\n    console.log(result.rowsAffected)\r\n})\r\n```\r\n\r\n__Example using streaming__\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.stream = true\r\nrequest.query('update myAwesomeTable set awesomness = 100')\r\nrequest.on('done', result => {\r\n    console.log(result.rowsAffected)\r\n})\r\n```\r\n\r\n## JSON support\r\n\r\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\r\n\r\nExample\r\n```sql\r\nSELECT\r\n    1 AS 'a.b.c',\r\n    2 AS 'a.b.d',\r\n    3 AS 'a.x',\r\n    4 AS 'a.y'\r\nFOR JSON PATH\r\n```\r\n\r\nResults in:\r\n```javascript\r\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\r\n```\r\n\r\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\r\n```javascript\r\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\r\n```\r\n\r\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\r\n\r\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\r\n\r\n## Errors\r\n\r\nThere are 4 types of errors you can handle:\r\n\r\n- **ConnectionError** - Errors related to connections and connection pool.\r\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\r\n- **RequestError** - Errors related to queries and stored procedures execution.\r\n- **PreparedStatementError** - Errors related to prepared statements.\r\n\r\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\r\n\r\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\r\n\r\n### Error Codes\r\n\r\nEach known error has `name`, `code` and `message` properties.\r\n\r\nName | Code | Message\r\n:--- | :--- | :---\r\n`ConnectionError` | ELOGIN | Login failed.\r\n`ConnectionError` | ETIMEOUT | Connection timeout.\r\n`ConnectionError` | EDRIVER | Unknown driver.\r\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\r\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\r\n`ConnectionError` | ENOTOPEN | Connection not yet open.\r\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\r\n`ConnectionError` | ESOCKET | Socket error.\r\n`ConnectionError` | ECONNCLOSED | Connection is closed.\r\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\r\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\r\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\r\n`TransactionError` | EABORT | Transaction has been aborted.\r\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\r\n`RequestError` | ECANCEL | Cancelled.\r\n`RequestError` | ETIMEOUT | Request timeout.\r\n`RequestError` | EARGS | Invalid number of arguments.\r\n`RequestError` | EINJECT | SQL injection warning.\r\n`RequestError` | ENOCONN | No connection is specified for that request.\r\n`PreparedStatementError` | EARGS | Invalid number of arguments.\r\n`PreparedStatementError` | EINJECT | SQL injection warning.\r\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\r\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\r\n\r\n### Detailed SQL Errors\r\n\r\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\r\n\r\n- **err.number** - The error number.\r\n- **err.state** - The error state, used as a modifier to the number.\r\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\r\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\r\n- **err.serverName** - The server name.\r\n- **err.procName** - The stored procedure name.\r\n\r\n## Informational messages\r\n\r\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.on('info', info => {\r\n    console.dir(info)\r\n})\r\nrequest.query('print \\'Hello world.\\';', (err, result) => {\r\n    // ...\r\n})\r\n```\r\n\r\nStructure of informational message:\r\n\r\n- **info.message** - Message.\r\n- **info.number** - The message number.\r\n- **info.state** - The message state, used as a modifier to the number.\r\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\r\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\r\n- **info.serverName** - The server name.\r\n- **info.procName** - The stored procedure name.\r\n\r\n## Metadata\r\n\r\nRecordset metadata are accessible through the `recordset.columns` property.\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\r\n    console.dir(result.recordset.columns)\r\n\r\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\r\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\r\n})\r\n```\r\n\r\nColumns structure for example above:\r\n\r\n```javascript\r\n{\r\n    first: {\r\n        index: 0,\r\n        name: 'first',\r\n        length: 17,\r\n        type: [sql.Decimal],\r\n        scale: 4,\r\n        precision: 18,\r\n        nullable: true,\r\n        caseSensitive: false\r\n        identity: false\r\n        readOnly: true\r\n    },\r\n    second: {\r\n        index: 1,\r\n        name: 'second',\r\n        length: 4,\r\n        type: [sql.VarChar],\r\n        nullable: false,\r\n        caseSensitive: false\r\n        identity: false\r\n        readOnly: true\r\n    }\r\n}\r\n```\r\n\r\n## Data Types\r\n\r\nYou can define data types with length/precision/scale:\r\n\r\n```javascript\r\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\r\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\r\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\r\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\r\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\r\n\r\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\r\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\r\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\r\n\r\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\r\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\r\n```\r\n\r\nList of supported data types:\r\n\r\n```\r\nsql.Bit\r\nsql.BigInt\r\nsql.Decimal ([precision], [scale])\r\nsql.Float\r\nsql.Int\r\nsql.Money\r\nsql.Numeric ([precision], [scale])\r\nsql.SmallInt\r\nsql.SmallMoney\r\nsql.Real\r\nsql.TinyInt\r\n\r\nsql.Char ([length])\r\nsql.NChar ([length])\r\nsql.Text\r\nsql.NText\r\nsql.VarChar ([length])\r\nsql.NVarChar ([length])\r\nsql.Xml\r\n\r\nsql.Time ([scale])\r\nsql.Date\r\nsql.DateTime\r\nsql.DateTime2 ([scale])\r\nsql.DateTimeOffset ([scale])\r\nsql.SmallDateTime\r\n\r\nsql.UniqueIdentifier\r\n\r\nsql.Variant\r\n\r\nsql.Binary\r\nsql.VarBinary ([length])\r\nsql.Image\r\n\r\nsql.UDT\r\nsql.Geography\r\nsql.Geometry\r\n```\r\n\r\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\r\n\r\n## SQL injection\r\n\r\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\r\n\r\n```javascript\r\nconst request = new sql.Request()\r\nrequest.input('myval', sql.VarChar, '-- commented')\r\nrequest.query('select @myval as myval', (err, result) => {\r\n    console.dir(result)\r\n})\r\n```\r\n\r\n## Known issues\r\n\r\n### Tedious\r\n\r\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\r\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\r\n\r\n### msnodesqlv8\r\n\r\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\r\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\r\n\r\n## 5.x to 6.x changes\r\n\r\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\r\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\r\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\r\n- It is safe to pass read-only config objects to the library; config objects are now cloned\r\n- `options.encrypt` is now `true` by default\r\n- `TYPES.Null` has now been removed\r\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\r\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\r\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\r\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\r\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\r\n- Invalid isolation levels passed to `Transaction`s will now throw an error\r\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\r\nto create new connections or not\r\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\r\n\r\n## 4.x to 5.x changes\r\n\r\n- Moved pool library from `node-pool` to `tarn.js`\r\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\r\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\r\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\r\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\r\n\r\n## 3.x to 4.x changes\r\n\r\n- Library & tests are rewritten to ES6.\r\n- `Connection` was renamed to `ConnectionPool`.\r\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\r\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\r\n- Affected rows are now returned as an array. A separate number for each SQL statement.\r\n- Directive `multiple: true` was removed.\r\n- `Transaction` and `PreparedStatement` internal queues was removed.\r\n- ConnectionPool no longer emits `connect` and `close` events.\r\n- Removed verbose and debug mode.\r\n- Removed support for `tds` and `msnodesql` drivers.\r\n- Removed support for Node versions lower than 4.\r\n\r\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\r\n[npm-url]: https://www.npmjs.com/package/mssql\r\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\r\n[downloads-url]: https://www.npmjs.com/package/mssql\r\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\r\n[david-url]: https://david-dm.org/tediousjs/node-mssql\r\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\r\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\r\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\r\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\r\n\r\n[tedious-url]: https://www.npmjs.com/package/tedious\r\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\r\n","engines":{"node":">=6"},"gitHead":"a33df999952b9adaf34069b2d98472254362bd3a","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4","tedious":"^8.0.1"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^6.2.2","standard":"^14"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.0.0-alpha.1_1584139036053_0.4817890226071979","host":"s3://npm-registry-packages"}},"7.0.0-alpha.2":{"name":"mssql","version":"7.0.0-alpha.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.0.0-alpha.2","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"9aa8ab657a2ba105772de1e21941b5255fd9534f","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.0.0-alpha.2.tgz","fileCount":37,"integrity":"sha512-fmmXq7fUmgrHOZRO0f5Za40la99CGas12crEmgzB9r5E38YJIIc9GSHy1/tK8ybcbz9APryxCJK+nrmitU77sA==","signatures":[{"sig":"MEQCIAYOYPeefJkx+IlMCyWAorAEHYzbGotuTm/PEksz6IFgAiAx4yFB19eNrouVs1NAXgzK33XRyo1YBx2Y1W8f1cnjgA==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":230094,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJeoc57CRA9TVsSAnZWagAAtWwQAJKh52WcZzGyOau+Zoqv\nS09mwmOxkuh+wavFHQ685Yv87JZcvG2WDfV3E66rME5uDe094PDWRj4McyE1\nU8sQUf3Ei9ErNYNsjkBV1EgU3yCUW982Yf5UY0N/DcKqhGsocT2IVau0XXG+\no94dcyRzQeGxalWSbQC/WzAt5hrlUyqA7ixgjEkSTM/EcPoIDHPBWbn/qS0D\n+/itrwffgLdH/uqyzXIpvxVAMFphZB2n8xBQftDO1lSe5ibW6Kux6v9F0Asd\nrcomPwiDNqI0X/IkxFBIMocyHlNHDAkMfxWibbAVPS7bPuYEk4SnoR01mR3F\nN7NWOMubGfI8kELAo5KSu0bGeXvfmRUV7YaBwHt6Sph4DiicvKnYVbEUGKLs\nRTdTiO/CSw10v+hMAsWtCBncoULkYFtei5N0gGMrPtUT6Yz/5hh0ze4iwISa\niGFgLRCDvqgt8SxJTTxTmSbZvDGf/9TvJiVqEx2ZytYR3bCyzjOGagr4j0OA\nUcp6M54U2S9DIOElYtfkQSCWev+d5ZguQyGBDIoyooBSpNDIqeplpAewxEYL\nh49WRHm7a3HnPPwofe5dDbIPXlqxGW/mBVAJglaDCKjTdgYj9KCx94zErQsc\nmhfNikpbQpqRloI3u5XmedF5F9ETR9mqmbN3nBQnM9Y/9ebl8wI+Sxqta0FY\nfhIm\r\n=Owxw\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [6.x to 7.x changes (pre-release)](#6x-to-7x-changes-pre-release)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    throw new Error('Pool with this name already exists')\n  }\n  return POOLS[name] = (new ConnectionPool(config)).connect()\n}\n\nfunction closePool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    const pool = POOLS[name];\n    delete POOLS[name];\n    return pool.close()\n  }\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 6.x to 7.x changes (pre-release)\n\n- Upgraded tedious version to v8\n- Requests in stream mode that pipe into other streams no longer pass errors up the stream chain\n- tedious config option `trustServerCertificate` defaults to `false` if not supplied\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"b4aac72506bb0cc83b8585c2d81363d9557f4883","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4","tedious":"^8.3.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^6.2.2","standard":"^14"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.0.0-alpha.2_1587662458789_0.8811384541073426","host":"s3://npm-registry-packages"}},"7.0.0-alpha.3":{"name":"mssql","version":"7.0.0-alpha.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.0.0-alpha.3","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"b7ee182aae9a736ec17a16d84fe62c4c6fe64e3e","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.0.0-alpha.3.tgz","fileCount":37,"integrity":"sha512-9pLbGQLkpr2YsTwoXwxVRg7QB9vpLCw3xWuj+RMypCCyN/e9uXnkyDj7nitasig5uWCVTc+v16+HQk5WONZQXQ==","signatures":[{"sig":"MEUCIBgt0yGgyaFhFXfv5j6rrkmKRTXvwk6mq1eIhmP+uc5sAiEAi2pxyy68TYRR2xwf+6EQEls+mESSiGp2/ugWbaFSUVA=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":231727,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJe+iAbCRA9TVsSAnZWagAAJ2UP/3uPPkBqZI9JKcphtYGp\n83hW9cXGwmFOfCZqVYsFAUWJ3qDU+Vtq2mN5z7sy/cO1EpruNsqZvotmkS/e\njYcB6YVxEypYxvVDtzyaHhTHoOLghuPTXENf4yqka/iM/+7WO89ubWN2SNnY\n5TPpzfjJNAnU9MpPm1JxT+Nh153SCb0SLjdVNy+5nw7EzY3efCfKekdRFK+Z\nH1g067HHiZ4xKbPblPuuHNJsTUxUO5b59ZF1oBusyRXPMhpYUUfQKIcyVNYD\nTEXWO2/12gRGxxJKlMhcelv+0MwQrUbXsGUA2s/DpRxVkWnusIvYqZ+UT1Lr\neqHicecMppjdVmOG0pdagv6ogmU+nx5jS40yQzt/chu79z24Flgtwf35+NNJ\nWt1VmdlKjxuhXihRDyNjF7cbCEuMq4BNj5OxhTJBit/9G9UuwiDD4MT+/s8g\nglCgKGOExYkBMBlqo5EaYJFJaZnttouLePSVcxDTzkCNeosdLopHWLNxpmYj\nsBici9e2HnZ0tKPmKJmjMqGN7lIunGt+7nnXi7xWu8+NSA1ATi0IM6/pdtx0\nc+07h/JAhk3zkd+X1QLqWIomY75dlr328D2YkTkVMls88j5l/rxjkv3c+LYW\nif7vw5VR24PxDjahHpIFRl/SNiIX7vn7y7i/+HgHAAcueFp52fshGPSz0/Zw\nb2hY\r\n=zInw\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Response Schema](#response-schema)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [6.x to 7.x changes (pre-release)](#6x-to-7x-changes-pre-release)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    throw new Error('Pool with this name already exists')\n  }\n  return POOLS[name] = (new ConnectionPool(config)).connect()\n}\n\nfunction closePool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    const pool = POOLS[name];\n    delete POOLS[name];\n    return pool.close()\n  }\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Response Schema\n\nAn object returned from a `sucessful` basic query would look like the following.\n```javascript\n{\n\trecordsets: [\n\t\t[\n\t\t\t{\n\t\t\t\tCOL1: \"some content\",\n\t\t\t\tCOL2: \"some more content\"\n\t\t\t}\n\t\t]\n\t],\n\trecordset: [\n\t\t{\n\t\t\tCOL1: \"some content\",\n\t\t\tCOL2: \"some more content\"\n\t\t}\n\t],\n\toutput: {},\n\trowsAffected: [1]\n}\n\n```\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 6.x to 7.x changes (pre-release)\n\n- Upgraded tedious version to v8\n- Requests in stream mode that pipe into other streams no longer pass errors up the stream chain\n- tedious config option `trustServerCertificate` defaults to `false` if not supplied\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"560c094ee5872c548d9c2725b6dec4b38cb610bd","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4","tedious":"^9"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^6.2.2","standard":"^14.3.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.0.0-alpha.3_1593450523051_0.22420171205965422","host":"s3://npm-registry-packages"}},"4.3.9":{"name":"mssql","version":"4.3.9","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@4.3.9","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"e84713909d5c404d261df67173639294bacb26d2","tarball":"https://registry.npmjs.org/mssql/-/mssql-4.3.9.tgz","fileCount":19,"integrity":"sha512-Qy/ewvlCHIJ13bPXTXaP7ZTskWMB0gwcYUtVedt7HvEAbRneYfggUe5mbRc/e9I12mdvepGKAXfm1bn20X4S8g==","signatures":[{"sig":"MEYCIQCQDfep7b/4wl2GHqvDxtN1I0k7uUnvXQOco5u3ddq+rgIhAIszuoL5rvcO04C38wx8IXw6M7Sdt+2gPkYpWOzl5Q7i","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":197799,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfGJ/LCRA9TVsSAnZWagAA9nIQAJDXZzAatagH2UkvmHOH\ntSCvJhtpUVlQx5/zSBV7d46Rjgc35HCO+C/Ntt5fIn3M02NfAmsG9D0BVU9k\ncqMwNVE6cYOw4WJ6kfPtUNr4GyxNRV89bBkikiap1+N1SUyaA+2b7riANPiD\nkhFkLeTWUgT7Q5zCSVTsEy1sJUNEQ/goDUVrpdf574D/jw+xtlhf48TU46fQ\nNlK6PkTSfPjRIgysy0SmhV6r//hHoQYh5L1mm6WcZQinb49hbYlFdcuB2lXv\nAkatVflvCBQmaGsS8sc2q6D7bbruWFTrHAGmWQOikXFCWJ5nzxXkXPCXCqqB\nvI3A8wRjpCE/9oPc03l5g0n03pY3KXqMJxKJ6iIUIla+cvZ+E6ZyL8ZIQWm2\nfAeQzG2doLFWFT71LAcLR3AurYcgCe0Aig+ccfdsyUh3pJTOwxLzOClg2lEC\ni/VC1+SiJlQdgyeaKQ7Z4DG02kwQHivTV6oeZjmmr0evY6Z4h5HsZxp2POxF\n7m/vP/sfzvb2byLiRQP2BbhhHz1HEj16GL389OtdrPl5gR2cvOP4t0JtaAWz\njSs16jFfMd7P9Z1Jslk1nCGblkNmvE19TNaV7BKrgjDUA1k48qWmyXL0WN68\nB5/fct6qjd8oXrT4c5W71PNioWf+d9BHmrRIj481hDWQCp1KYdEzxj+ZYKjk\nFxmb\r\n=1lVr\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\nUse `@next` tag to install the most recent version with latest fixes and features.\n\n    npm install mssql@next\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n});\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement!\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://img.shields.io/appveyor/ci/patriksimek/node-mssql-o4dhf/master.svg?style=flat-square&label=integration\n[appveyor-url]: https://ci.appveyor.com/project/patriksimek/node-mssql-o4dhf\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=4"},"gitHead":"1b838e312755703cdac4760545b531c81787fd92","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha -t 15000 test/common/cli.js","test-unit":"mocha -t 15000 test/common/unit.js","test-tedious":"mocha -t 15000 test/tedious","test-msnodesqlv8":"mocha -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"debug":"^3.2.6","tedious":"^2.7.1","generic-pool":"^3.7.1"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_4.3.9_1595449291185_0.3084127351200108","host":"s3://npm-registry-packages"}},"5.1.2":{"name":"mssql","version":"5.1.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.1.2","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"7c8a7a65416aeb94c933800c863b8210ca69789f","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.1.2.tgz","fileCount":19,"integrity":"sha512-m7FJdnwbJmXhfUOPEz0ZDCuP04c8ar6XmLqLmNY7WgpC4aE/4Dw8ojhHyXjUR1Iw6N7I2KzAy8jdGBerzce9jQ==","signatures":[{"sig":"MEUCIQDGl4CGwJpBLg+r54MNsR0DvxoiPAYrM2YwqwbjQy3PYwIgawzdpsnCL4snhOfA40KVt+lLlFCRPI83h2IFzgcWIBU=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":203936,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfGKC9CRA9TVsSAnZWagAAIegP/j1tSPAOkyBE51wm4uAw\nPw8wHSlsi6AHEh6Nf+v4V9OlV3dwAkNGkoQgFg2UWV/4UrkWx3g+g1T555Jc\nEPBCt3q9aAvWSOXES9toWCUNAnkRU2rROBPkKsAIafZpifK08LufhNUv1XE4\nKehhkSWcthz828AHamfiFtysiMt4gqZQEEgJUznCEjf1Xu3WHBd6mlVVTmk/\ndYLFr85mJVf/imppMekeESKPm80W4J5UqZGgXrkqofV9VI5gc29NP9YjGh3J\nQKyiKLsZ38OQ0HTvTlm6o1nVSR0Oe5R0hwgdO5JoJ2pt5x9ewznqoNJ970Q4\nUvi5m5pY0VBAPE2c1Kup1DBFX/A5P7g5RTDmhaX8poqxKDHuY1WWdjfQKE3P\n25zxl+GjGspply9ew9vS4W/xzr3PQ0RvSyGPB3SKLFH0l1/MXowNQZXUaIM0\naGMoRO92gGSYvwe5mpuoU5/534idM1+UfeCKfw1+bMB9WhP4G+s+tbMY5dM0\nJA93/bIieNz4yWi+HFM1+7EoFNbswc4W5Ek1bCzNZhsLRSwIVERd7xi5+J/K\nxzKdxjniEmaMNPcyYy5iPP4VA4GBFu/ljWsCu4Of1h6MPQjFW1NG7l0EuEzv\nu9oJlw+y6Ly6Tu7BtRDIQsR/5Cjdu2DvE5ZI6rEBdqSkpaxOwsHfW5rVOkB5\nZ1/I\r\n=QuvA\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n}).connect();\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"26f9b888687c90e54bbb81dbef5bed1c63f3ceda","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"debug":"^3.2.6","tedious":"^4.2.0","generic-pool":"^3.7.1"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.1.2_1595449532458_0.21565852680394682","host":"s3://npm-registry-packages"}},"6.2.1":{"name":"mssql","version":"6.2.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.2.1","maintainers":[{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"dhensby","email":"npm@dhensby.co.uk"},{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"4f18b8e2a29d67ee341dca84870d5de6234f7709","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.2.1.tgz","fileCount":37,"integrity":"sha512-erINJ9EUPvPuWXifZfhum0CVEVrdvnFYlpgU6WKkQW69W4W7DWqJS2FHdedHnuJWlJ8x1WW1NcD8GFfF15O2aA==","signatures":[{"sig":"MEQCIAamrBpbUs7MSFBRwVvXZRY5w1jF0gMJUYbhGtHy5CuhAiBuPU5T8kelaiTL9r0Cn2BPUTvdL2DXTzr9QcJAzECD6w==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":230602,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfGKLeCRA9TVsSAnZWagAAApIP/iZHXTp6NAJv7ydqwe5f\nTpuhk480QpYSppuN1OqZndRsWadHwvlUDvnkFm/HAyafn9nC0/emXh+rOGm2\nGILgmiYpUL8lcOH+qnXnTNtcNbg2AqU2XQs7jg2kfPN1PfAtXK10fhwsoIs0\neQHjUubNEIS9E8Xb6Sv8gpDhWbVWv46/Kl73Z6TI5ciFpA8nEogN8kGp6bnu\nrX8mZA5OeJCZ7H0Fz09hds37HwIo2cvLbX1BxicacywhkSwpmna2tR4Mdp/n\nKwkVXU6XG7yvrwElMdjRFjqyJn48reLTdsPiRCEVyDzoL/vuN2Ak5wkOXb55\ni1EeK15RNmJE4ERASdR90i5Reok95qKVctU9WMQ2vN8YVy5OIrCp5jSjmU2I\nn10odBALYqKoPILCMItEZdYw0vMY8yjPDqk6mubZFexNzQRFnWCXqcDhZWFD\n66snFWjCrFfAnSM1ksgsDt1kO00/Zyj+O5ac+ViyANuCy0v18zxpeQnF9uYa\nMsXHtLwTz4ONkmqUJa/RlOba0hKBtWoxxm56wdcSxW2qo12ucpFx0pk3CECD\ngLfVTa7SFo5sH1gsjwcOuLtMiCNvbJEHrP0y5P9+UBqby50PTORCOzBP442M\nUjzemzOafrF3ddCEBdqPC5dp+iVTtQ2SBZFuA7/ftmQTVmdEukBfadiZUXNe\nBj63\r\n=KzOY\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"bbd469afafc1eff35199e8cf9b8f8ecdd962350b","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4","tedious":"^6.6.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6.2.2","standard":"^14"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.2.1_1595450077687_0.5221701529942557","host":"s3://npm-registry-packages"}},"5.1.3":{"name":"mssql","version":"5.1.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.1.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"03ae3cca9c2990cbd1efbe53e25842b582009396","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.1.3.tgz","fileCount":19,"integrity":"sha512-Nz2rEXiR5NTW+Fe/rnZs9FE9wyNyZ3vgkuHHbmanlXyAtKl2GqtO05t9aSFjswoUJEaeTnGMpKd9hhudnLIEDg==","signatures":[{"sig":"MEQCIGt9prGOYjC76HL2iRe6cWFObj61IfxmyNO9f5Nfe2u5AiBH7QD+huK7M1rR+yBnD0d6z8Ki0D/MK8KVBJ4976j4XA==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":202965,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfZLPsCRA9TVsSAnZWagAAkmYP/1lre0b1vJw48gcVWq7F\nhnmVGyUKZJvW05KHrvCV4dJMyLL6yQk5JdwioHqmvVR7Epauy3vpYXa3xhCq\nLGmlqgg/jJzmpxrEJW2PeDPb0ZZSyMf3ZL3Bc4g6ZDm0P3nyMPBiP+TyOOmf\nRgSnv83mb+U1HhRSBTRDoeUC002VHCBGBr/SVo6EOkUsCFeRcRSe4KKgprL1\nWZ3T2afwUQfDbzwp1RGFPfoM0nYOU4lVYnVZDuac8nHiTA2sGzU+qeJxg4sn\n4LgF7marUitS4YgKeItDyhmGOIyHLfzBBPM55qZT7oJE9DyQnvL19jKa2y/t\nq6EENdXwZiVN7K82yDzns6H/smkqYOkGQ/ePIOAUN8ggHcM5NiKKlAdi9LIz\n7U4pf5JM3mYtNP852332Ej/URCPtkRnBJlINbOYTlkFb5zttisJ6m0+OwCaz\nWYnWY/JBsXPUS2s5OgJQ3l5X39FKf6rhVCROUdVEYDkZ47/OlOO4SmVNlhV1\nFOqkq602pkL0caGka7Z3lRYoZjCLPqf7KK1OgEIcv7R5HMcTCvYNrPm+8rxk\nhwaZiEBvXICnbWXHPqnb81a9Pdf1emSoUFERfGoSo6pGStFKTgtB/07c5qOC\naqSXbmcUMynlKzmc2MnF8oTVgxMN62KeLj4z4FyZDwnplSYGi/dSgoh4PNzT\nVlFS\r\n=O9DY\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n}).connect();\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"ecd4a11befb664358a1cd48a59617a39c151a976","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"debug":"^3.2.6","tedious":"^4.2.0","generic-pool":"^3.7.1"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.1.3_1600435179915_0.8568096132456959","host":"s3://npm-registry-packages"}},"6.2.2":{"name":"mssql","version":"6.2.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.2.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"b7136df2f24950262ee7f6f53eeedeb18f123463","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.2.2.tgz","fileCount":37,"integrity":"sha512-+G/E2Xw801ep4O5p5SDuV0u2LDpCuGIvVCLCNhTjILpF5hKJovjRh8S3t+A1Fwlly7zVx9rckEVo5c0cXo+BPQ==","signatures":[{"sig":"MEQCIGpFhuOwmoKd0EgomffIUWCOBCs311Co2Eu5iVFnB8SgAiA+fuSVNz6dxE1z6XkqNkAkbzuw/owJ1C/OLMpMhjEHyg==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":229988,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfZLYYCRA9TVsSAnZWagAADZ0P/ApEocMVeumfCi4QlDc1\n3nt5ftEZ4/wIXc6Kud8ul+SY583xp/X43Od36QT0KhjC2jXq9UafJCS0NCm7\nSOg07SVPilvCVnZH5eDlhkhDLocKeNKeMwMtbXW5H08VCG+9ce6gLkZo3060\nWzV1EC1AjfMvwbUcQJczN2mK0YyEHJji86u3l0ZGtosLn1priJ8Qdys1w8gJ\noSNCWsrvxPfPVBulZBvcjrJOEDDMUyyafuPN0H3bonavNtJv33Ty1fc0g2Xi\njjEVPJen+x9BS/WkangNvbIUbHUA5UPTsYUO0T7lhoYCp7f1xjclLXrUkUVD\nIl4Jy4FgYY0BcpqSUuhmI8LJP0pHHhxI7BeXRo5DiYgAqUSlPx8khNYOl/iD\nBUKx/gqNnacxg7/bQASLIYfE1OoCe+ztxMqNceQtgOzx1JaMitckL+YeLgJ+\njnQaX9oyDYa9BSRparum0fm1nPoSh8rnfkyMSudpUdgfHeK6Uo4guEYGNfq/\n+PL1m7tZAsPBr/GmIdfQiRRu0LUvsMXC29wx8l4t/46G8vx/Y98XegfjKoe4\nmiZ9vSasr4hsGKsnO7GVctlfpaVYmB2DVBx2GP7R+4pnU5+MjnxtK7gbJKz7\nfJKcOXOtPKxkejsVhdQnOuFNWhVMDm0dOUm+9YoybSuKOamEUX92UuAFot7z\nocIy\r\n=hcqA\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"2c7ffffc2270994f0aa5c4779ca7d981499182e2","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4","tedious":"^6.6.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6.2.2","standard":"^14"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.2.2_1600435736390_0.09086556524363854","host":"s3://npm-registry-packages"}},"6.2.3":{"name":"mssql","version":"6.2.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.2.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"1d15bbe8c3057e32ee6e98596b6c323b097a6cba","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.2.3.tgz","fileCount":37,"integrity":"sha512-4TW/fA9UgzmVTNgjl65r6ISr6aL5QHnlptEt1A3jIpdzkNbFPIkRbUNz90324HIdE+5pKc3VqikOImcTrhd4og==","signatures":[{"sig":"MEUCIDh8ZQPRB/WF2Q0oJIqI69VE0qMej1MTVEY/SNDqYJ8BAiEA+z8R/zEk6sq1C2q8tePhjqhtNXIkW81Jd2+jVacBd04=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":230639,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJfbeR5CRA9TVsSAnZWagAApn8P/jXexoZgQsERxDdIK9nL\nVNhneRQy/TsMmAAFBnf8NsrsigcVYeOZnNm+1GCh2/y5TzXNwhBtMatRFCEl\no+q0kxjVE0N1v8sseuI2KUticyfnKG4/6M/wRwo5PFvMkGg+z6jA6NhDGe/l\nBid+WV7jS3C9v5HZtFmR9RrvYtQKouvxWwqiscNbWMd1GdWnL30zdFRm4E2X\nYKZI6exK7CifvguborgQLrbKU6q909Fl17mdUNFKqYcfRrrIXgZFAbmDvrW+\nbwbF5IruRElT+JTjqLU9UEXrkw3yWV0CYT2o46MfP5v2PXVw9ltGGfAGi9hv\nkuhVdu1OGMSzdLJTn3I6kdIodFgYiwsd7hPTFCvAT0eVf5ZE59bN2whxwrEX\nnvOETLAH04L8uKyikvX8flZKAvZQbgJ43AQ9WZDvU0NTPnljM1j/8LwMQIC5\nGeYKo9SmheBL7tpY1qZKtBOxVWZW7Obo/GyCrglgEQB/aBTS5siQukxDiTRX\nbI6svpgiWOYXlCtNPgfUWCoOZpPPv2mwbdsAY6TjteA6eZ3OK69tWmHBeDFY\nfLdb9b9j7ztvm+iWDYXjVo5KMgo49dK5Cm9KVc8Adu/fOpZ1J4FTvz8YpfOE\nX+9MxigsMQ/tO31UMj6+J9pCQz99k6ogSGWqfdH8xH0VuoSc68Raek64sftO\nqymL\r\n=KcOz\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"8ba04f79f957908f32d614dc0c0c67104195d523","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4","tedious":"^6.6.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6.2.2","standard":"^14"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.2.3_1601037433089_0.7873474213403382","host":"s3://npm-registry-packages"}},"6.3.0":{"name":"mssql","version":"6.3.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.3.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"ad070d07fd3690d172541a9944fb7cf18caee41d","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.3.0.tgz","fileCount":38,"integrity":"sha512-6/BK/3J8Oe4t6BYnmdCCORHhyBtBI/Fh0Sh6l1hPzb/hKtxDrsaSDGIpck1u8bzkLzev39TH5W2nz+ffeRz7gg==","signatures":[{"sig":"MEUCIQCNp2/R3i3MypyPrxUwADJILuVUgJv9jWfdYDbgj3hgxwIgEbDG4i4lGdjbR7Jh68VK0+at7mi1OWpSSn8J6MvaA2A=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":250603,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf125DCRA9TVsSAnZWagAA9cIP/Alx9pjgywl5HEtnwaLu\nAkrpkjeLVP81jJlRX5BMQVm+u5R2rtW3QnDlKTbswF4Imopt1TaVcD3VEWxi\nPTbfTK3Irsj7BTfJ4dSMoQn7ksEwhdspFD0E7Z3jTr0TOksa89tmaGTMXH9w\nZ47g9ewpQb0+H8ZW1N/V3qk0ILrOTD5M5saCANV7fHZlDSllIk1rlTB+WHg9\nbMQ1ZYsNloqjW1uv92h8SHD85P1+p6s/0stiswn0AF8nFUU2o8ALB3CyK73T\nZ9u+Z1tuy1KrJOn867plLEB7EzZ1XujFdyCXy0PY/UX+kIpPX9wZ3gahJ3zX\nCv2IvcESkDysll6lbhLjjS0Egfm+qQpsH2JL5hQv5QIigqTfwuPuVUFh937A\nUj15L6BZpQQ3op/uML6Lc20LXkAV9iewPi8dRPEwypQzfnIeLUNIVeQw01GQ\nutpRpgvnHD5h1Rb9YxcZYZkHS/t4DBPXP0sr87yk5zaQyhMa1FsGd1ApZh75\nyhh7sQQW90in4Y33EisffBbqfzQOeOnNZO3nxj7NyxNbXFQ2wiQXjUfNPJaX\n4FJMt4iP/hGMmMT2ySWChQAaTp+7e9m4jQDAw8R3VngfrFBcmsC6srNHK/ff\nv0ZAnRy40QwzDA2pQeQzhA7qh++gd25JDtiqVnBYRYkcC5+0Jc/bcOUMc0d+\nW4g4\r\n=ri6I\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"e45c0ae1f139d631908bae7327e9365b579b784f","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4.3.1","tedious":"^6.7.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6.2.3","standard":"^14.3.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.3.0_1607953986932_0.9485492832103743","host":"s3://npm-registry-packages"}},"5.1.4":{"name":"mssql","version":"5.1.4","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.1.4","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"70378857651b77ce58320923a705a33ccffd555d","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.1.4.tgz","fileCount":20,"integrity":"sha512-gyVAblm18RexdesxQubaLawjOyT8tPtBHuD2bdpoMYtythoJ8/Xs+DPYbdkNWOb2oU0uZrC87TdKVZhDWLwwlw==","signatures":[{"sig":"MEYCIQDwu0dkuz9lD5CMNLKMBAR5/MShjGjopwpXqAGQQrpTuQIhAJUxLtUM66eoYK9Dnxlb8qCtulrLy1Tgm6FAR3eLeyon","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":205383,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf7v52CRA9TVsSAnZWagAAXVcP/1f/AgGJKsSpovp4hSq6\nGSKrzTVfwpm19wzyyrlyoIWHvACCb8rc/oJQMtRRT9EoYV1AT5sgoXUJ27q3\nIR7OGFWiXe0fFEBJ07zp1YGBh99WiCgMwoW6URnHEd1KIGaJj4z3VY6DPRZC\nu0/A9HiJT93lanrerTCicMflCz91c7prFmBdWHgDMXsEQiO4fR/jlr22F4tH\nENvE3XAA8aQhdvPhpojHN00kEpbvNmQOZhwHg6Jt7kLjikskWOXpyfPoom6Y\nGUEZVubJ1NGnlBMbKlH2xG6iQ0iPp3NdyQGWPge65vJ3i0Z8FihpG+mXVtVo\nVMwZDgruyPE9u2WJxGhCeGxzeIN6QpHzaaHueRhB2Q53Xncmjw59BWwBRf+V\nQPrz5KpjcUrfmug+qR+DLUlCnLfx7fCQLaRxlgROqezp/Hr9cLqOkAeIY6G6\n8FzVFwnB39Gdr3WSFvlMBALkgpLEOoZauPfAvZheIvHDkuKjNjD/St92+DLq\nEHcHO8NIlcl9eJXaeRF0da/90s/8CvJRo0mc+xQcg/SAbp/dcBdSv3cX003a\nODctWn1OFmuqlATAkMDuk3Dw67im/Sb0oHDulw4daaDHl0rVGQlSKxpzc8ro\n7aJE2qQYHiWWGnqn0vCgN+K8eZ+xiDw1Xnn8aAIvHnSt3p+8O/e2Y8/a9Cb0\nRo6X\r\n=QYg2\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n\n    options: {\n        encrypt: true // Use this if you're on Windows Azure\n    }\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n    \n    // Stored procedure\n    \n    return pool.request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config).connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1; // ensures that the pool has been created\n    try {\n    \tconst request = pool1.request(); // or: new sql.Request(pool1)\n    \tconst result = request.query('select 1 as number')\n    \tconsole.dir(result)\n    \treturn result;\n\t} catch (err) {\n        console.error('SQL error', err);\n\t}\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config, err => {\n    // ... error checks\n}).connect();\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2.then((pool) => {\n\t\tpool.request() // or: new sql.Request(pool2)\n\t\t.input('input_parameter', sql.Int, 10)\n\t\t.output('output_parameter', sql.VarChar(50))\n\t\t.execute('procedure_name', (err, result) => {\n\t\t\t// ... error checks\n\t\t\tconsole.dir(result)\n\t\t})\n    });\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n\nComplete list of pool options can be found [here](https://github.com/coopernurse/node-pool).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `false`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js 0.12.x or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"38096d8e8d7360f10e06a03d47077d8731c1e56c","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"debug":"^3.2.6","tedious":"^4.2.0","generic-pool":"^3.7.1"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.1.4_1609498230018_0.08349440234871097","host":"s3://npm-registry-packages"}},"6.3.1":{"name":"mssql","version":"6.3.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.3.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"b6da02f9d4dc8f105ef54528a806922bac4aa20d","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.3.1.tgz","fileCount":38,"integrity":"sha512-ammxrhbdDpcBWhiZLiy6miiU7ELt9qFbGvwmPbiufn+tBHAYUFR/AgwE4/v4jzPzbatowscmhFx1U61L91uVzQ==","signatures":[{"sig":"MEUCIFZdVvCI1DQuxkDmcRZQCMw5PXvP4q2vMrOnVcddBhi0AiEAhdew9d4v7qJ9mkyr+wEHJBBttVnQKVjA34s80T/JnUA=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":242744,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf7wErCRA9TVsSAnZWagAA27YP/Ru0/to+Lw6Ogwy7lJas\nhid+l3j7VoXrhswjfGwqSptrw6m8tIOIcDrYidwcpHK3bf741Z1332sFyfkN\nCFG2fV0MJMPyx0NhvwxaCfpcKbTfXfU1o1FCN0GLTe544v88kqkO4TFFjXL+\nx5B/P8NzQgIgH8HI5LM7f95Kqq++dOSANfUG2XUFvXAxmaX9RNfwcfmYOJfj\nGrlajQd8zuRXuzQiFSF/6iaT+5z4dgMJjJR1UqCfLFoXNM1u04RfHK2Dc5+E\n9AZ/GU9Wg4PjYGeqZOwkaGNkJnLWuJMuZUxpubAoeaJEavqX0+wb5Q1IPO39\n1u5E1KmvkcI2tHD+yRu1yPMgMlWazdABq+MlaxIfTV8DP9bc4poT1k3YGmIG\n059iIP+MZA0wvOnM9inZhYALlgY+PaTlJUOUp08hMWzT1JiXmVmoIxLeTcUs\nUHMb5D/vkFbguV8yF9s3yf0XZHdGPlsgMbYDXyyzCzc1p8fuV1uqfTccSYAQ\nM8r37Cd0D1P9t24gg0s9QGINUaoG1XcyjcK9cbLOnZDwi8sZqIgXiJlebIyV\n0gie3lCPZkjpMjWnyo1/wSmqXLDVmp4DIu9CtX9araCeygydP+1A4mNlAS33\n02ncj03QN4kOWByVYKZRo8+Sjo7ZULf8/PQMFLbxK3qaKiQ0thRhwUhJPt5F\nzX9V\r\n=22jf\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"375419b590036bb8566bfc4452caa18b2ed444cd","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4.3.1","tedious":"^6.7.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6.2.3","standard":"^14.3.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.3.1_1609498922836_0.7231228039972872","host":"s3://npm-registry-packages"}},"7.0.0-alpha.4":{"name":"mssql","version":"7.0.0-alpha.4","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.0.0-alpha.4","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"0576ce177a38ccd66e8d7bfb1b6988f36cc3d8a6","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.0.0-alpha.4.tgz","fileCount":38,"integrity":"sha512-vt/OGFG2tw86TiEIAldy0LEkmoPqR9ZsBjxlWeriTs6CuPrE+o2LfXRZ7rI6Awx8QvckZbCShZgRGZoELUQ9ZQ==","signatures":[{"sig":"MEYCIQCqLsY3Mw8+MofHzguFnNy9i0pIvYMSv3epfZB64Seq6QIhALX+UJklveZWhrSIW9it0q0ptXCs4tccXc5/x88uLY+d","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":246438,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJf7wLGCRA9TVsSAnZWagAALMQP/3DWwmNTV3YajzucFkNQ\nlMryLpCcY5iryn410mL9wGipHNuciiXYd34ClLg68X8uKMkveEks86X1+Poh\nv3egMywXqCJ0jphLZJhM5DChsdHR9fz3bqvS/iZChR0bTB8F//QLBGHl4hnH\nNLlzvjALUziNCrlNn3vCUZ22CQJTxuOODDtsQy9NvJAPGIK9wOnsG5Q4JnUD\nvxJw+ajH5mtX/Aum3BTwqYtNjobI5bHTIBGB7fosVLF1ICxjJ9/8cbPi5Z6p\nPVsXOKqJ1o5Ln7a2mz/xxFgKpb7iIDVWEUyO/CSAIwJR3I1uAb/BNjEqHSmC\n8RQG8yZZC8Dy0mqtXb6DZRpr58uyEgxhc75DSRSB7BO+GLluS1O0S5qwcncj\n5t1bZe8QVVeMdiGALDxls+xBz7uxzkhjtiYXR0a1b5PdjOfftGlMwmHgmfuJ\nZ1MydYbZKryql96RV181A+m/MB8TaoB1LJg4edUU6rVRvFpni3uUWFeNrW0Y\n75l5MAUkj30BFFDb6wwHsWZZ5HjuID/SQvcsMHjXmH+MVUeNQtIm3vvYO0VJ\n41ETa6H1yU3dlVYoQ2f0H/SH4tKesuKlF1zfmhFRZ3qsnhKgr22Hrbn732Ee\nXGYsNsh8MCFslQ9ylcvn2ZeBNt+7Fdke5rEkRNG1k/AuxooT6KJxTjipxqKk\noNKN\r\n=bDLj\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (v1 native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [toReadableStream](#to-readable-stream)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Response Schema](#response-schema)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [6.x to 7.x changes (pre-release)](#6x-to-7x-changes-pre-release)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    throw new Error('Pool with this name already exists')\n  }\n  return POOLS[name] = (new ConnectionPool(config)).connect()\n}\n\nfunction closePool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    const pool = POOLS[name];\n    delete POOLS[name];\n    return pool.close()\n  }\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js v10+ or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8@^1`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### toReadableStream\n\nConvert request to a Node.js ReadableStream\n\n__Example__\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream()\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\nOR if you wanted to increase the highWaterMark of the read stream to buffer more rows in memory\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream({ highWaterMark: 100 })\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Response Schema\n\nAn object returned from a `sucessful` basic query would look like the following.\n```javascript\n{\n\trecordsets: [\n\t\t[\n\t\t\t{\n\t\t\t\tCOL1: \"some content\",\n\t\t\t\tCOL2: \"some more content\"\n\t\t\t}\n\t\t]\n\t],\n\trecordset: [\n\t\t{\n\t\t\tCOL1: \"some content\",\n\t\t\tCOL2: \"some more content\"\n\t\t}\n\t],\n\toutput: {},\n\trowsAffected: [1]\n}\n\n```\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested. \n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 6.x to 7.x changes (pre-release)\n\n- Upgraded tedious version to v8\n- Requests in stream mode that pipe into other streams no longer pass errors up the stream chain\n- tedious config option `trustServerCertificate` defaults to `false` if not supplied\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=10"},"gitHead":"76585f973dd8cad48836fe302f99f67d47ff6129","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^3.0.1","debug":"^4","tedious":"^9.2.3"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^8.1.3","standard":"^14.3.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.0.0-alpha.4_1609499334181_0.9571631635417146","host":"s3://npm-registry-packages"}},"7.0.0-beta.1":{"name":"mssql","version":"7.0.0-beta.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.0.0-beta.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"9b48397881a7ae1f968a1d2acf8a31daf0a28a94","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.0.0-beta.1.tgz","fileCount":38,"integrity":"sha512-iyFnNVWhjTnIy5nKCq+v/de8mr41TbNKRrulDXASuDqbjOlfLe6YefnXp+ZRPHJUU1rrjmtAnrUoN2y7dc2LUg==","signatures":[{"sig":"MEUCIAmHA54WwRaotHNAyVe89FAFhdsNsGKWqx4c7iROJLuVAiEA8kvqrzjuoqMlv8s76Lpl/QriGXyMUrHHR6ud5Zz4ksg=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":246817,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgAGR+CRA9TVsSAnZWagAAVkoQAITm+LfbW3n2fWqa+KS4\nGNaJAs3bdSxzF9wPD8z3t7vQefI3zbUFNiK2d2byTACjlvOUJDsvzyUKrTr/\nJ0p0aX0rii1MOR5SINOYy03N97xKxRNd347ezK4V1y9SZkkto+bjNTc4CEyz\ngXhGFf2M77cr2hog5O4IiGOzZt/ZLi68PErGBu1XZPcmFmB6bKL9Q3RNIMyT\nP9oOiqwJTTJOK12GNELGUBZuegXZ9pfT5BdLsX2pWWfjIkv7t3GGYDT8If+M\npzPVY9oJdzCGbxKbjTEj+sfB+hXysseyHjArX35IzKHnCuG/LzGV9iOuIUoR\n+Bdfl1S/z/F+lHSHtpzJsxWtorX0lmw/qNHSzmQ0dOQiIIxq1l3WlHiapQES\nNexwXWpvS5DRCrqWLkWGxNZQAboQFhrooHrfCMFmmrl8+j4OnXaowsYW66SN\nf3oBRStC6bmnJiYmAgYVaGmUSxwWigYqgZQbQ2gPyNV5xahoH1OIAtTf7Fyr\n+tXsAAicGgRgA5xewASbNjLt9LEAQ4FZd1gpfsOIrw3HbhON+y7tQhbVjJ6D\nelBnBNysliOUlJpSZToFvFDM/rP9T9bB5DdzEjORnhpmyxwZ+5H8ED5AbBMg\nYNCgJ8zHkSpP5Hkjkm/ClYKKFz0C3yJxjjlCI0m+SgCYBzsdWKNPsvxY+QII\nuQTD\r\n=IUb5\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (v2 native - Windows/Linux only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [toReadableStream](#toReadableStream)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Response Schema](#response-schema)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [6.x to 7.x changes (pre-release)](#6x-to-7x-changes-pre-release)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    throw new Error('Pool with this name already exists')\n  }\n  return POOLS[name] = (new ConnectionPool(config)).connect()\n}\n\nfunction closePool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    const pool = POOLS[name];\n    delete POOLS[name];\n    return pool.close()\n  }\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js v10+ or newer. Windows/Linux only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8@^2`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### toReadableStream\n\nConvert request to a Node.js ReadableStream\n\n__Example__\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream()\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\nOR if you wanted to increase the highWaterMark of the read stream to buffer more rows in memory\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream({ highWaterMark: 100 })\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Response Schema\n\nAn object returned from a `sucessful` basic query would look like the following.\n```javascript\n{\n\trecordsets: [\n\t\t[\n\t\t\t{\n\t\t\t\tCOL1: \"some content\",\n\t\t\t\tCOL2: \"some more content\"\n\t\t\t}\n\t\t]\n\t],\n\trecordset: [\n\t\t{\n\t\t\tCOL1: \"some content\",\n\t\t\tCOL2: \"some more content\"\n\t\t}\n\t],\n\toutput: {},\n\trowsAffected: [1]\n}\n\n```\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested. \n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 6.x to 7.x changes (pre-release)\n\n- Upgraded tedious version to v8\n- Requests in stream mode that pipe into other streams no longer pass errors up the stream chain\n- tedious config option `trustServerCertificate` defaults to `false` if not supplied\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=10"},"gitHead":"8d25da957af942d5ed5978e7361592ba7862d8f5","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^3.0.1","debug":"^4","tedious":"^9.2.3"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^8.1.3","standard":"^14.3.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.0.0-beta.1_1610638461747_0.74513936206969","host":"s3://npm-registry-packages"}},"7.0.0-beta.2":{"name":"mssql","version":"7.0.0-beta.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.0.0-beta.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"c51ddf49a3effb9a5e26e9f06c1b310892a5572c","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.0.0-beta.2.tgz","fileCount":37,"integrity":"sha512-7fOp+QzFf24ir/gGeSvyyGlQKfxZj6tx88vsk4UiQw/t/zpJ9PLjOBOoi6Ff+Tw/CZ1aJTa83MPm+CRYJ/UCQA==","signatures":[{"sig":"MEYCIQCdmbAg+1VzWAfODJ0Zgi7bet82yIkK6CgI8/tO/S769AIhAMCRR4Pa4bzFUwSxW9eTpjZF+624F1BW3dQqw6VoTANc","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":244796,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgA2U2CRA9TVsSAnZWagAAGHcP/A2eByCsC69e6DxO56pw\n4GVBO99YXQFWNjYi2pCYjVfafa2lKzYkkHF3aXS3WyO51zgAFU1T+en5vJGk\nlqKUCobAwUSJmVFlB2vgsDd5/qh1Rivn0cUm1wG8eK2yzQAVj6YmfvY7tlOY\nK1tvRH2YYrmkBVNrLTd7/faQYnmkrirCC4kR+XMBCNuG1q9gRxP7moMx9aPI\nt/uX++zODofgsnfolfatLTqaGD1XPGyqxs99l+tsT49HdandkvsrS9q8XfXu\ndbC6XrFbgviLft+n0QgqS8Dtx7T/SzfZiaU7DL3cj0nPOYAD55mDI1vLamCF\nr7dNi9t3ozNjHkc64PNxyhiNrZrT25jWVkETpP9MZOFXHqYALJCHj+au6xYQ\nJVSyaD7J1RVkswfPThl8B9kqW51ef62BPfzdyBx/xOjAo41+m8Pj7vUqWMKY\n7ntWxUcWsaeGFopeDeozg9qev563lie5YgtpI8JMwclWm/VvIbpzrOfDb7Sa\nFiPOV11d+Req00zGkig4Wpq0UWQ275LaF6LADjB/GsPR+UymGEBMVZiVSfTk\n5qWsgtGsGpGzVDxJCqm6LdaOa6JuSh3DfvH6s03z3BJ2P26lTTgO+AV1Opf4\nB5x5E+1bO8cMR3WJ8poC5soLVyTS2iov+rdNnL/txkm4y0DnA64plv4GxhkX\nM6T+\r\n=qjFv\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (v2 native - Windows/Linux only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [toReadableStream](#toReadableStream)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Response Schema](#response-schema)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [6.x to 7.x changes (pre-release)](#6x-to-7x-changes-pre-release)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    throw new Error('Pool with this name already exists')\n  }\n  return POOLS[name] = (new ConnectionPool(config)).connect()\n}\n\nfunction closePool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    const pool = POOLS[name];\n    delete POOLS[name];\n    return pool.close()\n  }\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js v10+ or newer. Windows/Linux only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8@^2`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### toReadableStream\n\nConvert request to a Node.js ReadableStream\n\n__Example__\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream()\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\nOR if you wanted to increase the highWaterMark of the read stream to buffer more rows in memory\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream({ highWaterMark: 100 })\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Response Schema\n\nAn object returned from a `sucessful` basic query would look like the following.\n```javascript\n{\n\trecordsets: [\n\t\t[\n\t\t\t{\n\t\t\t\tCOL1: \"some content\",\n\t\t\t\tCOL2: \"some more content\"\n\t\t\t}\n\t\t]\n\t],\n\trecordset: [\n\t\t{\n\t\t\tCOL1: \"some content\",\n\t\t\tCOL2: \"some more content\"\n\t\t}\n\t],\n\toutput: {},\n\trowsAffected: [1]\n}\n\n```\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested. \n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 6.x to 7.x changes (pre-release)\n\n- Upgraded tedious version to v8\n- Requests in stream mode that pipe into other streams no longer pass errors up the stream chain\n- tedious config option `trustServerCertificate` defaults to `false` if not supplied\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=10"},"gitHead":"526aa806a310543591004a470375bab916b99e40","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^3.0.1","debug":"^4","tedious":"^9.2.3"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^8.1.3","standard":"^14.3.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.0.0-beta.2_1610835253521_0.3599958074996139","host":"s3://npm-registry-packages"}},"7.0.0-beta.3":{"name":"mssql","version":"7.0.0-beta.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.0.0-beta.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"74e4c2b5ce7e8633067c86c8b2fc714b2ea4d98f","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.0.0-beta.3.tgz","fileCount":37,"integrity":"sha512-Jn/q64Dg2UjbNTqsBwCHFdMjxs4xIVqgWQ1hmDKvBR0T8ebHfPnGTzfNl4oE/VwqP1m0As+v2CMjyqOi9WneuQ==","signatures":[{"sig":"MEUCIDl7M+FZz1X7ixRSVjWS9W22vhnGSX5SZ6EGIDUIYYZLAiEAiHZIAR+Tpmz5vPfYkPYNrgYL0gRb6EvDa/zmAOBL9CY=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":249704,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgDeOpCRA9TVsSAnZWagAAN4wQAKLPslWoTdFR5JMReC7z\n7Yr52rqPL7PZpZV8TKPgsYulk2CpUJnWkcVe7JJYd+w/LVLKfK4NWfpOftO3\ny4YQ7/mrXFiD/2GOaW+T5CVtn9CCPSwLudotYJ4DYEImCKs+ZoRbNJ/rqe8J\nRderiTd5HgIYlFAsoi0BSWE/fTHzbYoSIxy48SmauDEu+v4bduZ9QiFIKQ3l\nRNhAyYdKI5J5N12p7Z3jrPuzDbd5l2GUVfvFm1QAJyK8brlfCmYHD7lTtRoQ\nhCuD5apz6+uQIMsQdhXSEib5dAx6APEz5vX9CO57amdlFRKAepraRRUuxAHC\n43xjSTjZAkKzmH9vzh20m1YQuh1EAEj9d79SwDM03nTbtbLIXMfFUX2Y1EjK\ny6euWwYagXIjpnvoKtAIxP2/+dAD5oOBfcuF0Umna2wzCwvYYxqRKud+UVOY\nU3mXXRWYIQCBYD6PBIdiOsyBeYNtY52+G2avacUC8Hk/V3Dmf9700exBmqqe\nyAZU532csakEiUIZNDS2ZWVxnW2l9VHrp4gsZ0bI5Uii5JwItfTYwSfKW2dN\nuCV+90xczVEhipX6PM7gzCAptf3qSm9NH5Lp5msWbOYnMeMKDPGK1KajkQkY\n2F2+/21Hf/BrCmoDstw3mz+meK9MUpGczAc7JIvNOXUeq3Vc6TRB5HAVKV12\nleMF\r\n=DUGc\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"1fb0b4d9067512add666100b95acd24ccbf780a4","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^3.0.1","debug":"^4","tedious":"^9.2.3","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^8.1.3","standard":"^14.3.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.0.0-beta.3_1611522984322_0.06438811599790739","host":"s3://npm-registry-packages"}},"7.0.0-beta.4":{"name":"mssql","version":"7.0.0-beta.4","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.0.0-beta.4","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"370db9bc223c7f6816bfa1adb38d9156531146a7","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.0.0-beta.4.tgz","fileCount":37,"integrity":"sha512-kWx2PLkj/VvaK0g5FLzpZjldsi+PDNzAkHxLtsnLxwgq2nKALsYnXMGcU8g1FaRUky+kauGUCpbKWD3NUIytOw==","signatures":[{"sig":"MEQCIDUQu+xzGvfIeRn8+JHBL2DQTKrWJrcka2u3oauqdHZ9AiAaUigA3FBFCpFMepe4OWun/cKKGTKL6N0MrbEoXQfEnw==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":253072,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgeKxrCRA9TVsSAnZWagAAJwEP/26dpnLXo7lfkTHtLi4L\nGsePbxVIL8IltrnzqYtvq4FpNbvXJo1t+gcGFygmlV6/SDtx3AfWSdgpsq0W\nE33HDk98zD/P/wPJk+MqxDEqBmyyLUnIB8RbomxM0ZJmREPJ57+jT2ZNBQSM\nSm3oxlkX0SToJz78eQ/KZTezDqltHqZyHf8NerQJKoOAbjGKpy8B7L5vW8O5\nDGPZ8KqS47NcR3/aRwYZZK+YEugCPe5DQZJGAsD3chQYTipnU+MCT9xtlgiZ\nKO6gaxr44yvpXIDGbK8oA6sFFlqPrEgTNdRmdJ5iK9DRfVnDJO4JV1as7TkV\nmWjfQmfBsxvzwjaPrL3En2Y8uO1jkCz/A+G9wTe0qN6KyNQQwGNUWp15hsvY\nWghaEiq7xRsf/H6qBrhhMNVEvGhJWhxjlF9fWDSMkeyoVOjJaumJkvtN0FkV\n3caeHVvnm2u5I+TCu7nRzlRsf4tAJhVs3G5pKy7AmVsY5CZLN9pKJoql/ga6\n2FuL+cukZTy59UwZrLdWclAM50Dv/bViZWA7L4i7sw1liOL0CPehflqDznHF\nFJG7g4kEJwHLLqxJOe54bRc5sbci/DOkhmECQn7/GEsxgdaXYaoO0zczGKHH\nvc6oYZELNaDH1BtYTwigeGuMuXp8TVr/vy1V4H/gJwgNKkPaKgpXhp92qqss\nYDKJ\r\n=ryKN\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (v2 native - Windows/Linux only)\n\n## Installation\n\n    npm install mssql\n\n## Short Example: Use Connect String\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Longer Example: Connect via Config Object\n\nAssuming you have set the appropriate environment variables, you can construct a config object as follows:\n\n```javascript\nconst sql = require('mssql')\nconst sqlConfig = {\n  user: process.env.DB_USER,\n  password: process.env.DB_PWD,\n  database: process.env.DB_NAME,\n  server: 'localhost',\n  pool: {\n    max: 10,\n    min: 0,\n    idleTimeoutMillis: 30000\n  },\n  options: {\n    encrypt: true, // for azure\n    trustServerCertificate: false // change to true for local dev / self-signed certs\n  }\n}\n\nasync () => {\n try {\n  // make sure that any items are correctly URL encoded in the connection string\n  await sql.connect(sqlConfig)\n  const result = await sql.query`select * from mytable where id = ${value}`\n  console.dir(result)\n } catch (err) {\n  // ... error checks\n }\n}\n```\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [toReadableStream](#toReadableStream)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Response Schema](#response-schema)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [6.x to 7.x changes (pre-release)](#6x-to-7x-changes-pre-release)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('rowsaffected', rowCount => {\n        // Emitted for each `INSERT`, `UPDATE` or `DELETE` statement\n        // Requires NOCOUNT to be OFF (default)\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    throw new Error('Pool with this name already exists')\n  }\n  return POOLS[name] = (new ConnectionPool(config)).connect()\n}\n\nfunction closePool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    const pool = POOLS[name];\n    delete POOLS[name];\n    return pool.close()\n  }\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n- **options.authentication** - An object with authentication settings, according to the [Tedious Documentation](https://tediousjs.github.io/tedious/api-connection.html). Passing this object will override `options.user`, `options.password`, `options.domain` settings.\n- **options.authentication.type** - Type of the authentication method, valid types are `default`, `ntlm`, `azure-active-directory-password`, `azure-active-directory-access-token`, `azure-active-directory-msi-vm`, or `azure-active-directory-msi-app-service`\n- **options.authentication.options** - Options of the authentication required by the `tedious` driver, depends on `options.authentication.type`. For more details, check [Tedious Authentication Interfaces](https://github.com/tediousjs/tedious/blob/master/src/connection.ts#L237)\n\n\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js v10+ or newer. Windows/Linux only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8@^2`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### toReadableStream\n\nConvert request to a Node.js ReadableStream\n\n__Example__\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream()\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\nOR if you wanted to increase the highWaterMark of the read stream to buffer more rows in memory\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream({ highWaterMark: 100 })\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Response Schema\n\nAn object returned from a `sucessful` basic query would look like the following.\n```javascript\n{\n\trecordsets: [\n\t\t[\n\t\t\t{\n\t\t\t\tCOL1: \"some content\",\n\t\t\t\tCOL2: \"some more content\"\n\t\t\t}\n\t\t]\n\t],\n\trecordset: [\n\t\t{\n\t\t\tCOL1: \"some content\",\n\t\t\tCOL2: \"some more content\"\n\t\t}\n\t],\n\toutput: {},\n\trowsAffected: [1]\n}\n\n```\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\nIn addition to the rowsAffected attribute on the done event, each statement will emit the number of affected rows as it is completed.\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('rowsaffected', rowCount => {\n    console.log(rowCount)\n})\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested. \n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n## 6.x to 7.x changes (pre-release)\n\n- Upgraded tedious version to v8\n- Requests in stream mode that pipe into other streams no longer pass errors up the stream chain\n- tedious config option `trustServerCertificate` defaults to `false` if not supplied\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=10"},"gitHead":"d5a1f462990ad7673c52328b6400b024cb21be8e","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^3.0.1","debug":"^4","tedious":"^11.0.5","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^8.3.2","standard":"^16.0.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.0.0-beta.4_1618521195227_0.9514833005334564","host":"s3://npm-registry-packages"}},"7.0.0-beta.5":{"name":"mssql","version":"7.0.0-beta.5","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.0.0-beta.5","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"c07be9abd42a025c3a318cce38523bf3d84857c3","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.0.0-beta.5.tgz","fileCount":37,"integrity":"sha512-LfvKm/vcaQNA4w/ARbFCFraFmri0arwOgcSRkyajIVIrfW7Yd2zUZ2w+c8Ee7k3k5BeD6c0D3G6gdfW9aW0fUg==","signatures":[{"sig":"MEYCIQDKkn+FkqaiDlIX+9VwZOyoTrsnvZwGfrm4Y6jDVNqOFwIhAISRh9R1KJS0A9l0aKj7zoSKs7ZYUwmUj+6OgXTr7nhb","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":253279,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgeK+hCRA9TVsSAnZWagAAPGsQAIbcc2AFZBRhkMLOcWPJ\npJ2rQRyd9HRiTKeU5TPszRxj5x/8rQr0Bcz+Abnllh7xu+AbjX3f1iCzlHSe\njfz/pJFfjCJf0JxZp/yFkHeR/Tvu2PhzESQW+wYPlMeh7zhIZ4k3CZXP4UNW\nAeukB7K2tALlpP47L3/7ARLt8ooDeYggRDpNNGI1Z6pyjcJYw1ucUn3Q9hFc\n3V6N5jhFbgxmMFmin2r+T651G+V8GHKS8NE9/opjqgeoCNTbWyd8jZxvURod\noYOgPfxrXE9nJhHWu7XfLNKE/2k3QmGfj0Zr0TX3pc7ltTNwXEy4Jd9SLBa4\nG1m7YuYXjE07opwpK6KMiWW77jx7ncx7IJGg8Puu1O1vCTwJ4mIk0Lf3F6sY\nlc9ihwIGsfpkpw3JcXcx3vOoI6XpymR7uZeaZmUrnyRqdx1oh6mQQMabWFhf\nbvH2+ukaKLHyp9c+uDeMgWderGN39QVY2Fg3aA9H0L9YE8WClg9oU8QIayvA\n0aglf9LPv5oQQR5Sm4ULHtVjaoIDK0MeHlHXOO0pzsUx6FFgVMeDJ5rex978\nZIMNvIihZ2bO4cMAln7VQNygYGdrhAgwOmmwY/spARtyeoWRAbj2U/cjfmaG\nifBBxUwrLcQVEkG0/68y6JkwZ2S0tyjX9PZ5zM7tORxide7mjgzVXDkIAW45\nNlie\r\n=V3PJ\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (v2 native - Windows/Linux only)\n\n## Installation\n\n    npm install mssql\n\n## Short Example: Use Connect String\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Longer Example: Connect via Config Object\n\nAssuming you have set the appropriate environment variables, you can construct a config object as follows:\n\n```javascript\nconst sql = require('mssql')\nconst sqlConfig = {\n  user: process.env.DB_USER,\n  password: process.env.DB_PWD,\n  database: process.env.DB_NAME,\n  server: 'localhost',\n  pool: {\n    max: 10,\n    min: 0,\n    idleTimeoutMillis: 30000\n  },\n  options: {\n    encrypt: true, // for azure\n    trustServerCertificate: false // change to true for local dev / self-signed certs\n  }\n}\n\nasync () => {\n try {\n  // make sure that any items are correctly URL encoded in the connection string\n  await sql.connect(sqlConfig)\n  const result = await sql.query`select * from mytable where id = ${value}`\n  console.dir(result)\n } catch (err) {\n  // ... error checks\n }\n}\n```\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [toReadableStream](#toReadableStream)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Response Schema](#response-schema)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [6.x to 7.x changes (pre-release)](#6x-to-7x-changes-pre-release)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('rowsaffected', rowCount => {\n        // Emitted for each `INSERT`, `UPDATE` or `DELETE` statement\n        // Requires NOCOUNT to be OFF (default)\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    throw new Error('Pool with this name already exists')\n  }\n  return POOLS[name] = (new ConnectionPool(config)).connect()\n}\n\nfunction closePool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    const pool = POOLS[name];\n    delete POOLS[name];\n    return pool.close()\n  }\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n- **options.authentication** - An object with authentication settings, according to the [Tedious Documentation](https://tediousjs.github.io/tedious/api-connection.html). Passing this object will override `options.user`, `options.password`, `options.domain` settings.\n- **options.authentication.type** - Type of the authentication method, valid types are `default`, `ntlm`, `azure-active-directory-password`, `azure-active-directory-access-token`, `azure-active-directory-msi-vm`, or `azure-active-directory-msi-app-service`\n- **options.authentication.options** - Options of the authentication required by the `tedious` driver, depends on `options.authentication.type`. For more details, check [Tedious Authentication Interfaces](https://github.com/tediousjs/tedious/blob/master/src/connection.ts#L237)\n\n\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js v10+ or newer. Windows/Linux only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8@^2`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### toReadableStream\n\nConvert request to a Node.js ReadableStream\n\n__Example__\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream()\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\nOR if you wanted to increase the highWaterMark of the read stream to buffer more rows in memory\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream({ highWaterMark: 100 })\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Response Schema\n\nAn object returned from a `sucessful` basic query would look like the following.\n```javascript\n{\n\trecordsets: [\n\t\t[\n\t\t\t{\n\t\t\t\tCOL1: \"some content\",\n\t\t\t\tCOL2: \"some more content\"\n\t\t\t}\n\t\t]\n\t],\n\trecordset: [\n\t\t{\n\t\t\tCOL1: \"some content\",\n\t\t\tCOL2: \"some more content\"\n\t\t}\n\t],\n\toutput: {},\n\trowsAffected: [1]\n}\n\n```\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\nIn addition to the rowsAffected attribute on the done event, each statement will emit the number of affected rows as it is completed.\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('rowsaffected', rowCount => {\n    console.log(rowCount)\n})\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested. \n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n## 6.x to 7.x changes (pre-release)\n\n- Upgraded tedious version to v8\n- Requests in stream mode that pipe into other streams no longer pass errors up the stream chain\n- tedious config option `trustServerCertificate` defaults to `false` if not supplied\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=10"},"gitHead":"43e44d1f94ed7671c30701427db5fda235314401","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4","tedious":"^11.0.5","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^8.3.2","standard":"^16.0.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.0.0-beta.5_1618522016917_0.19509669408181463","host":"s3://npm-registry-packages"}},"7.0.0":{"name":"mssql","version":"7.0.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.0.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"73f30b95d7a6610bfa8069297bacab078d4be2e0","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.0.0.tgz","fileCount":38,"integrity":"sha512-/6IXQUucUw4wpWXq5eO56P17NQkKbY6sak8NAUrofY5whWkGg0VCxpPQjq8qiuV2hGPUt6+Yo/5La0o4SpatZA==","signatures":[{"sig":"MEQCIG3iQ0H//eRCei7phGBNdse7gjXJjDQPY40CwiUZ6cLUAiAP6PR01rXzsL3aEQdcQuO+D5HegDUCrxAI8+j5q104eQ==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":257698,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJglCfLCRA9TVsSAnZWagAAovsP+QAh9rflXtkVZztjCdbK\nVDY3PNjtVN+M8+ZG96isOgk+39Spv+2rjIFR055foylP8grTR4mnkAZy7Gz4\nBylWagsT2dcnyeSPnusD72Y4pV+ZqF4fTWmfTJ8drmU3PVWG9y1FY+6ISvqp\n2t+sE5e+vdjwqe1AiNIYKEWcqziLOXis5+YulrwH8jK1dMxWnodEYDnK82ws\nMyiiK52qQER5vuhPzhMuJmtpG+wHPTxdSJQoNTFHkMAnxb88oybS+QsJoEQF\n2ntGKLIMKVccxfAm+Qgk4SNTPh4KYpZRgsKOxT0FemoT+4kgeUqDxCAZfTJ6\n7Y9JlytLoefouZbNrDb754/Hm+M4mra6uu3uyoHb+asmDD8UlU62JcXJzF5j\ndAPIE7SgK1MGgDbsY9/jmiz8go/tKyAA2asPJDqWd/YPmC0qDdw0FZrLe1ZZ\nP/VK1nT4W6m3anv4Yztnf0zJVB8VOWlRUsO+6Hi1dSeIrQ+GYfu5FboXVqMA\nM2YPYsqERBj75obOt2DnzE23g5mMtjYwxrPW+3aBrvW5IbqOJ1k7OMVzcTf9\nX0TGtcjNE7P5Hl+ioVUSAFea5hWEMQSeL1eI2tnE8GUtTsxfz5abcR32Qj6U\n9ZlU0s5/L/LWjYtf7v+JV9S3mw2/SrmhXW0efbOcH8ujTpHPK8oPNoCRa74l\nYgJ3\r\n=mR0O\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"4863573535a2ecd9a45b71bda102313f0c5a8e67","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4","tedious":"^11.0.7","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^8.3.2","standard":"^16.0.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.0.0_1620322250453_0.06646149842236437","host":"s3://npm-registry-packages"}},"5.1.5":{"name":"mssql","version":"5.1.5","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@5.1.5","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"19c587bf14ba7cb00bd487a1232f21f4ed364f69","tarball":"https://registry.npmjs.org/mssql/-/mssql-5.1.5.tgz","fileCount":19,"integrity":"sha512-/OdMuZL4PUFwoPd+bnfmxeTwmDZVvHt05LSMOLkMUX8hD1sX092Ag3gTgKmiQwB3K6EkmTxxh4Mgo/M4dqxP6Q==","signatures":[{"sig":"MEYCIQCrCBK2+7Yyq/GCslMYoVl5rSaYl42G4H1oLgBl3AbjIwIhALE7OefSOi7jzGp6L4Tw9Ybs4LPU0RSb4OLh0a8/qtGV","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":203210,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgnXNYCRA9TVsSAnZWagAASoQP/ib7VnVncNNeNecpRbCV\nb5FOBdCPmmHlzQDnb/M9ONIVtQJ2k7T7vb3TZHiorTNJrHA0KxaLwtc3UmZo\nqVz0ehxIw77ydElyPdmMhCLfBPebG08/DC4ww34BbnRX8LGVSIYEIHCttxCy\nzl2Z5xOY6qyxsQQb/MFWeG/+Dx0a8pDkA3q6BW0W9KXNWUBaaF1+vPAupHv7\nGQVuByvkuCMF9wER63UELyTOiBXJ74TbTPTIEZ0ZG3o2XaFnbUh5ZcRYAABP\nYrd68rlorAPmV7MvlqOdAGyI4d/XaBuZw6McI5eJ83SP84/E39tShGt27qnB\nlc0GL+Fqyxn26LVNK8Aqiss/zEpmd8dYorohN24vQzFdThXrn2sAbcUKSIt6\nz9+zS3ngSK/4X4SHPTxeOjanayC1GxpdogXM8IK/OLSoUbPPd7XLW4inlHmD\nerlY6onwWLzG4cX72EJKFLR5FpdVF6R6YbUcsa8ymyZbJf9H2AiRxlZ6CSRX\nI4g2TEy7rLpyyHW9lPZkO7aXBWy3HfVuh/u5tbW8G7udwQSkYnIAK90We4RB\nTmCnUjSEmNFHbyApLvB1+FCtVTeCWPeJ4qFi08JTZtC2/SUzjEhsbctVNEq+\nrceGylwJzXXy5Elv43YQCtZ4qXEr/d0E/01YT9aEkDOuW9e3KkyGLSymW3L4\nyj93\r\n=UG0/\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"921fc4aab0b263ae325f69310fa1f5ad1f93742c","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"debug":"^3.2.7","tedious":"^4.2.0","generic-pool":"^3.7.2"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^5.2.0","standard":"^11.0.1"},"_npmOperationalInternal":{"tmp":"tmp/mssql_5.1.5_1620931416350_0.38265170389816894","host":"s3://npm-registry-packages"}},"6.3.2":{"name":"mssql","version":"6.3.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.3.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"116c1ab17ae55b1fac67dc453af54c06febe855f","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.3.2.tgz","fileCount":37,"integrity":"sha512-84++SB86VlVm5VrUU3g1fOOjU29mqnF6In2Gz+sJCxnuG5c3J9ItaladE1NayO+D8ZuKtxbkGATVYZv2MsXMIA==","signatures":[{"sig":"MEUCIQC5L3YpRmctbOqhHIgB7kWrQ3NS0lo+F3o/wCLEbGYKrgIgfuWwevFPVtShUZxy34HbIJ792AmY8qAvZycDPhDgM5Q=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":240576,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgnXQ4CRA9TVsSAnZWagAASb0P/A119+u0UuOU5UnbLo5/\nK7JOYHXh5DQmUyA6KDfloRzxLNigpVF9hzHD92J7dHQ3YA5VWk/GeuG6lgOl\nTnDmQtbC/AqRTf6zNJQpnkq+qhnZnecPRCBlmYIjwpod5M2LjQywDEUp+Dwo\nAWET8htGggC38ILwxXH6ZGyU7N84h9txJ40VWei0C07Tcopd9g37oewC3GTh\nO9z/n4m9UP1pmGxIqTL7A5Sm2WKsh/c9uKZZyCxCYJdHLAvSv7pF857Fmf72\nY+Vq6MUCG7692d0jjQw16dS9frC24nXwFUiQ3X/1XWwO+S0sunhFbj8rK9zL\nExUo2djNjcxzGjV2N6x1OfTWALAwqDXk8YKPIlgzgMQTiIB85B0WWRR7KxV2\nKUC7b0OwGTClMuoEJFVV7ZjGiimBwVo+UQP3vZSJrRNVWgtdkMChC6shV1DC\n+HPOCIU4DrvDACUqa402WBziPX739Xs7wkqYh3konlUgC/Mg98TdIwCTCelx\nU2azAbqD5Elf2tfkrG1qq47uCocBJpcH4OrJLhioD4F6tssTqH/OaVvbhQm6\nQ8Eir4Oc+KEYe4UHQokGHLFOUcnLDRl8JTzuB0ENq4UJb/dBqO8+eL5kmVgf\n+5uZZ6+qA5vCngOOpmOQXTOM23G7uu+olU46Ac3UcMxigXVIF733KvbCN+zC\n0E8w\r\n=EVFC\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (v1 native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    throw new Error('Pool with this name already exists')\n  }\n  return POOLS[name] = (new ConnectionPool(config)).connect()\n}\n\nfunction closePool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    const pool = POOLS[name];\n    delete POOLS[name];\n    return pool.close()\n  }\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js v10+ or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8@^1`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested. \n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"6fe5d50a177f4056ddaf2e8c2e8b2998c54eaf3c","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"tarn":"^1.1.5","debug":"^4.3.1","tedious":"^6.7.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^6.2.3","standard":"^14.3.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.3.2_1620931640037_0.049441155104189116","host":"s3://npm-registry-packages"}},"7.1.0":{"name":"mssql","version":"7.1.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.1.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"8281297a4d01198506ce22abd49c68cc80dd7605","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.1.0.tgz","fileCount":37,"integrity":"sha512-Nx+7RQrK7GHhgvKdBnfmt/EqnTUP3bWyi5nxsDiaD6kd5kJSUKbsfVqi3Vy2j0GWH51zHj89LlG7P4w5ZBe5Fw==","signatures":[{"sig":"MEQCIDutaJn32+717v5yobVnMXDVcsPhzqxrGpRq8F7mlDFiAiAGXXzpzWHFbt4bPHl6udM8/+woBbbK8sg7Ma8DRBt93Q==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":254449,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgnXTSCRA9TVsSAnZWagAAfCwP/A9NAnfrS4624r7nBMJE\n8upW6Ogz58g5NT1Gmo8p//cb7ITKRT35zXtWq5cmXearx25IZvkorm55u5z3\ns70A8q02sElcs6XhmxiY20hTZvzJrEuBJOzlTDlhPTXIHgxjbU6j/lvMNzGB\nNtfk2m6nSoBHUrSqHcrNViJvLjtmTxaaunbM+uc7XvS9SwVScpbIxUP6mMoe\nPXtl8G+BlmX9OyDr0yXXWLR+BRTTpJENLTGdiEN53xqSy4rvbur88EbyQO9W\nYC8aBfjUbRBO0jr6f3xpTGz2baAAkYVKnLFjgdYMNqB0/CTw33cMMPkeJ6kC\ndo8exmW8A7SqaKIDn5z2uV4pywnb/t57Jc34jMb4WQG6SZ6LipiPmbonhCQD\nRap9dW+03et/2EiJujPYoHuson+/BWID2wGYY0EOhFHJmXLsuSJ3stJpZjIf\ncpxQr2Tqb5HM9vyOZLKZV2E26m3PR7GRTZfH+pz0BNZkeXSRdrVwyAcDFPXx\nsIObJ4DCerxWpAhC5x+T2EovNimd8FGb34oK7BVbE7yXX8LfHBgTp5i9tx66\n0iYc8BP2/8oNI8Hq8TuBCx8goz4GVwwADFXliWbYLN2kjDUwzByxs4kyZcpN\neGqLkaMOBjQofFjbPzE/XSO3mbhWKfTGcV+Dz+8XTNHiUPAW8mKCb9MGwIng\nba7y\r\n=UE6/\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"fcb6e797108045c22f52d166077c12296818a0cf","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4","tedious":"^11.0.7","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^8.3.2","standard":"^16.0.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.1.0_1620931793830_0.536881283699852","host":"s3://npm-registry-packages"}},"7.1.1":{"name":"mssql","version":"7.1.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.1.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"cf0a9b3592e767225055c563956b1d4cf18305e3","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.1.1.tgz","fileCount":38,"integrity":"sha512-DBAjde1nct2VhH3FMW5h8TuNc7mr1okq+lb0pEuHB8sTi2KaTTdvkoCMT9XeUgTADKqzWO6nEPLzv6Ohe3/urQ==","signatures":[{"sig":"MEYCIQCfN04UIwftikSJV7dLNUTvRoroAQycOr8RXNtRZctt9wIhAMTpLoEABSUREfYiPmNHzr/IvQH6Dnvz/fOzbOdZKWFI","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":257229,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgwJGZCRA9TVsSAnZWagAANyQP/3b2pZiaWCFUJdheDXMc\nQHMFYNIOtoLvmutz0Ez77AzXeDMSpGPWNtCqtXn63pqDt2wa73APcg70b3XF\nch8EsQjDuM7+bT+aAWg5ab2VQAWculVxEko9JHxawbqS25jrfqUdJrZBd9jI\nK4ECt9JLKLdZJSlcnT37/oQshudbVSVk0/GZO+fT0ajVf4EhVXh2PxksQI5y\nNqU+mt7oYG1XLaacwQVru/WByGpvmqqcb+an453PObYyNq6Z8SMMDPSykrWp\nYEwPWSeN2FUhSSAyPAIdOZR2vQD5OxJjl3i7Qv/80a41slOnSnurILFY01ZJ\ng8NoMu9OY1tE9+uEzCa2mkRgi0f9slxL81g+9AC8gxH6HDq7hUUuJpr2p+mi\nxFsNTcltVaBLm0T9dGKhP3nSA3DCHNEIvc2uy/+BWe8sUju2eEGJk28lGOlV\nN6lF371hTIo23EyjDk3sQTDjTPL4+4GDFPreu90w5krrqpmfJbTkDpBNBS+4\n6DRRd94vw0yj5GKcVN2K+ct0WUAHErxmfkQET9CluOceAC5gPq2oqlBsb3tI\nSO3KjIede15YcIO9jK2fPX+KJlfghFKlB3Rp3XN7aJhOJZhxe5PsJRv/gNTi\neQNosew0BOM6GvnjqjSDBJSwoF+9pbHgTOiRNBSfbkzC9i+Em+6L5dbHXRw1\n9n4g\r\n=MGWY\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"c19bd8163b4ac0a0339a350ead170b135d9efd7a","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4","tedious":"^11.0.7","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^8.3.2","standard":"^16.0.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.1.1_1623232921069_0.7896550101514983","host":"s3://npm-registry-packages"}},"7.1.2":{"name":"mssql","version":"7.1.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.1.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"35432ffb1e1f11b7c65d9d8c4db2f19262394d26","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.1.2.tgz","fileCount":38,"integrity":"sha512-uKVhGcUmz5oJHe9zIbAJsmtOmDbO9rcob9I5ddD9Woknk7skBkDEtOwZOYW3gGfsi7CJcQX2P5FoehlxxpeVpg==","signatures":[{"sig":"MEUCIQC+saa40WhEUdOSUc33NWZ5QL/VZ6DqpY0GF1YevVnFHQIgOkb9QikWiUCrbdr2GUjDCaCNxbxXLh9pWfrY8C7ZwqE=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":257229,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgwx3cCRA9TVsSAnZWagAAGRIQAJDI/rH5ZjbkVfly6vbS\nmT+cPSg64wcwp8er1rShA7bQ4gsi+1nN1rn+qoYqwi1UNbyGVpVW3CNk0jMb\nqdk7Ypjy3WBKhF1xJ8hT0saRhrWL8ejn7+FEeqLJCoHNRIUNGsmc9u02o38k\nq8zhEROIw/CAzMde1sLMrKh8IKbdUDmiH4vBOk+TMpNuCSAwkeadO6YAvkpr\nK5toGrd0Cu6mhRLOc9My+2xxn9wfz4bwv4mX5+U3PM7yeaJrv1jC1scJu28P\ntsTxGShpaoGI3HgcmZTTxRoLWHpfy1XJ3yq6PVwT/KnobrcRY/Vh9SQqvKL6\n5kDKTKBMw9UFY3UD0viy/lVeBWYQZ4l11tuJHQ7FuOkEMXohB09a7UF4LYvh\nZHA865F3hc9ixZWjbvbR78s0akQ66546UAJlzh0+Q3Q73agXQ396YHFWmLbU\ne0ic8dnaEk1zx53PissLJiCjq/L4kaEoAEPnXpqTNT8ymh10RayCqbr7tKCS\nHjcfeWvqZfmVcEqiy8uBLz5/riCKtYma/wc/xeD98g+83/+mcmNHVlF61eK9\nmqIXQ+Nj08oMcdk3y+PcqVkI09EDSbNTqbQAWuQB3Q5CwotgAsWVZ3W5UbEv\nGFItX81+C5vzvz5DJX7Qqgtha6MgHX3reZfRae/zXPOwsofMn/YoWqmR51/x\nr5eL\r\n=tgd+\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"168f599409a3eba79ae3bdb2bc0854af80e27591","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4","tedious":"^11.0.7","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^8.3.2","standard":"^16.0.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.1.2_1623399900148_0.8830622327594162","host":"s3://npm-registry-packages"}},"7.1.3":{"name":"mssql","version":"7.1.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.1.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"568504640a3b18412332bbcedfb6de9fa5d2b11f","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.1.3.tgz","fileCount":38,"integrity":"sha512-VCtGfJhb9ik5RV3PZQS9jG9I261cghwyWG4YZWn4+13k377sclkCx7/loctCnMNk1EYJFIIAWYCsk1GYwF1Yag==","signatures":[{"sig":"MEYCIQCIM3cVjtoRzK0LIJYLMVb0eaRJU8Fm4CpG3nVqiB/8hQIhANjcNGQL6Y1oXbXzgs5RRob2Ct9IqsGPn1j8XXnoytNs","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":257412,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJgwx8yCRA9TVsSAnZWagAAgJcP/R9TVcY4oVfYPnpwDeEy\ncKFaa0h4zMiIFrCTuc7BSapdIW91Q8f+RpfOf/q606UWqB8VcIC8r2qTZ8wX\npt8SW2lsqUE/VwCNvqM/IAQTer6DNZ2xnu+K41zYr+JRZuUp2zYjBKdE49qb\nBAL78Ry7qAFOi2SYOq1yAZOcibJuJyZ4DoDegYmbp5pW/6hOqGRI0nsEX4FX\nXQxJZIBDOnTUOlVOyjFntFk0PEVUISkiSIO3lmmwzNkXYdzWwARwd8NZE5PU\nwCT5+THGUkZ4ITAHxQeHQW912/7DYYao2pI84xgDLfJoybU3gmodEy+dy/gz\nyVPRSJOARJhFev9N7gysMfmCizZXaARVBGdP/VFKFh+ADID85ucv+JvxceVi\n+OBdZJwMXIQYk/OLKQ+VFa2hNKPEQj6MytNMEXee7gghVfQUbuGi+9GWuxS3\nrLQMeHCJeqYIvKwiwPEGe1pm0UJpVjH1n+4Elz3RqJBc5zwabDWB5IFzT8bQ\ngfqEJzfDqKCOk2oVceZFEFojlbzmR6YFooZ935TYFEIHOV9a24+deVQ/VdCf\nErwdj/PMyyqUO7KETowuhVXH/CkOEBFv0BwbDO90lwNocAbMzKqQKXTzJkZ1\ncoZS1xoliH7BPzWgAPhrDAeHkPOera++Aekah8+8PMiU1ipy4nZh7TooO3r7\nOEwB\r\n=MPj1\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"556ff0e680b3c1762932dbb560eed5466c853137","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.4.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4","tedious":"^11.0.7","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^8.3.2","standard":"^16.0.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.1.3_1623400242213_0.27786389053763316","host":"s3://npm-registry-packages"}},"7.2.0":{"name":"mssql","version":"7.2.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.2.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"701bea8d90d535a3905286b96129bcde9700c722","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.2.0.tgz","fileCount":37,"integrity":"sha512-nlFq6UmYmJTT6pSo0x2NCigXuOi42WM6d6A8By3ZxMRznY9wVw7KQ9IfRhC72KaRj4G9oACHeCHVCucoSwcFFg==","signatures":[{"sig":"MEUCIQC1tKODLSTlXZKtw6Bw0kMcrSWOhh33kzaLs1TT8eYz6gIgF2nitxd7GZ1JNKMKXG/V2n6LOCD37NFkVoeHb6REoeU=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":258789,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhAlo9CRA9TVsSAnZWagAAyhoQAKLLG3DgyDvjFR4wkX+F\nqswR7EzXryhnKieFl2dpQEDsBHGBrDXHQREskP99ZFpfOrH+1Cru/a3Xnw5X\nUQ2XQzQm7jsEQQag3DJJRxTxX20/kxs4hDaPPPz1N2VRI4zLiOOV84yR6IDL\nqtJ15NL+xxAgdJTCIMA8iySNFkyhO8IFKYzksrSjCKW5YHfJSTDOlRImYKhm\nWU8uDml3zdXGUyhHi3c/UN5id1zyy5uqLQANPk7fpb8eTnV11rCesoNZiKDK\n6F69rfM6PfcXQvmiDyF+CIWXRpHIXXqPRdq6qPfYhqn3R08SgYR3ImHTdy1T\nxj1EJ0qIR7Qs/2yPZDI4Puc/U1oTNeTYCVpEwdVuDiGZQxskfTLhEhsjKNYU\nlcDcfKgEzMswTtJoIXQG58bmzqs9FD0BkRoO6+n+cm2Qc6+xeVHcLdDXcoot\nSzVxlNakadfALW6WAK1anfxx8FrVlvIIStx/6SpQtLfC+4rs7r0ShLzBtAHv\n7IGmOFC5PbAxUWRww4SG19pKYqAGISWBHzdmr7qmHoWric64WkGb03jBkgG5\nWkDRvvbCiXuyKFZR9ygeDqagPG0erKSYUGa4Z6bly1RAXlWw7trjW3/yOFjY\nydiW+fdXeSNPvQU4XQPqOUCrxDFAqHnlcw8c6nU/Sp1IIrbZaMlo54Nbls3U\n+IjM\r\n=6/O3\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"4f8937669f6c2be8dfbd4caf65dec08aa2ff9572","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4","tedious":"^11.0.7","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^8.3.2","standard":"^16.0.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.2.0_1627544124889_0.38639826210176853","host":"s3://npm-registry-packages"}},"7.2.1":{"name":"mssql","version":"7.2.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.2.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"./bin/mssql"},"dist":{"shasum":"b63d00a5e721d4976908eeafe693e9e6703a4675","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.2.1.tgz","fileCount":37,"integrity":"sha512-kq0hVeD1tR+ikZqmLwgQqLGSavOhrrwaiYsYxdUQASifc3oIOFRx2IHpuWk+8oLI6Ab/s3o3JfpFX1v1Nf2sxA==","signatures":[{"sig":"MEUCIQDlB7T0Nw/2paPClb5OKUG/3lWHkpYVbpDD8GVcIDPyGQIgK2v5Fh7HdvRulh0b2I55bG0S9yymbr8KhFrM7HaIzYQ=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":259102,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhHrr+CRA9TVsSAnZWagAAEdsP/31lP1SI04RRi1OYe0mu\np3ABYMmYCrJBXqeZxORG7b7gbENCxeW+M1R0m2uIaJv93anA4WzVw9K9itDI\n1eV/aLei9s+QZi4Y+pX6eVNFfLsDzft0OSV0UAOJUTPdrRT8Ckst7Q3uvt5i\n95RB/hXPMybIcvJ3lVSuKmtxEwk9qHGjNN2qdA/Wdak3Ow2YEPS0BlbJjK8r\n6y4fQbyw1sy4EYv7BcHVG3NH4KI62Cr1T2VNWK52Hf9t/oKLLo1DpXnJPDf+\nK6+4PYiyrLzkaZ8GN0as4dzxTIJ3rprQeCulT3mFj/SPC8L4tS6gtKkOQtWK\nQB4K2gJfhGBhtUOC78pS3PHGYDcsWj/bt8O46GaI+Ayr6c38Kk0Fb6IR71CL\nSH6/oRutJvRCG/MONLoiIRwC0GLH6JPy4fHzfckOz37gwBJ+m2EdgqOcuI/3\n1iL03q0vbRGK/BrvI2kRY6tFrFuvcdlkdTIQAQxsHZWc+DWZVf5L6ZADqazk\nHWmBFoaGn97Jc6EOfMcEsYMcUdweJtzGz/PNcZ36WjK8dZH+pAAVfMXU4sjb\nIWO1Ukew9pA6WX9Md865nJFAYArGhDmieqMxQ/RGFXmqOEZi5KPgjPKQRQru\nEEc9zy06FrIspqZUO/2TRkY8ybJuh27n+T/iENLKC8Ngtc4oIntzft/lvbz/\nF0jJ\r\n=L8hC\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"87da4e84e24db861b0c80652c0305843081de8ba","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.9.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"10.14.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4.3.2","tedious":"^11.4.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^8.4.0","standard":"^16.0.3"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.2.1_1629403902559_0.5975441785202784","host":"s3://npm-registry-packages"}},"6.4.0":{"name":"mssql","version":"6.4.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.4.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"d347015b1c589f4220e387a5f0aff3f22d77b9d1","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.4.0.tgz","fileCount":37,"integrity":"sha512-Mtgu3PXqoaL7aHCMurttvEHibjvz5XKjlR6ZCDyAeKtDBORpxm88JyzEU2EESVf7588GulYKc7Gr+Txf5CICBQ==","signatures":[{"sig":"MEUCIQDkh4JO6TYQ1LHmvonoZo3FGzLXX1ba8YVdC2F840LwAgIgHfQuIuh8n6EabdhFLHVabhI6vc9TKen3KaJcJL4+N8s=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":241193,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhltaKCRA9TVsSAnZWagAAxY8P/ik3cHUke589wX06p93r\nj7e5YMkj9dk4tAh6b0fzR9YuwluaQgWg3HQ94wl251OIVEtU7CBo17Q/HOyB\n0FbSAjSw0WRNAxfuyrrF371ACMMQvP7Mk6QRQgljpFOK5Khz/T0Ng+drgnmR\nTjWBCd4rCdlOZ18dOauNDbkoEQQV+VG+2McUHtp/xhbDcRehooeMaqVZdNpp\nU8o6eYML/kI449Lt0vX3e7VmaK+ZqbR3CohfvSfuC+RIa7C2cBN2ZDoHJ6vY\ndXkjbYlqUwaU2gtmYaYyOBZnyHM6btLCxX2Jb2HufmdAjiljccXv3uKo4G2e\nl4glenoZBH3Ng9VwY62TK2ohUNHaYw5uIMFEjdrZMDicDRe8gApj3L4wHsNi\n6X0SpJ2hkX5ktHlBaegZfR0MixU7a/G0iq7mht7pyo1skIqthRgrmFeJ0yB3\nQTW04eIXiFD8YKbaD928s1zOfeN064KTCZALvqoGgmQ2p3jejNV6n1eLP8/l\nNKhh59ovC+KL9CwmZoIDxo/zCUmKJbCItKr6ss8fDt9W2Q340PNOECSDp7O5\nxd3MBxWtH0vE6zt0Zoc/GNVd3wpw5cL7LHzASFiXakIrA2uvAF/jP3fHVuSp\nZSsOLWGwU/eOSckw+MBrfDfc5NAPwWt9ACSFW6QwtQ/NbaoSoNYK+X79cVfS\nNH58\r\n=hKWH\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=6"},"gitHead":"b16835e8810fec2857905bb113425fba27596a12","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.13","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.17.1","dependencies":{"tarn":"^1.1.5","debug":"^4.3.2","tedious":"^6.7.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^6.2.3","standard":"^14.3.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.4.0_1637275274515_0.349232785085809","host":"s3://npm-registry-packages"}},"7.3.0":{"name":"mssql","version":"7.3.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.3.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"290dc219fcbe6d35734514e5d3e769da3eb89546","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.3.0.tgz","fileCount":37,"integrity":"sha512-3NGxDomH5Lci2g0EUrsejHIsvtFwlIE6A9SNFWQ2/JD4Dh0+5XVFHeyB4RXKb+nRMDosSUBAQDIVSuLXo5XFZA==","signatures":[{"sig":"MEYCIQDsn+lcZw62iXZ2l2Le5VEx4Cj/kY0bmcD+uIS/XCOhwQIhAK7czNsV73f5UTeWgpYEn1BvvdZY+1CY/WQH4aieTJAn","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":260086,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJhltg1CRA9TVsSAnZWagAAlh4P/3j47Sfq6YuolsKXfA9q\nITR4ZBV+tkPEST4H2SQAwFZUcYkfe9AN6w1An+SiCNIA7wPXn0guaLsMYtGZ\nxqwv34JUILx78A96O5gPx2Gyog9x5EF9NUIGtx1FNjd6j8G31+UImVj/rVOK\n7aFNZ7qR5RGaDUeMqjiL5CeuCeGvosxGSUYeUpwVPmNMzxI+KeQmSQC96ZrX\naocAeesZhbEFzboZgSP9LZk4nrtzmTxt3QAOhDHGosrTQpHtz8ffIG/7EO6S\nVxIbB3zwew5VbN4m9J+U73Rg8b/fjofd9WZvLp3ki12umxTtX9FR0tlJ0ayO\ni8X9WIffNEH565wQ5fnKIYo0ltSkzNpWMb7SpDUUtA1XdmLovZWar3+lTQCN\no/ybtny+lKSlS00bcPHVweJvrHf+HgYrmjXBSDHgamnbJXPmknNyaa3V/G0P\nomSBMRdOjXlK11P6Nd7lqtSxjx2ER9zrf0O0TSyerMQwH54qIIEZPmF+SIJm\nVqu/EGSpQh/gy7sljOPWgJ1aK42rUdVzmHREmlfPC9V44PtQ7j+1mS2KEg2o\nuoVoRF0asXlegiIpo57Jfr5Ddv9Lu6ywvmsOiO5/HhVHqgntdhs1w5eN17Xy\ni+Kdknkn67J4gdC2wzWhcSjxF/nlqX7DRid21/xdMZsyRyithGudYjEbREyc\nuB4V\r\n=/YDx\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"314b68a2fe0a504841dba92ca2bfda3556816675","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.13","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.17.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4.3.2","tedious":"^11.4.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^8.4.0","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.3.0_1637275701585_0.34405770656977586","host":"s3://npm-registry-packages"}},"8.0.0":{"name":"mssql","version":"8.0.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@8.0.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"4177816b42b7e126f339c936b4660f570c12b5c9","tarball":"https://registry.npmjs.org/mssql/-/mssql-8.0.0.tgz","fileCount":36,"integrity":"sha512-6ePlyQuYlq3QCiN580sZvjEfrU+bo1wxXLzZFU9T59194XlMQIbjijeP3vyo/OyGPV6zIQYaCpvFurQR8itIFA==","signatures":[{"sig":"MEYCIQDmQ4XYJ/1Bz6u8820EaiD0qIFCVDyVHAf8xQlTwHL9yAIhAMmKvZJ+w4be+CPesHraK3ao+V1ABuofMNBWXQPiP+Lm","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":253312,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh9xA4CRA9TVsSAnZWagAAvE0P/11iisO3AiwScCxW7uFt\noU3zNklJ+iJXhpnYjCGP1LFF+M+dTeHYYEbcOSt+gFTB1n2NsRulJcUWY2gD\nGCvf/8Sqkb1fE1nFJl0cIoiPqkd0zEpGzHznBWiSe+dUHMf+PsLYfZxL/NHF\nq2OyVOKOW2IJts0eyXI6HxFgiFx/unl050pz3nt4TOPKvCgIv7t+6n9bgSZQ\nmNlePnqvU3W/R4RZU+iCiGjmBFE52D72X6e7TCyirktndEkwGPSdeUuKfDLi\nlnSZioHFPW4o1D++W1qrsoCgRzwC8Fl4IEDMHJ+HQq/eEwxfRNrwcYBnKlPz\nStPxwN5hjnpt6WqK8rcFkO10UOK1C7WzPykytcknKS/NTUA8UoR7Qo6tBoQI\ns6SEPc//NuFHrthqbCAS14iq8KJHner5YjnVMTSbVe9g+BjTgbKxLew0jmW5\nV95DVKZgWUcsyTY8p+p+B0eD8Qu+gAdJOD6zadpoTjZ6Djo3BbUqtb8QI2O/\n4QubhHt0Zb2A0fwFSqiAgKYo7YM4sI9qyE7Mdv+jM3jPgMZrhgTdmr9HKoj0\nyPw1gNtarTv7w3QxFL+VUHjT3tmzEPrdpbQQ14iCnkdg2Ck7KBPaiD7RdB1E\nSMIQmlZjdcn/vKN29LW3CBG7JMgM2a9nozbed5bPniUjZWML6ZJhobHBC1ao\noVjA\r\n=hM/a\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"919f9980faef9f8de758b188395a002d18e93848","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.13","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.17.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^14.0.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^9.1.3","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_8.0.0_1643581496339_0.7744697349119998","host":"s3://npm-registry-packages"}},"8.0.1":{"name":"mssql","version":"8.0.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@8.0.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"ee7abdeb35d15ffab07dc149344adb0ad93ea2af","tarball":"https://registry.npmjs.org/mssql/-/mssql-8.0.1.tgz","fileCount":36,"integrity":"sha512-GZ1YnfMjfEdiXNRWZeYyTtqHWptUMA5jWrygbqfl72zsCxXsNuLPH9gPxz7m2F6+tWY48hR+ieZ92QY11ILNeg==","signatures":[{"sig":"MEQCIHz9gTcl3fSGYeKTrUK8kcMiCtPv0ZmSfsTKU7fos+GyAiBen0bnDUZBkSldb7Bkus8UTb9JR0M95TSg7obEW9PWgA==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":252301,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJh9xFfCRA9TVsSAnZWagAAVqAQAJyt/IKazznEemSaQPxN\npAJpuwXStsAnCcPXzwD/MeTE5MEy/Zu4nEtH6XPzzLwuTTsePfHiv7HLnUxC\n9B8Q2v00W3qgcKFvH73utk2Fhoc+uQ/TY10BaloDjVp5OZQ6qgaXFkxxT2KJ\nFu8wSu8Oe7PwRxee+NUNstvAEodlchzpwyAE1Pyb6wspq2nlJhf0tV5tz5QB\n+6wqva/GiLYbze5uieqwT2pbI41lUKsNSaibXJi3T0G5D3eX53ijlzZKNeJH\nDJY9j4iQxxgDwU2O6HmRry0ZOE8EUPeYTR/NInzOP0244oJMYrPIu7j9hg7b\njCHFsaQSo4mPTgADUyJltw6ucIjveQruJoDqu3Jm+B5Uji+53uriIY5WYSNq\nkL+UhzKk5PtJqtdpdExElsdT65E3oxZR/OC/dXLRcYdTpRNg4LScG92hpR/l\nxZoGdN6tSgnDyREvK4fa9wumAEUb6lmgIjqwM5b5C2HE5pgntghcqIucwSCv\nXVnztCuzWS0doHlDcXWBMWmnJFLHQjgDFQnuMKyN6Va1UUzjj+40Q+BY/pAg\nV2P4xwkvoPa2+RLatmtymSvM1TZziGKzCmnF3M5gbpRk5TnPHEn7aCwgnmwh\nBqL1GoT3zh/6NjIq4z9One5CEr7BwwNPbu0ZVz4X4ZLCKJaAoSboE+RXjKlF\nTUU7\r\n=0f6o\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"f7cd49909547d485921da9f6d974febdbb85fb60","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.13","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.17.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^14.0.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^9.1.3","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_8.0.1_1643581791247_0.6556835358451323","host":"s3://npm-registry-packages"}},"8.0.2":{"name":"mssql","version":"8.0.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@8.0.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"e8c21c021ddac1ae699a4012ee53ade24d984830","tarball":"https://registry.npmjs.org/mssql/-/mssql-8.0.2.tgz","fileCount":36,"integrity":"sha512-2FKoSFjJ5Ax3QlS/m6peMOlTZ7ks4SQ6D+K7/c7X0a7rJ70EqnQrriZHSvUE6Ale6EaQTtqrjgRMFPDNM9VfXg==","signatures":[{"sig":"MEQCIEGdReiSuWvhm6ASosOOzAHiDHH7yPl8IA6cD+3xvPEDAiBlO3bKLViRSdpCHtRl2M2NGYF4NHKci7ri84IupKh9Ng==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":253043,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.13\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJiARxYCRA9TVsSAnZWagAAlOUQAJ9fapLjyPMshgmUjvQj\n/JFlPyya/EEPPNK5x4Z5gxL75/oKauckYsG/m+55vD5eq8xmbWt1740twkb1\nrOJ16Ic5Pzgj+5IV+kA8JzFTwBz9MO4Z3K3ikpzNRQLRIblYo+Y7ZU6m9sbw\naib+hy8dqp78SX/dcqmHJ21TafDoKRZoK8q50Nj5cJcdwmKPF6+RmtC2bblA\nlo67SUKTeDJHzNMmniOVfYhHQ+XajLLdjvuxrbcKgs4/wyWER4fzpq1AqVYA\nPooBVTb+mcjaU1CP/LVcKSYN4A6w1LEUcQQh+qyuHHCgKDkjkh2huNrSp5+r\nz+oXZsluR6H/ZOWdNyBg9KH84R0AJgknNS4WCy6cbVSMq/eSWMtJ1SjZ64bE\nZi/sy7Zzd8qwCeBgrqdAtry4jBY65CULAxEsCJAcSumjj7Heve6oCDxxsodT\n5hKz1chTN1nBceyLxOGBNh77/LeKJD3V9sHA43eLNBaTetKiuHtqgpaVohqY\nuZ5VEFDlOEQY3icb1/Bxu0Lr7KQVJzwZsZOOmWZR+Udsq2cTWhPVb+/t9ln9\nlXouaRWpZKyVa68PyR+traRQqT+ihdaUs/JcdtWiqxb8EEyRRc5tJ+fh/3cR\nyouHd2fAIaoNW5IRIHIb52XT7WJSB/FS1kdtDQYiSzi1DikWS/mcTtugi/ut\nUTK8\r\n=i115\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"c77c80b7d90c172a76b7422dccce94e77607b06c","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.13","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.17.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^14.0.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^9.1.3","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_8.0.2_1644239960666_0.4790732461649865","host":"s3://npm-registry-packages"}},"6.4.1":{"name":"mssql","version":"6.4.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@6.4.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"24fcde0a32349aa6e1ba2123119ab254e355f8bb","tarball":"https://registry.npmjs.org/mssql/-/mssql-6.4.1.tgz","fileCount":35,"integrity":"sha512-G1I7mM0gfxcH5TGSNoVmxq13Mve5YnQgRAlonqaMlHEjHjMn1g04bsrIQbVHFRdI6++dw/FGWlh8GoItJMoUDw==","signatures":[{"sig":"MEUCIGNcnNa8Pl9KweYeAFWhPeCD90xXfQa3sI82mpmqby6WAiEAszexZIcWfMRts7zfpSvRt8o9OgRyqHBiJ8GXURkSE3k=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":219503,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiGAu0ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmokZQ/+LZ5F+6jEfwjZLeZcfN30UsL7DqdlV+uIEJF10wWBCAE4S8rD\r\nPYIUV4XLY0CBCrgyLXHuJCzYnNhVmz6Yez6u5b8tB7R2uKlfUkt72WgbRqnu\r\nThGlyCB5cQKHvjR1Au6yxGfePN2xdU5XWi0dTrLvlScwOCbHZNt+RToWlPNv\r\nSmBrVR6xXZcwKspapA+nqhdWs8xvgzDON8W3hS1JHsSQ2iTDbVUF8OOPid1s\r\n5vUdDf276W5PPB9Y1S0QZJ9GjzJ2jVpqiZ7pKrRgS5wE/yi1qQiDCMtaI29U\r\nNQQFh36JUWhV35ppvywnKo5wq+jbzpZ0zL8pTF5pH2bRk1av8tAWYjKS8fJ5\r\nNIiyRPMYuvcrQ5BfkqtAgk1b098DmAz7MEvf6GwIhLwt8TPmDYolXxWjSQeN\r\nU7ebecm2uUMvhHzg8y/OZppJpnWxNSwTbh7HC1TQBiWHNlRcb3i5sRt93r24\r\nUpWiFBbxJrO5CqUqcW2D1Ty7m/X90Ej/UhN/tWXWYQYRNAirUDVxwD5+WiqX\r\nO2xNggyIk7Sly71s6T0n/RD3spibykhsRQQ69GKUHRwGkbKx9onWAvjBWtwT\r\n0fq65D16SOaGZ8xJTxeAnEmQaoGRz1BlIHTWCcEcDVoj67IKAYlZWEOLcdJV\r\n9kOtf/Jg+wiBKR6ARYSF6NlpshhjHZL1S1I=\r\n=hvE8\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (v1 native - Windows only)\n\n## Installation\n\n    npm install mssql\n\n## Quick Example\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('mssql://username:password@localhost/database')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    throw new Error('Pool with this name already exists')\n  }\n  return POOLS[name] = (new ConnectionPool(config)).connect()\n}\n\nfunction closePool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    const pool = POOLS[name];\n    delete POOLS[name];\n    return pool.close()\n  }\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Two formats of connection string are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Connection String URI\n\n```\nmssql://username:password@localhost:1433/database?encrypt=true\nmssql://username:password@localhost/INSTANCE/database?encrypt=true&domain=DOMAIN&driver=msnodesqlv8\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect(...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js v10+ or newer. Windows only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8@^1`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` ans `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in serializer for Geography and Geometry CLR data types.\n\n```sql\nselect geography::STGeomFromText('LINESTRING(-122.360 47.656, -122.343 47.656 )', 4326)\nselect geometry::STGeomFromText('LINESTRING (100 100 10.3 12, 20 180, 180 180)', 0)\n```\n\nResults in:\n\n```javascript\n{ srid: 4326,\n  version: 1,\n  points: [ { x: 47.656, y: -122.36 }, { x: 47.656, y: -122.343 } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n\n{ srid: 0,\n  version: 1,\n  points:\n   [ { x: 100, y: 100, z: 10.3, m: 12 },\n     { x: 20, y: 180, z: NaN, m: NaN },\n     { x: 180, y: 180, z: NaN, m: NaN } ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 2 } ],\n  segments: [] }\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested. \n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n### msnodesqlv8\n\n- msnodesqlv8 has problem with errors during transactions - [reported](https://github.com/tediousjs/node-mssql/issues/77).\n- msnodesqlv8 doesn't support [detailed SQL errors](#detailed-sql-errors).\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=6"},"gitHead":"602952b81c0aae624556f91ddf434e26fa6a4da8","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"8.3.1","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"16.14.0","dependencies":{"tarn":"^1.1.5","debug":"^4.3.3","tedious":"^6.7.1"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^6.2.3","standard":"^14.3.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_6.4.1_1645743028605_0.503739528531437","host":"s3://npm-registry-packages"}},"7.3.1":{"name":"mssql","version":"7.3.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.3.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"34d74017e42930c74b686f53f74548d57ba7920e","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.3.1.tgz","fileCount":36,"integrity":"sha512-mu/+4wp0xS/zg+F0xeTsXN4geB/7k+TmtPcIQ0S0IWtoPd/6Th8bGEeLoCWAsLSUop//hXiI+suh/0l4iWmjmA==","signatures":[{"sig":"MEYCIQCn6V8yiGu/DsaVHFzCLfW4rXXKaTdWtH5/iXJItEEfbwIhAPWoErku3bYYujVBbvcieMemmB1F7jQFFquAHLAW4bBY","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":259274,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiGA1ZACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmpRDhAAlohIhu+qZV9LqLO50HYnTKdZPLexS35hPRSyzOc7yLGM/uI0\r\nYQJVLhKDlUy8tU+/opgkkHxebAgxkEnEIBTl0gplui0s8W7b5wGK1NDdSUoY\r\nKIxgGjYu4DRfT/KJSyunDdiw9EdhHgpPxX5/If+1VhPjnESDIIlw6QlMlSlP\r\n2VdDymYtltETQBAUsTMfUOytUKjo4Ohy/QC9ILQgtCfCh971tLsWAd/AJaay\r\nToYVvMEfa0qZnrPcTam+tQDdXv81X/N/oQBRNZyAofuSfTUZuLjXoFEfq0JK\r\nfpjxybjudZTLwlebjoLq8PrmVubjhCWGeuYvi/2nDZM6B2I1Sa69RbXFmjdI\r\nerWcAskw6Z2Mab/YqIDhTacJDGILaU6eT9k9+m4coX7pWlchSkd+EU1JWGI3\r\nogJb5MxMNoTo4zHqU5XlEeBR4kPUpO8eGR02PNAecS2IZn0kpKamencpxKzK\r\nhn+nDPxUGGD+FfdXi5IoKoUicsgPcMrw4srIOGxK0vpQJBJ7rupK6/8xuFRM\r\n5/bKcZBUQOi9ZD+JZY/sZYZ2wVKyqcaVUMmDO8ockhEu1LJsM3c8r3OV4cNA\r\nBxoAKvLZiRFUhUFBxy+9eQaHOE7o+ixTCVIvxt90oZ+WdXZEVVtbAXHLMM+6\r\nzegkTH1gpPiCn+cbGWyi/otihShXpMpKkrw=\r\n=GaVL\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (v2 native - Windows or Linux/macOS 64 bits only)\n\n## Installation\n\n    npm install mssql\n\n## Short Example: Use Connect String\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('Server=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Longer Example: Connect via Config Object\n\nAssuming you have set the appropriate environment variables, you can construct a config object as follows:\n\n```javascript\nconst sql = require('mssql')\nconst sqlConfig = {\n  user: process.env.DB_USER,\n  password: process.env.DB_PWD,\n  database: process.env.DB_NAME,\n  server: 'localhost',\n  pool: {\n    max: 10,\n    min: 0,\n    idleTimeoutMillis: 30000\n  },\n  options: {\n    encrypt: true, // for azure\n    trustServerCertificate: false // change to true for local dev / self-signed certs\n  }\n}\n\nasync () => {\n try {\n  // make sure that any items are correctly URL encoded in the connection string\n  await sql.connect(sqlConfig)\n  const result = await sql.query`select * from mytable where id = ${value}`\n  console.dir(result)\n } catch (err) {\n  // ... error checks\n }\n}\n```\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [toReadableStream](#toReadableStream)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Response Schema](#response-schema)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [6.x to 7.x changes](#6x-to-7x-changes)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('rowsaffected', rowCount => {\n        // Emitted for each `INSERT`, `UPDATE` or `DELETE` statement\n        // Requires NOCOUNT to be OFF (default)\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    return Promise.reject(new Error('Pool with this name already exists'))\n  }\n  return (new ConnectionPool(config)).connect().then((pool) => {\n    return POOLS[name] = pool\n  })\n}\n\nfunction closePool(name) {\n  const pool = getPool(name)\n  if (pool) {\n    delete POOLS[name]\n    return pool.close()\n  }\n  return Promise.resolve()\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Connection strings are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\n**Authentication:**\n\nOn top of the extra options, an `authentication` property can be added to the pool config option\n\n- **authentication** - An object with authentication settings, according to the [Tedious Documentation](https://tediousjs.github.io/tedious/api-connection.html). Passing this object will override `user`, `password`, `domain` settings.\n- **authentication.type** - Type of the authentication method, valid types are `default`, `ntlm`, `azure-active-directory-password`, `azure-active-directory-access-token`, `azure-active-directory-msi-vm`, or `azure-active-directory-msi-app-service`\n- **authentication.options** - Options of the authentication required by the `tedious` driver, depends on `authentication.type`. For more details, check [Tedious Authentication Interfaces](https://github.com/tediousjs/tedious/blob/v11.1.1/src/connection.ts#L200-L318)\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js v10+ or newer. Windows 32-64 bits or Linux/macOS 64 bits only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8@^2`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\nNote: If you use import into your lib to prepare your request (`const { VarChar } = require('mssql')`) you also need to upgrade all your types import into your code (`const { VarChar } = require('mssql/msnodesqlv8')`) or a `connection.on is not a function` error will be thrown.\n\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nPlease note that the connection string with this driver is not the same than tedious and use yes/no instead of true/false. You can see more on the [ODBC](https://docs.microsoft.com/fr-fr/dotnet/api/system.data.odbc.odbcconnection.connectionstring?view=dotnet-plat-ext-5.0) documentation.\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### toReadableStream\n\nConvert request to a Node.js ReadableStream\n\n__Example__\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream()\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\nOR if you wanted to increase the highWaterMark of the read stream to buffer more rows in memory\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream({ highWaterMark: 100 })\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in deserializer for Geography and Geometry CLR data types.\n\n### Geography\n\nGeography types can be constructed several different ways. Refer carefully to documentation to verify the coordinate ordering; the ST methods tend to order parameters as longitude (x) then latitude (y), while custom CLR methods tend to prefer to order them as latitude (y) then longitude (x).\n\nThe query:\n\n```sql\nselect geography::STGeomFromText(N'POLYGON((1 1, 3 1, 3 1, 1 1))',4326)\n```\n\nresults in:\n\n```javascript\n{\n  srid: 4326,\n  version: 2,\n  points: [\n    Point { lat: 1, lng: 1, z: null, m: null },\n    Point { lat: 1, lng: 3, z: null, m: null },\n    Point { lat: 1, lng: 3, z: null, m: null },\n    Point { lat: 1, lng: 1, z: null, m: null }\n  ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 3 } ],\n  segments: []\n}\n```\n\n**NOTE:** You will also see `x` and `y` coordinates in parsed Geography points,\nthey are not recommended for use. They have thus been omitted from this example.\nFor compatibility, they remain flipped (x, the horizontal offset, is instead used for latitude, the vertical), and thus risk misleading you.\nPrefer instead to use the `lat` and `lng` properties.\n\n### Geometry\n\nGeometry types can also be constructed in several ways. Unlike Geographies, they are consistent in always placing x before y. node-mssql decodes the result of this query:\n\n```sql\nselect geometry::STGeomFromText(N'POLYGON((1 1, 3 1, 3 7, 1 1))',4326)\n```\n\ninto the JavaScript object:\n\n```javascript\n{\n  srid: 4326,\n  version: 1,\n  points: [\n    Point { x: 1, y: 1, z: null, m: null },\n    Point { x: 1, y: 3, z: null, m: null },\n    Point { x: 7, y: 3, z: null, m: null },\n    Point { x: 1, y: 1, z: null, m: null }\n  ],\n  figures: [ { attribute: 2, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 3 } ],\n  segments: []\n}\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Response Schema\n\nAn object returned from a `sucessful` basic query would look like the following.\n```javascript\n{\n\trecordsets: [\n\t\t[\n\t\t\t{\n\t\t\t\tCOL1: \"some content\",\n\t\t\t\tCOL2: \"some more content\"\n\t\t\t}\n\t\t]\n\t],\n\trecordset: [\n\t\t{\n\t\t\tCOL1: \"some content\",\n\t\t\tCOL2: \"some more content\"\n\t\t}\n\t],\n\toutput: {},\n\trowsAffected: [1]\n}\n\n```\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\nIn addition to the rowsAffected attribute on the done event, each statement will emit the number of affected rows as it is completed.\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('rowsaffected', rowCount => {\n    console.log(rowCount)\n})\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested. \n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n## 6.x to 7.x changes\n\n- Upgraded tedious version to v11\n- Upgraded msnodesqlv8 version support to v2\n- Upgraded tarn.js version to v3\n- Requests in stream mode that pipe into other streams no longer pass errors up the stream chain\n- Request.pipe now pipes a true node stream for better support of backpressure\n- tedious config option `trustServerCertificate` defaults to `false` if not supplied\n- Dropped support for Node < 10\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=10"},"gitHead":"b33a83a4c16f0b316dda34af50f203f11b3b6b4a","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.15","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.18.2","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4.3.3","tedious":"^11.4.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^8.4.0","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.3.1_1645743448928_0.11206667194053299","host":"s3://npm-registry-packages"}},"8.1.0":{"name":"mssql","version":"8.1.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@8.1.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"d660eafdf0fcf529e2c839705b9455d60ccbacf5","tarball":"https://registry.npmjs.org/mssql/-/mssql-8.1.0.tgz","fileCount":34,"integrity":"sha512-S7j4MoanTCLM09I+wMI9thTS2342mgxCpOQ9kpnFiG3P1NStuQMhPILLOgOt6hwMa/ctfTUKl7eJpB5XGPoe6A==","signatures":[{"sig":"MEUCIBdSFvg9zgb7xJDUXxPE3pn6ABft/ri5RRUB2dBccv4LAiEAgrWCI8dsihfDyPTBn8GLycUxa0cW/zgCQbfzmSWOF0A=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":254979,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJiTXK9ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmp3XQ/9F3CnB7uyYzyNgPUQJQ2skROPml2OmIY2GFlAt3EBiv9zZKpO\r\nGaMGPCqEDe10h5Xos1GJwJhKVifARvZraClF+qfjKCLlvHmk4sf1Gb9Oz++W\r\nja0fKOF/H+YEvugnmUXvtUuebmHddriHs1EVihz8C4PAavw0kf3F56bN5RvC\r\noHtnT14UrfHU7r+x1ky0lIVHWlHYxQda8u2xR9kCY91mDD2yyLVEM8ti52ZI\r\nYXw8cmZfZ3VOicOM00CNeQARQuQ8K2+fcYi1Bl+GT+Vdvyc/wFynXfLljv2c\r\nn9OBA8pTpZKcY9yk+HMz2GjZSy8u/+pqqD67P1j5D+4kEAle7x7lORc160rT\r\n8c5NZ3qInte+n3RYMFNUURj22rRhHBgjodR6zTyIWzqMs+uSrBPWFNBM45NN\r\nGClKjLUPRIZ3kZ/AXvNOBBvoud/WmhkgU6g8rJp7YaKe7EaTndbMiAFbtW7g\r\nvXmVQihYHWSJSZPQ5WdxvCaALBxBEB/1v4b8xfKEFqvMc9IPfj2DArj/J48J\r\n5UckOF/c84Qhp47JxKOAnPymBuNPm2zKX+yisiOtjXtLclb0vp+ldmN+eBrb\r\nU+uF1GLMPdepCR2MhlJb4njHY5iEOHQksdexD4SWFHzAgrL64zzdrrwZDerq\r\nZTgi4YIhbylvRfNZORcXwY3qs0BF4XPxido=\r\n=t9K6\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"640c37e90c96e6d303ea6d183a0441ec689fb715","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.13","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.17.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^14.0.0","commander":"^9.1.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^9.1.3","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_8.1.0_1649242813453_0.44224853837443434","host":"s3://npm-registry-packages"}},"7.3.3":{"name":"mssql","version":"7.3.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.3.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"d9622ae779fede004dbe22b802707e090b88db5a","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.3.3.tgz","fileCount":35,"integrity":"sha512-gZFcZxc53Id5Bd88Jy4PfS6tt127MarmrqDQ0bIHMAMPBL76/tn9AlH6MRohk4Pv5kXLEweeHyJiwil23Ph2RA==","signatures":[{"sig":"MEYCIQDO0XscH+3mdSz4JSJp3Xe3tMz6dwZcSXwMhhgYYW/2SAIhAPqEVtVN9BokkVLrPZ4mXY3BpFEt8Be9IzENBa0tuSTe","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":259508,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJihKTkACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmr/Tw/+OwMNuUvhLaWN19FQ88LoXhrnG5+re4aXdug9JKALBD4duTo3\r\nxlQ11RUHgdIsv7kaa6O8c2xbmffHxKbzdHzwF6n/WN1wrKYu46VJnuhnt/aE\r\ndxmEjGguXSGYM/9CQCwhuHKE2m+rKrLm7j/fQZx4yuxz16mj64H0ewxhOA0s\r\n9Afk/CF+Mb755Y7R1uTtKQmNuY+/7pUjDFP+RLYouTqcU2FXiEGAukvFK4ga\r\ngH6i8AOV5MagE8w1Nj1GHxw7+8vP6iPZruyhjz1HlQaPrVwuf2PsbjjqSlcm\r\n8HCG+xsMP/S1eTFb+3Uz28383Y1ghMTdMn82XaWojV14ZdTe1MoBKR4m9C+D\r\nxdc4D+ExiOlQ20HwMYKNcifGC8+OPZnlpHPljO6U2XDP+YQofO5XyNFKv4NS\r\ns891TgR4I0Q/TQJMh8zG8b0Wzm2N1QpAMqiBQ7+Ax3NoxEghBl5c6maHFLjx\r\nqqCQGiNR/MT7IB/MtswFfXOZQ1fuBI7yiGhNOoyhltH3D8XVZV1l9TDZLkgu\r\n82QWwzTH3kXzdgnkjoccYKEG2yzAS94iWBdh26cwmgMaDAcBpUWUKac1zwII\r\njG+EwVTvDJx2xt2YvF7N17u0tGvHSH7O22jAF4eyggKnp+p4ixDtHf8gWV4j\r\nSOh0poJCtjRxtUl+4x+bS+HMQrzZSINlRGc=\r\n=07W8\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (v2 native - Windows or Linux/macOS 64 bits only)\n\n## Installation\n\n    npm install mssql\n\n## Short Example: Use Connect String\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('Server=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Longer Example: Connect via Config Object\n\nAssuming you have set the appropriate environment variables, you can construct a config object as follows:\n\n```javascript\nconst sql = require('mssql')\nconst sqlConfig = {\n  user: process.env.DB_USER,\n  password: process.env.DB_PWD,\n  database: process.env.DB_NAME,\n  server: 'localhost',\n  pool: {\n    max: 10,\n    min: 0,\n    idleTimeoutMillis: 30000\n  },\n  options: {\n    encrypt: true, // for azure\n    trustServerCertificate: false // change to true for local dev / self-signed certs\n  }\n}\n\nasync () => {\n try {\n  // make sure that any items are correctly URL encoded in the connection string\n  await sql.connect(sqlConfig)\n  const result = await sql.query`select * from mytable where id = ${value}`\n  console.dir(result)\n } catch (err) {\n  // ... error checks\n }\n}\n```\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [toReadableStream](#toReadableStream)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Response Schema](#response-schema)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [6.x to 7.x changes](#6x-to-7x-changes)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('rowsaffected', rowCount => {\n        // Emitted for each `INSERT`, `UPDATE` or `DELETE` statement\n        // Requires NOCOUNT to be OFF (default)\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    return Promise.reject(new Error('Pool with this name already exists'))\n  }\n  return (new ConnectionPool(config)).connect().then((pool) => {\n    return POOLS[name] = pool\n  })\n}\n\nfunction closePool(name) {\n  const pool = getPool(name)\n  if (pool) {\n    delete POOLS[name]\n    return pool.close()\n  }\n  return Promise.resolve()\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Connection strings are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\n**Authentication:**\n\nOn top of the extra options, an `authentication` property can be added to the pool config option\n\n- **authentication** - An object with authentication settings, according to the [Tedious Documentation](https://tediousjs.github.io/tedious/api-connection.html). Passing this object will override `user`, `password`, `domain` settings.\n- **authentication.type** - Type of the authentication method, valid types are `default`, `ntlm`, `azure-active-directory-password`, `azure-active-directory-access-token`, `azure-active-directory-msi-vm`, or `azure-active-directory-msi-app-service`\n- **authentication.options** - Options of the authentication required by the `tedious` driver, depends on `authentication.type`. For more details, check [Tedious Authentication Interfaces](https://github.com/tediousjs/tedious/blob/v11.1.1/src/connection.ts#L200-L318)\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js v10+ or newer. Windows 32-64 bits or Linux/macOS 64 bits only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8@^2`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\nNote: If you use import into your lib to prepare your request (`const { VarChar } = require('mssql')`) you also need to upgrade all your types import into your code (`const { VarChar } = require('mssql/msnodesqlv8')`) or a `connection.on is not a function` error will be thrown.\n\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nPlease note that the connection string with this driver is not the same than tedious and use yes/no instead of true/false. You can see more on the [ODBC](https://docs.microsoft.com/fr-fr/dotnet/api/system.data.odbc.odbcconnection.connectionstring?view=dotnet-plat-ext-5.0) documentation.\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### toReadableStream\n\nConvert request to a Node.js ReadableStream\n\n__Example__\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream()\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\nOR if you wanted to increase the highWaterMark of the read stream to buffer more rows in memory\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream({ highWaterMark: 100 })\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in deserializer for Geography and Geometry CLR data types.\n\n### Geography\n\nGeography types can be constructed several different ways. Refer carefully to documentation to verify the coordinate ordering; the ST methods tend to order parameters as longitude (x) then latitude (y), while custom CLR methods tend to prefer to order them as latitude (y) then longitude (x).\n\nThe query:\n\n```sql\nselect geography::STGeomFromText(N'POLYGON((1 1, 3 1, 3 1, 1 1))',4326)\n```\n\nresults in:\n\n```javascript\n{\n  srid: 4326,\n  version: 2,\n  points: [\n    Point { lat: 1, lng: 1, z: null, m: null },\n    Point { lat: 1, lng: 3, z: null, m: null },\n    Point { lat: 1, lng: 3, z: null, m: null },\n    Point { lat: 1, lng: 1, z: null, m: null }\n  ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 3 } ],\n  segments: []\n}\n```\n\n**NOTE:** You will also see `x` and `y` coordinates in parsed Geography points,\nthey are not recommended for use. They have thus been omitted from this example.\nFor compatibility, they remain flipped (x, the horizontal offset, is instead used for latitude, the vertical), and thus risk misleading you.\nPrefer instead to use the `lat` and `lng` properties.\n\n### Geometry\n\nGeometry types can also be constructed in several ways. Unlike Geographies, they are consistent in always placing x before y. node-mssql decodes the result of this query:\n\n```sql\nselect geometry::STGeomFromText(N'POLYGON((1 1, 3 1, 3 7, 1 1))',4326)\n```\n\ninto the JavaScript object:\n\n```javascript\n{\n  srid: 4326,\n  version: 1,\n  points: [\n    Point { x: 1, y: 1, z: null, m: null },\n    Point { x: 1, y: 3, z: null, m: null },\n    Point { x: 7, y: 3, z: null, m: null },\n    Point { x: 1, y: 1, z: null, m: null }\n  ],\n  figures: [ { attribute: 2, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 3 } ],\n  segments: []\n}\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Response Schema\n\nAn object returned from a `sucessful` basic query would look like the following.\n```javascript\n{\n\trecordsets: [\n\t\t[\n\t\t\t{\n\t\t\t\tCOL1: \"some content\",\n\t\t\t\tCOL2: \"some more content\"\n\t\t\t}\n\t\t]\n\t],\n\trecordset: [\n\t\t{\n\t\t\tCOL1: \"some content\",\n\t\t\tCOL2: \"some more content\"\n\t\t}\n\t],\n\toutput: {},\n\trowsAffected: [1]\n}\n\n```\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\nIn addition to the rowsAffected attribute on the done event, each statement will emit the number of affected rows as it is completed.\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('rowsaffected', rowCount => {\n    console.log(rowCount)\n})\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested. \n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n## 6.x to 7.x changes\n\n- Upgraded tedious version to v11\n- Upgraded msnodesqlv8 version support to v2\n- Upgraded tarn.js version to v3\n- Requests in stream mode that pipe into other streams no longer pass errors up the stream chain\n- Request.pipe now pipes a true node stream for better support of backpressure\n- tedious config option `trustServerCertificate` defaults to `false` if not supplied\n- Dropped support for Node < 10\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=10"},"gitHead":"3caf3d8d69346423af6cc47bcd8632cbafaaeb35","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.16","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.19.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4.3.3","tedious":"^11.4.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^8.4.0","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.3.3_1652860132558_0.7770815213986584","host":"s3://npm-registry-packages"}},"7.3.2":{"name":"mssql","version":"7.3.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.3.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"b6dce91f7f0ac932ccde1a845e6f363c8fb276da","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.3.2.tgz","fileCount":35,"integrity":"sha512-iLIhScZGwZwU6NQgURKpJ/lvviQ+epyb7sXxtU/8xqz9wYK91eIueInV6TdfIO8qHQljKbAX0NmXFl34w5bTCQ==","signatures":[{"sig":"MEYCIQCoajybPW+HyGZkKIYkPSU1KPe/MuTT9ctkp0JPZCtTBAIhAIL2dZ1okL+dvhTjKxsh1PgRuTqTVAhnWxjgQ/ygaNZl","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":259508,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJihKbcACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmou5g/+PQ9Nrn3HItRJ1fT9gTLMnQZBTL65zaNvBnbeUC+CafJIpknW\r\nnTyuuqJlAJSl8H/lYlUlHjyrxMHxcfCa2QoiBbEjEfk6MSpvB+tz6cUpBJIm\r\nUpq8mrFXeZSSg4dpqrQTb7omhvUH6edXI4ktgE94V2YBXK2uOkRjTgJT5L10\r\n2TeXoTQT/5Xez23T9evgNeMXq4pVIWdNyY+C2h683Y27Xxteqz/IcST3SRIB\r\nY6u/cqVt+KAj5KQsIvDBfQ3StEiza2WeWAW3CIvR4nVfJ2dLCC3nV74cu+vd\r\nrT8LDnD7bEd8XPDZHErUl8Oo+iLPLn2PeYeMYp2Sx29yApEjsggz/NnOyAp+\r\nVKSqXG7iNg+ERVGHWqVaSudV5SjfnRaYDzCRDjSTQP9W8geWmxuX+UdiBpEL\r\nqx8HMq0T2ivfvcYIOfLK/rMS3cYuMXlIYVfnAhQQa4+Usp4KqFHxB0CpZuDc\r\nQpZtsxIdB8LLD8XpE5UJ/9PPOQwd2kmoqUuZLecB/P9b8EzEv4/2IiBdu8zi\r\nHnuuM/cnsvkVyYWzIbCjZVK7zsq2KZKGIwDy5fdeZ0kBsJWTSDMMvuTjCj1l\r\nMdAVWIS1rh0RQKW0R4g8MzRauYrz1YIhZRbxMiXT5K/aelsETMeDeQGmz7ID\r\nGzZsnwSLSU59Iv0Ahtwsogm0g89l9RV5jgk=\r\n=ZPBm\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"446f30f35935b907a8c55cf9e29d55f1035fe829","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.16","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.19.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4.3.3","tedious":"^11.4.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^8.4.0","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.3.2_1652860636543_0.6692432288311501","host":"s3://npm-registry-packages"}},"7.3.4":{"name":"mssql","version":"7.3.4","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.3.4","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"6369d3eba6d2b9600461647826a9d002b65f7e51","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.3.4.tgz","fileCount":36,"integrity":"sha512-/pHh7YbY60X63eFUUMFiowZnN7+LKcSbexBc7zMOiiDQB7eftoSL9GunYkY5MhSmvHXjsids9izbCdzTeqzwIA==","signatures":[{"sig":"MEUCIQCxuQvUaod3863Aw3J6hPTbsMFzRxyRiA8lGjI9MFV0OgIgWay7cKELa8w+k0ZDvgsWfoDQtUYhsdubiKPjDlKCmvQ=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":259732,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJihKiEACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrWfRAAiFJxVOe8k5FbXmVhs7OwEry0W+metQSeSJOCIA5f8JynhRQk\r\n1rpLh7TQ+ySt5JZYUTN0JqlRBEV1FObUEhJtUDIWqadYCgVrcz9XnWxyJW6x\r\nmSgSCwvqF4g6foL33mSSPK8rSMh7vf8kk4iTanjO9ABTkO+0UdbnyChlJZn8\r\nn1sZOem/ghvrGm/zVYfvPD1bCsSWC3WfZFkgE0OyNiavcDSEhQggJtjoGDgP\r\nyoBGfguEb/b7V8qg9XEiJ6W5eGRliXWfgvsQJhqVzxHDTl55tuUKfM3qVnw7\r\nHJFG6dKchlFDTI22LH0RC12J3mba4Ggow1TLq9xBgQFYhiSr63O5352YFd2P\r\nu2Wo/GxQP8KhiZB1aqpRS+KBfCvxeDPEpxVJY+ozOkX7ZEsfDkc+ESEIlC16\r\nJUPT9AMb+dZIaLYqAWAppTWml92BHV+lbKR6YiaoBOkprwRaazCB0w6SYHab\r\n6AWGP7pe8jWULbYtODuu4hObML4COiLyFKAgPIfnENuVJrwFJluHGG32I/zo\r\nqo0deWYR0nUT49bQx1qDXiP0NwI514xhZDE2yACMGrC3CIDFvAbJw4/EjxrV\r\ntcn60T6xZ5wDXpfcRTqMbNbp13cyqlehTasM/hqV+8VYO512JOIB+vQTTFm7\r\nVOW7leNekgcet52gzOQC33thgGYLFMxTchY=\r\n=PrG6\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (v2 native - Windows or Linux/macOS 64 bits only)\n\n## Installation\n\n    npm install mssql\n\n## Short Example: Use Connect String\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('Server=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Longer Example: Connect via Config Object\n\nAssuming you have set the appropriate environment variables, you can construct a config object as follows:\n\n```javascript\nconst sql = require('mssql')\nconst sqlConfig = {\n  user: process.env.DB_USER,\n  password: process.env.DB_PWD,\n  database: process.env.DB_NAME,\n  server: 'localhost',\n  pool: {\n    max: 10,\n    min: 0,\n    idleTimeoutMillis: 30000\n  },\n  options: {\n    encrypt: true, // for azure\n    trustServerCertificate: false // change to true for local dev / self-signed certs\n  }\n}\n\nasync () => {\n try {\n  // make sure that any items are correctly URL encoded in the connection string\n  await sql.connect(sqlConfig)\n  const result = await sql.query`select * from mytable where id = ${value}`\n  console.dir(result)\n } catch (err) {\n  // ... error checks\n }\n}\n```\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [toReadableStream](#toReadableStream)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Response Schema](#response-schema)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [6.x to 7.x changes](#6x-to-7x-changes)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('rowsaffected', rowCount => {\n        // Emitted for each `INSERT`, `UPDATE` or `DELETE` statement\n        // Requires NOCOUNT to be OFF (default)\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    return Promise.reject(new Error('Pool with this name already exists'))\n  }\n  return (new ConnectionPool(config)).connect().then((pool) => {\n    return POOLS[name] = pool\n  })\n}\n\nfunction closePool(name) {\n  const pool = getPool(name)\n  if (pool) {\n    delete POOLS[name]\n    return pool.close()\n  }\n  return Promise.resolve()\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Connection strings are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\n**Authentication:**\n\nOn top of the extra options, an `authentication` property can be added to the pool config option\n\n- **authentication** - An object with authentication settings, according to the [Tedious Documentation](https://tediousjs.github.io/tedious/api-connection.html). Passing this object will override `user`, `password`, `domain` settings.\n- **authentication.type** - Type of the authentication method, valid types are `default`, `ntlm`, `azure-active-directory-password`, `azure-active-directory-access-token`, `azure-active-directory-msi-vm`, or `azure-active-directory-msi-app-service`\n- **authentication.options** - Options of the authentication required by the `tedious` driver, depends on `authentication.type`. For more details, check [Tedious Authentication Interfaces](https://github.com/tediousjs/tedious/blob/v11.1.1/src/connection.ts#L200-L318)\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js v10+ or newer. Windows 32-64 bits or Linux/macOS 64 bits only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8@^2`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\nNote: If you use import into your lib to prepare your request (`const { VarChar } = require('mssql')`) you also need to upgrade all your types import into your code (`const { VarChar } = require('mssql/msnodesqlv8')`) or a `connection.on is not a function` error will be thrown.\n\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nPlease note that the connection string with this driver is not the same than tedious and use yes/no instead of true/false. You can see more on the [ODBC](https://docs.microsoft.com/fr-fr/dotnet/api/system.data.odbc.odbcconnection.connectionstring?view=dotnet-plat-ext-5.0) documentation.\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### toReadableStream\n\nConvert request to a Node.js ReadableStream\n\n__Example__\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream()\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\nOR if you wanted to increase the highWaterMark of the read stream to buffer more rows in memory\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream({ highWaterMark: 100 })\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in deserializer for Geography and Geometry CLR data types.\n\n### Geography\n\nGeography types can be constructed several different ways. Refer carefully to documentation to verify the coordinate ordering; the ST methods tend to order parameters as longitude (x) then latitude (y), while custom CLR methods tend to prefer to order them as latitude (y) then longitude (x).\n\nThe query:\n\n```sql\nselect geography::STGeomFromText(N'POLYGON((1 1, 3 1, 3 1, 1 1))',4326)\n```\n\nresults in:\n\n```javascript\n{\n  srid: 4326,\n  version: 2,\n  points: [\n    Point { lat: 1, lng: 1, z: null, m: null },\n    Point { lat: 1, lng: 3, z: null, m: null },\n    Point { lat: 1, lng: 3, z: null, m: null },\n    Point { lat: 1, lng: 1, z: null, m: null }\n  ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 3 } ],\n  segments: []\n}\n```\n\n**NOTE:** You will also see `x` and `y` coordinates in parsed Geography points,\nthey are not recommended for use. They have thus been omitted from this example.\nFor compatibility, they remain flipped (x, the horizontal offset, is instead used for latitude, the vertical), and thus risk misleading you.\nPrefer instead to use the `lat` and `lng` properties.\n\n### Geometry\n\nGeometry types can also be constructed in several ways. Unlike Geographies, they are consistent in always placing x before y. node-mssql decodes the result of this query:\n\n```sql\nselect geometry::STGeomFromText(N'POLYGON((1 1, 3 1, 3 7, 1 1))',4326)\n```\n\ninto the JavaScript object:\n\n```javascript\n{\n  srid: 4326,\n  version: 1,\n  points: [\n    Point { x: 1, y: 1, z: null, m: null },\n    Point { x: 1, y: 3, z: null, m: null },\n    Point { x: 7, y: 3, z: null, m: null },\n    Point { x: 1, y: 1, z: null, m: null }\n  ],\n  figures: [ { attribute: 2, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 3 } ],\n  segments: []\n}\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Response Schema\n\nAn object returned from a `sucessful` basic query would look like the following.\n```javascript\n{\n\trecordsets: [\n\t\t[\n\t\t\t{\n\t\t\t\tCOL1: \"some content\",\n\t\t\t\tCOL2: \"some more content\"\n\t\t\t}\n\t\t]\n\t],\n\trecordset: [\n\t\t{\n\t\t\tCOL1: \"some content\",\n\t\t\tCOL2: \"some more content\"\n\t\t}\n\t],\n\toutput: {},\n\trowsAffected: [1]\n}\n\n```\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\nIn addition to the rowsAffected attribute on the done event, each statement will emit the number of affected rows as it is completed.\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('rowsaffected', rowCount => {\n    console.log(rowCount)\n})\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested. \n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n## 6.x to 7.x changes\n\n- Upgraded tedious version to v11\n- Upgraded msnodesqlv8 version support to v2\n- Upgraded tarn.js version to v3\n- Requests in stream mode that pipe into other streams no longer pass errors up the stream chain\n- Request.pipe now pipes a true node stream for better support of backpressure\n- tedious config option `trustServerCertificate` defaults to `false` if not supplied\n- Dropped support for Node < 10\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=10"},"gitHead":"6d87e8a460a77c9b160b0cf5f78fd479d6399bf0","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.16","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.19.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4.3.3","tedious":"^11.4.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^8.4.0","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.3.4_1652861059841_0.8178097478272595","host":"s3://npm-registry-packages"}},"8.1.1":{"name":"mssql","version":"8.1.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@8.1.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"8806f3e4356a0e6526ed0d18bc64da3f4e85d2d6","tarball":"https://registry.npmjs.org/mssql/-/mssql-8.1.1.tgz","fileCount":34,"integrity":"sha512-1eqLvf/x7owSnwZGpd2oDpBC/BzALjl+ERG2S+4I5IBmeNnxe+XftBrWq9qpgIsJrqyUBBUNoYNNAcbJcQzWFg==","signatures":[{"sig":"MEUCIQCujTGayqxEqxrG2WI0AER7gSDxNwl3f7b1EkkyBhVf0QIgdI5yz6eHhZcku+D+wmLI9GaG+39TAy+/jQ2PCg6PMqg=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":255541,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJihKkgACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmphow/9FDFZABO1YN6VanVvByuX1fNQO709cTySssOUEtfQx0GPh2VA\r\nfRmUFdqWaUNxnJaFYEBw41lDKjw3bfrdgSbHVOaZ02WBOs6mZpSWqs8sNtBn\r\nYMMMYk/CtZmgq3+pXxeEMYrckX8qkBoALktltV5T31JbUlOA24IF76a2xI4+\r\nbgEA3IWjjY+3wr9x96u8wC+hUwdJF5WK/qo5Qf7XI7czhI5lHI/Y2+on7O6o\r\n+C9gffSw14A1GvZeeI664TQvEPjn5bIewJhQSgWJoq11ZMAz5NztPTG/OjHC\r\nd825dU9CwXtd5xrqo+HttKdqU1bL1QHPc2DxOZcq8HLjprV5a0mBMuGGFqWv\r\nbWTQC/bW4CSgDTBjNsaYp/okC1QKzfAeBg++j+V/jj2hBLrN8wvMTw963NH1\r\n2DwQO07xUF5XnhM8Xo7V5bVKcNJUyRBldrVLS96vXjD5Kagt6/O7/nDK8/Jm\r\nDyhyO8j+0MDiWaz/zlePQ9uKwF518OSrmtRnl8AWo/nWJIH7/Gfu+jNSav/C\r\nQLA62km4X/zX5OdWI6JWphOeC/rTQCeXNytpZMTMnX9x7AJboqGJ3iAKraXg\r\nPDjkaQ6CZcbkKX4FToEReaaFdJmubLZP/NdGZeGWmfNRUb4qXF5H6O9KYAUt\r\nLIOYhzbtb2ITTNqKvB+3rFF3KG4lh+8561U=\r\n=qDOo\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"338ecd67fb24044e8be0c1dcba9ec902a8f4041c","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.16","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.19.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^14.0.0","commander":"^9.1.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^9.1.3","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_8.1.1_1652861216388_0.12704816605197067","host":"s3://npm-registry-packages"}},"7.3.5":{"name":"mssql","version":"7.3.5","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@7.3.5","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"f2efe50d863b642e64ed5c7bf33cf640dd0f854c","tarball":"https://registry.npmjs.org/mssql/-/mssql-7.3.5.tgz","fileCount":36,"integrity":"sha512-LTOSQ3k8yZTBfO/5XwH7zC6fDPBx1sYgMXZyP/k+ErWrhZN8faAvDq+/gMlm9DaFG9yaOipHedF5JSPV17EHNw==","signatures":[{"sig":"MEUCIQDDClroIiuNQTzaKEV+7Ak6U2BPCp9D1nrYzRhe7hxLgQIgW/gam/0HlXqIgRq/CGz+MHRhRCANasoM+M5iB4JLNpo=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":259892,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJikPvSACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmr6Gg/+IeKas96WrK8sZoXCLUiUiyHNhPFHfMzZXVA/V6lXM++GLK1D\r\nxWSv7CFyMuwOoFswIQoFQdhN/CGg/gWoziZsPaIKv/zKLtzfgQYNKpVEA4Hu\r\n4kC/y8iBBrmA6X1JE83bS49fymZoyUezDOZyKb/tswGN55FZLHZYU214eGRg\r\n16ndvkgPzqZQfoLSDer4OT0RfGLTLxGVATcJUzd4TFLMYALlgDZXA1FxrXVj\r\nsrcxkpHKw0qHNwINZ8fT3gh9Dy0oLn4BHWCuoG9D816tAdBStruce0Fxm2FQ\r\n6fKX6owjhCqulzzY46d36IB/p6gaPbCzK6bh1QY3Duk5bOwbbdmaK6haLqaK\r\nI/2nnI02xIu1WNhpUTlraaAh090LzblXAB0c5CpIakU9XKA8L2XY2YrPocyq\r\nshdS7jNZkHp2a6qch42E8cwebbkBz6ztlRIk19BL4OUMMC5xJDeq+mZo/Fks\r\nkgq+sIvV09XRCKtC/lGnAD0BdnnY9DVLlyDJfQt4zF0jU/iNCllOHZlwgH4/\r\ngaUCTL3LAZBVkYblVjZS39an4gsXHuo6viIbmO+JcJNCjGrhnDv56S92IshT\r\nwBxGB7YVXYFhajkjvf3Q0C6A/tyMjWWdheLVDxe/uevYdQrR1DvA3Y1Cujav\r\nSRVytNLcH+Lre/ULQG9nA94AVOI/i9tYqWs=\r\n=hzsp\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Travis CI][travis-image]][travis-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (v2 native - Windows or Linux/macOS 64 bits only)\n\n## Installation\n\n    npm install mssql\n\n## Short Example: Use Connect String\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('Server=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Longer Example: Connect via Config Object\n\nAssuming you have set the appropriate environment variables, you can construct a config object as follows:\n\n```javascript\nconst sql = require('mssql')\nconst sqlConfig = {\n  user: process.env.DB_USER,\n  password: process.env.DB_PWD,\n  database: process.env.DB_NAME,\n  server: 'localhost',\n  pool: {\n    max: 10,\n    min: 0,\n    idleTimeoutMillis: 30000\n  },\n  options: {\n    encrypt: true, // for azure\n    trustServerCertificate: false // change to true for local dev / self-signed certs\n  }\n}\n\nasync () => {\n try {\n  // make sure that any items are correctly URL encoded in the connection string\n  await sql.connect(sqlConfig)\n  const result = await sql.query`select * from mytable where id = ${value}`\n  console.dir(result)\n } catch (err) {\n  // ... error checks\n }\n}\n```\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [toReadableStream](#toReadableStream)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Response Schema](#response-schema)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [6.x to 7.x changes](#6x-to-7x-changes)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('rowsaffected', rowCount => {\n        // Emitted for each `INSERT`, `UPDATE` or `DELETE` statement\n        // Requires NOCOUNT to be OFF (default)\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Pool Management\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool)\nas this library uses connection pooling extensively.\n\nAs one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process\nto create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand\nhow the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection (Pool)\n\nTo assist with pool management in your application there is the global `connect()` function that is available for use. As of\nv6 of this library a developer can make repeated calls to this function to obtain the global connection pool. This means you\ndo not need to keep track of the pool in your application (as used to be the case). If the global pool is already connected,\nit will resolve to the connected pool. For example:\n\n```js\nconst sql = require('mssql')\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect().then((pool) => {\n    return pool.query(query)\n  })\n}\n\n```\n\nHere we obtain the global connection pool by running `sql.connect()` and we then run the query against the pool.\nWe also do *not* close the pool after the query is executed and that is because other queries may need to be run against\nthis pool and closing it will add an overhead to running the query. We should only ever close the pool when our application\nis finished. For example, if we are running some kind of CLI tool or a CRON job:\n\n```js\nconst sql = require('mssql')\n\n(() => {\n  sql.connect().then(pool => {\n    return pool.query('SELECT 1')\n  }).then(result => {\n    // do something with result\n  }).then(() => {\n    return sql.close()\n  })\n})()\n```\n\nHere the connection will be closed and the node process will exit once the queries and other application logic has completed.\nYou should aim to only close the pool once in your application, when it is exiting or you know your application will never make\nanother SQL query.\n\n### Advanced Pool Management\n\nIn some instances you will not want to use the connection pool, you may have multiple databases to connect to or you may have\none pool for read-only operations and another pool for read-write. In this instance you will need to implement your own pool\nmanagement.\n\nThat could look something like this:\n\n```js\nconst { ConnectionPool } = require('mssql')\nconst POOLS = {}\n\nfunction createPool(config, name) {\n  if (getPool(name)) {\n    return Promise.reject(new Error('Pool with this name already exists'))\n  }\n  return (new ConnectionPool(config)).connect().then((pool) => {\n    return POOLS[name] = pool\n  })\n}\n\nfunction closePool(name) {\n  const pool = getPool(name)\n  if (pool) {\n    delete POOLS[name]\n    return pool.close()\n  }\n  return Promise.resolve()\n}\n\nfunction getPool(name) {\n  if (Object.prototype.hasOwnProperty.apply(POOLS, name)) {\n    return POOLS[name]\n  }\n}\n\nmodule.exports = {\n  closePool,\n  createPool,\n  getPool\n}\n```\n\nThis helper file can then be used in your application to create, fetch and close your pools. As with the global pools, you\nshould aim to only close a pool when you know it will never be needed by the application again; typically this will be when\nyour application is shutting down.\n\n## Connection Pools\n\nUsing a single connection pool for your application/service is recommended.\nInstantiating a pool with a callback, or immediately calling `.connect`, is asynchronous to ensure a connection can be\nestablished before returning. From that point, you're able to acquire connections as normal:  \n\n```javascript\nconst sql = require('mssql')\n\n// async/await style:\nconst pool1 = new sql.ConnectionPool(config);\nconst pool1Connect = pool1.connect();\n\npool1.on('error', err => {\n    // ... error handler\n})\n\nasync function messageHandler() {\n    await pool1Connect; // ensures that the pool has been created\n    try {\n        const request = pool1.request(); // or: new sql.Request(pool1)\n        const result = await request.query('select 1 as number')\n        console.dir(result)\n        return result;\n    } catch (err) {\n        console.error('SQL error', err);\n    }\n}\n\n// promise style:\nconst pool2 = new sql.ConnectionPool(config)\nconst pool2Connect = pool2.connect()\n\npool2.on('error', err => {\n    // ... error handler\n})\n\nfunction runStoredProcedure() {\n    return pool2Connect.then((pool) => {\n        pool.request() // or: new sql.Request(pool2)\n        .input('input_parameter', sql.Int, 10)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name', (err, result) => {\n            // ... error checks\n            console.dir(result)\n        })\n    }).catch(err => {\n        // ... error handler\n    })\n}\n```\n\nAwaiting or `.then`ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it\nis needed first. In practice, once the pool is created then there will be no delay for the next operation.\n\nAs of v6.1.0 you can make repeat calls to `ConnectionPool.connect()` and `ConnectonPool.close()` without an error being\nthrown, allowing for the safe use of `mssql.connect().then(...)` throughout your code as well as making multiple calls to\nclose when your application is shutting down.\n\nThe ability to call `connect()` repeatedly is intended to make pool management easier, however it is still recommended\nto follow the example above where `connect()` is called once and using the original resolved connection promise.\nRepeatedly calling `connect()` when running queries risks running into problems when `close()` is called on the pool.\n\n**ES6 Tagged template literals**\n\n```javascript\nnew sql.ConnectionPool(config).connect().then(pool => {\n    return pool.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nAll values are automatically sanitized against sql injection.\n\n### Managing connection pools\n\nMost applications will only need a single `ConnectionPool` that can be shared throughout the code. To aid the sharing\nof a single pool this library exposes a set of functions to access a single global connection. eg:\n\n```js\n// as part of your application's boot process\n\nconst sql = require('mssql')\nconst poolPromise = sql.connect()\n\n// during your applications runtime\n\npoolPromise.then(() => {\n  return sql.query('SELECT 1')\n}).then(result => {\n  console.dir(result)\n})\n\n// when your application exits\npoolPromise.then(() => {\n  return sql.close()\n})\n```\n\nIf you require multiple pools per application (perhaps you have many DBs you need to connect to or you want a read-only\npool), then you will need to manage your pools yourself. The best way to do this is to create a shared library file that\ncan hold references to the pools for you. For example:\n\n```js\nconst sql = require('mssql')\n\nconst pools = {}\n\n// manage a set of pools by name (config will be required to create the pool)\n// a pool will be removed when it is closed\nasync function getPool(name, config) {\n  if (!Object.prototype.hasOwnProperty.call(pools, name)) {\n    const pool = new sql.ConnectionPool(config)\n    const close = pool.close.bind(pool)\n    pool.close = (...args) => {\n      delete pools[name]\n      return close(...args)\n    }\n    await pool.connect()\n    pools[name] = pool\n  }\n  return pools[name]\n}\n\n// close all pools\nfunction closeAll() {\n  return Promise.all(Object.values(pools).map((pool) => {\n    return pool.close()\n  }))\n}\n\nmodule.exports = {\n  closeAll,\n  getPool\n}\n```\n\nYou can then use this library file in your code to get a connected pool when you need it:\n\n```js\nconst { getPool } = require('./path/to/file')\n\n// run a query\nasync function runQuery(query, config) {\n  // pool will always be connected when the promise has resolved - may reject if the connection config is invalid\n  const pool = await getPool('default', config)\n  const result = await pool.request().query(query)\n  return result\n}\n```\n\n## Configuration\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Connection strings are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\n**Authentication:**\n\nOn top of the extra options, an `authentication` property can be added to the pool config option\n\n- **authentication** - An object with authentication settings, according to the [Tedious Documentation](https://tediousjs.github.io/tedious/api-connection.html). Passing this object will override `user`, `password`, `domain` settings.\n- **authentication.type** - Type of the authentication method, valid types are `default`, `ntlm`, `azure-active-directory-password`, `azure-active-directory-access-token`, `azure-active-directory-msi-vm`, or `azure-active-directory-msi-app-service`\n- **authentication.options** - Options of the authentication required by the `tedious` driver, depends on `authentication.type`. For more details, check [Tedious Authentication Interfaces](https://github.com/tediousjs/tedious/blob/v11.1.1/src/connection.ts#L200-L318)\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js v10+ or newer. Windows 32-64 bits or Linux/macOS 64 bits only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8@^2`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\nNote: If you use import into your lib to prepare your request (`const { VarChar } = require('mssql')`) you also need to upgrade all your types import into your code (`const { VarChar } = require('mssql/msnodesqlv8')`) or a `connection.on is not a function` error will be thrown.\n\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nPlease note that the connection string with this driver is not the same than tedious and use yes/no instead of true/false. You can see more on the [ODBC](https://docs.microsoft.com/fr-fr/dotnet/api/system.data.odbc.odbcconnection.connectionstring?view=dotnet-plat-ext-5.0) documentation.\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### toReadableStream\n\nConvert request to a Node.js ReadableStream\n\n__Example__\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream()\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\nOR if you wanted to increase the highWaterMark of the read stream to buffer more rows in memory\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream({ highWaterMark: 100 })\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nBefore you can start using CLI, you must install `mssql` globally with `npm install mssql -g`. Once you do that you will be able to execute `mssql` command.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n## Geography and Geometry\n\nnode-mssql has built-in deserializer for Geography and Geometry CLR data types.\n\n### Geography\n\nGeography types can be constructed several different ways. Refer carefully to documentation to verify the coordinate ordering; the ST methods tend to order parameters as longitude (x) then latitude (y), while custom CLR methods tend to prefer to order them as latitude (y) then longitude (x).\n\nThe query:\n\n```sql\nselect geography::STGeomFromText(N'POLYGON((1 1, 3 1, 3 1, 1 1))',4326)\n```\n\nresults in:\n\n```javascript\n{\n  srid: 4326,\n  version: 2,\n  points: [\n    Point { lat: 1, lng: 1, z: null, m: null },\n    Point { lat: 1, lng: 3, z: null, m: null },\n    Point { lat: 1, lng: 3, z: null, m: null },\n    Point { lat: 1, lng: 1, z: null, m: null }\n  ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 3 } ],\n  segments: []\n}\n```\n\n**NOTE:** You will also see `x` and `y` coordinates in parsed Geography points,\nthey are not recommended for use. They have thus been omitted from this example.\nFor compatibility, they remain flipped (x, the horizontal offset, is instead used for latitude, the vertical), and thus risk misleading you.\nPrefer instead to use the `lat` and `lng` properties.\n\n### Geometry\n\nGeometry types can also be constructed in several ways. Unlike Geographies, they are consistent in always placing x before y. node-mssql decodes the result of this query:\n\n```sql\nselect geometry::STGeomFromText(N'POLYGON((1 1, 3 1, 3 7, 1 1))',4326)\n```\n\ninto the JavaScript object:\n\n```javascript\n{\n  srid: 4326,\n  version: 1,\n  points: [\n    Point { x: 1, y: 1, z: null, m: null },\n    Point { x: 1, y: 3, z: null, m: null },\n    Point { x: 7, y: 3, z: null, m: null },\n    Point { x: 1, y: 1, z: null, m: null }\n  ],\n  figures: [ { attribute: 2, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 3 } ],\n  segments: []\n}\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n## Response Schema\n\nAn object returned from a `sucessful` basic query would look like the following.\n```javascript\n{\n\trecordsets: [\n\t\t[\n\t\t\t{\n\t\t\t\tCOL1: \"some content\",\n\t\t\t\tCOL2: \"some more content\"\n\t\t\t}\n\t\t]\n\t],\n\trecordset: [\n\t\t{\n\t\t\tCOL1: \"some content\",\n\t\t\tCOL2: \"some more content\"\n\t\t}\n\t],\n\toutput: {},\n\trowsAffected: [1]\n}\n\n```\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\nIn addition to the rowsAffected attribute on the done event, each statement will emit the number of affected rows as it is completed.\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('rowsaffected', rowCount => {\n    console.log(rowCount)\n})\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested. \n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n## 6.x to 7.x changes\n\n- Upgraded tedious version to v11\n- Upgraded msnodesqlv8 version support to v2\n- Upgraded tarn.js version to v3\n- Requests in stream mode that pipe into other streams no longer pass errors up the stream chain\n- Request.pipe now pipes a true node stream for better support of backpressure\n- tedious config option `trustServerCertificate` defaults to `false` if not supplied\n- Dropped support for Node < 10\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[travis-image]: https://img.shields.io/travis/tediousjs/node-mssql/master.svg?style=flat-square&label=unit\n[travis-url]: https://travis-ci.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=10"},"gitHead":"179953c79c40b9c63db5752fba6b4045d38676f1","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.16","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.19.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.1","debug":"^4.3.3","tedious":"^11.4.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^8.4.0","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_7.3.5_1653668817905_0.21816743092411506","host":"s3://npm-registry-packages"}},"8.1.2":{"name":"mssql","version":"8.1.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@8.1.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"dff6f0cd3fce403bf6d06eaf83578adbe6aab325","tarball":"https://registry.npmjs.org/mssql/-/mssql-8.1.2.tgz","fileCount":34,"integrity":"sha512-xkTw3Sp1Jpq2f7CG3rFQn6YK4XZbnL8HfZhaB/KRC/hjDZlJB3pSWYN2Cp/WwxIeA1iUJkdFa6GTfdMY8+DAjg==","signatures":[{"sig":"MEYCIQDPp05nhl98Q8TrjXYHhiIzVRQLCk7/GRuBoWXIZ8pnbgIhAL2mRyFY2/KIYc7QJZEpeIX0QJsavs2J9NHolV1lpoFx","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":255859,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJikPytACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmrtaA/7BpLw+t6wJz5VYMEE9xrormBZIQZ1WRmRWRctZiIccsO60n6d\r\nEUIp/mgRYRiwKj3gMyamznRvDxdhtzumjEuPP3iaQRap4cQ3s8yajowFXc5s\r\n1VtvY+DUasfMriWFsSLIIHZ9qfSORfOm7sjSbrgpt682ZlQpS6pAv49aJflI\r\nVpR9I/FS5KicghpluY5G6P87elvrRbtz+etxoiQKUEF2d4ViQ3hqA3oouy9J\r\n76hA5JZNNTLSaCfFrf7mJo3A9e8e/SyKcsW4mWZN5Oq783uugbb25lh2JA1a\r\ncyuBLfoh0FsVteB8JZHQoFIKT1lV15nBpYA/aR/FqQcMP8Fg75jIoOqVf7Pk\r\n1FctIlPpNhmxpDm0obfjdxhb5FL7KEGieZ/bJWpQF/qJv02MXwP2wV05BVi6\r\nTwcpyYcjD61YBcCiB3JToWv0d9Hy4fclAdhHdzdewzPhPRgRF2MXFVDR+hCM\r\nfxvi5GFmYZt5/BRVjTgfwhh1EoCT2ZHT9T/Fbp4heBB+5uSdCgw9WiNR6wm0\r\naYVBd4OWpJnrxPOaM3QtOb2ojdi1DqRXG9ZE74CeRDTN0j8Nuwj2YEp50n4u\r\nUCpAO7Hv9xvqeOyYHHXU/pS3Pr3FGzvJ0NywF9ZD4Nhm79Bisy2cypCf3mL4\r\nkUfGNyB+2wf3VWgskhLS2eAHsSI4clFrcYM=\r\n=5/KX\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"b9382d425726ecdaf29972e20e1c0e115cbd8856","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.16","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.19.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^14.0.0","commander":"^9.1.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^9.1.3","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_8.1.2_1653669036902_0.2099833873919461","host":"s3://npm-registry-packages"}},"8.1.3":{"name":"mssql","version":"8.1.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@8.1.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"7b63173c7afd75a9eaafeeeed98f8b973996aa13","tarball":"https://registry.npmjs.org/mssql/-/mssql-8.1.3.tgz","fileCount":34,"integrity":"sha512-XGxNNNeKZMMTM71na2M4eLMkPWKckcfZtMiCKR1mLzN887x31NisekNhoBAoRpqizErUZxSW8gSDZc8PVig7Kw==","signatures":[{"sig":"MEUCIQCY+PnB9a3Yu2XKBe87hQr+HpN4lwploxcahL7M6Y6+zAIgYDF5i2kpXoW00vQKApuq37tX4qbGpZXmrv11xx81nk4=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":256568,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi8TG1ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoDmQ/+IN2nHAP4wZvgQyxJzp4LGoX+kSHexVblYA8jkp4G4qxgLDmf\r\nPf+nAvTEU4t289bl9NHkNvr8eruIxY+uf7FHcnVt2Ly774r2yws1pLpQoJJC\r\n9ph3u8m12CnTlaWMa/nD8xz9H30OKNwhbHbKNyFVhG9M/oJAf8z5IEoXpFXO\r\nkiCWMBxGGQ2xtX5h3VCbmIx0bOiIbucTZWceGFWsAnXXnVOVe0313sP0WQCb\r\nop+wrFCKBZiJxFIscwms6u91PNHx83TkZUL+qcrrrAdVuWJgUANM+tyR5sZi\r\nEsJ5ErwZDTeX2dwccRb8GpnvA6SRocg/FMS/x9JjOixTp/QR+b+qkLe16r2j\r\nuuDgPfYL2AvPh8JCBxq2svSfE05Mmj/gEYnGiXRizFnTqWp4CO8rW2FcoBS/\r\nfWFTbGALx0skwgtYVrf+ErBDrjJkygY17auFdcgW5ceNdjN+iPnbMx4FlxJl\r\nbYBMnUZqcmIuOiyaexb3N+9WoynIQYcLbI+YEQIijxzqPHXbwhdmijIAsnTr\r\nnIiFbbTL3vUSTGp5C3UJGV1E2nQ8mW4vpiyJo4r/dIcWbYt22965tqlboO+h\r\nXUns25zc/Rf7Hgw8lqf8GT1dND2W3LkA6iBSr3vuToKj+V6rgzsDbIwJx1Hx\r\nDFrc6uFdV28VKwBirGlVNqEp6YArTLswJGw=\r\n=NerI\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"9c9e6caf00ba679e61efe9692348ef09019a2ea1","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.17","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.19.3","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^14.0.0","commander":"^9.1.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^9.1.3","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_8.1.3_1659974069520_0.11454285935514363","host":"s3://npm-registry-packages"}},"9.0.0":{"name":"mssql","version":"9.0.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@9.0.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"c2ea64777ea16a0cf0448dcc862f42a02c429acd","tarball":"https://registry.npmjs.org/mssql/-/mssql-9.0.0.tgz","fileCount":34,"integrity":"sha512-jXRPdQ5GOv0HLLhilmb0gIffzhpIPbFEzEn/5BBk4kcii16cliEWiMwSFiCgqPridQRVGv6NsGWzyQq3IraRcw==","signatures":[{"sig":"MEUCIQCPPIG0WBmY5Q/iw4VJqosVtWyYMngOkJfvo5bYTvFh4QIgVhaRgJ29CeJwKoqfxzLzT0scPKOzW0dYWxREIP6PpRI=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":257095,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi8tsVACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmp6WQ//YN6hZC83+lHtfYKbdy25/llWknN+Dgwc5fLm2qJEdfKovk9/\r\nisvFoSExI+HjCkY11u5V1yMiizmILASs+dbbHsvs0uaaycbh/z5mNkcLKsjx\r\nd3sS5dWytpLDV9UNlm0jYK/xH/DhAujoVFpKmo3K3bvqko0+njFHdhVKXjpo\r\nWo1wTzAOTOpVxgESFGt/9h6McJe8xTitV7ZtmydAT5HLu0KUsfkqfm76eKkr\r\nlEOTkreQoZ0Oy27Dty0LSRIyBrEywFeRGDxR/5mqCzrVnsoP11Frp8y2Yp7b\r\ngwAl3VzDiVoky4gDrmdlGDPGTI1To1M8WE+ha2XWAEnJYP2BwFMBSUJzpDTk\r\nMD9m4XR1WwWJQZlOBUgocXv/BtIeKNjPXNBEvj963S1/R6w1nWwA0+azmDIW\r\n9B56rj7O9SomSNHuQL4oV+XKp4sG/voXqzepm4YsqaU1wY2ITNe6seiEJACx\r\nNTesychrzD8lAD5rdB2errL5VZ3vLNZoD9f0h7TayMsgGLpX2Oo0PjIjiqzC\r\nLawW7XZwZefjMEjR8zC8Qe64DaFZEotTjOTl5mofR4i8krHtYgTj6KAyrMm6\r\nJPZ78EMps9YqRW9zpFNcD1n8AEaez2NC6YzqWToPQqxlhNmQe0n8Caq8bkeM\r\n3x+9wuLB4m4g/WFXTyenM6+ifEL9bbAtNs4=\r\n=s2jP\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"54ad59b14446fda636c2e726f7660b30c6419912","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.16","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.19.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^15.0.1","commander":"^9.4.0","@tediousjs/connection-string":"^0.4.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0"},"_npmOperationalInternal":{"tmp":"tmp/mssql_9.0.0_1660082964834_0.5248434257472789","host":"s3://npm-registry-packages"}},"8.1.4":{"name":"mssql","version":"8.1.4","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@8.1.4","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"5eca0b515b3a0dc878f380460315fc8f73c40d80","tarball":"https://registry.npmjs.org/mssql/-/mssql-8.1.4.tgz","fileCount":34,"integrity":"sha512-nqkYYehETWVvFLB9zAGJV2kegOsdtLjUnkHA52aFhlE0ZIoOXC3BL8pLERwFicFypM4i3DX1hYeuM726EEIxjQ==","signatures":[{"sig":"MEUCIB5hqazzKnXXZ172R5dLuePVtWFqTBIpvIYWdWeX3pISAiEApTJl9yEvdYMNXaROJgu1w2dkS+wyUizoY796nP8m1EM=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":257067,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi/lzGACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmoLig//XZzPAEibdwiKKxPKK6jkH/o2ZEou8PIfTzd7dvvV/eIlNCSi\r\nH3NGf93BEbAp34JVsObYhM+Ara5fcUY2bcCzSD04zZqKpI/E4fLddIRO9Zil\r\nHWM9eka5gX59dfXcZB8+2suL7VCBO3rIfHCsKBaxZtK52VWmjIUqKW08IEj0\r\noGKBApy56zdUAo2fo070Gn9HOV5V8+Ex84OdQhqHDCyMOIX5ogTiGmU5sawB\r\njzSCPHmEK+sYbl4x+gk2djhgtWEQzbTw0o4QpbT7IDKUVjMy4UpoFIDlM8X2\r\nNq+ngfD/1OPUKZ9V3WLxH6H3DHEOBigfHenXDeNu3PnEDzfyZNxt92/e7bye\r\nWjlwTWrPP6X1XsiRc0Vg2tUYmtS6AIf6PYGd+xrb1O25YlBR7f4/oWPt0wew\r\n1SsMItNdmbTVDWChvOSdYy0kHpb80b5gZ2z1hfITQCCmErlUk9hxi063cWHx\r\n+krBrKFcrlHP99sZqsBkPvuxVrw4GBwU7UiDRCLCzaFjakOCGZcY1bpspSHh\r\nRcq+uutOoxShlHdTUtIdn1NY5lThpFMbGe4MxYkdGnwqp7bf+t+GlkGGcD6S\r\n75y6Xhli/4L7UmrmuRtdsDyqXbupIvsoQSQRRifr6WhKPGP3x641+7cLwWjX\r\npjpDjghvF8ZiU9D82X5le7ilTaSXiz7ORGk=\r\n=OsKI\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"c5c88b311f5bccf55f9bd5e76e09d25b0669f89a","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.16","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.19.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^14.0.0","commander":"^9.1.0","@tediousjs/connection-string":"^0.3.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^9.1.3","standard":"^16.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_8.1.4_1660837062067_0.11911048430309767","host":"s3://npm-registry-packages"}},"9.0.1":{"name":"mssql","version":"9.0.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@9.0.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"9a311388229e5d596bfbda616e535b9a63241d69","tarball":"https://registry.npmjs.org/mssql/-/mssql-9.0.1.tgz","fileCount":34,"integrity":"sha512-rmBEPeUgZswvcclSc4s21WJCG0xqDYBas1MSnZepzDPvtNRgkx6f/gCm52EEo2djVtIXJgRq22m7gj7floz4Ng==","signatures":[{"sig":"MEQCIGbQeWyEQmxjGPvogDnPE/tbQxk504qKfJqF/u19No6zAiBOwcBqBBm7JPRSPtqQaWmksBOTY6DloKUhjz1roavnww==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":257447,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJi/lzRACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2VmqApg/7BkAYyxp9O38Aneg3YbZCixUpU3wDY0j8CbuFRIwpih49RCu6\r\nFH+s3l6vkg7Qg6CqrzVaT9MT0VqE/vlRvlMyqBW5k9zgf24Vdu+iSZnvJKET\r\nJgz1NFHxyL66wdKoN9GLjyWYjKqU57P6OTxDX4tODRiA3i31Vvsw90c4KFhN\r\nYypg8khsD7fakZK8is6D2i+3rkrQjRsWV9tCbL0YRLs8IRrM0mH3eq0uQAzq\r\npVwaCvzs1XlnzZPOzADxDFyB1fg/RghRrPQOIpiL61G5YVrr5uJAsZcBuGLU\r\nNuGV6DkqSFW846js5BA3VZg77L6Tp9kB/8vOa8SyWa5qHWGKx+ZYQ6/ZdgxD\r\nH67a7d2f9nqv/UpRc4yz6LF9LAsqKSLDatYXjHsC32/x8A/VQhmRnnkfifnA\r\nyI31x1N/XlUpTUFFk5dxynnEzikQ2bism4YkpFD17k84SPQeMLaXwYwvEPdJ\r\nDniAmlKhL39jDxPaL3pcJHHevH5C7fdo1F7ln/mAT326bFOZtRMh7/fNOfik\r\nGm806Xiu5e0ONJEezshGN/j+EIFwaSS+2faaP227fGQ+/jby7lO/iiZoTiWn\r\nEduYjhyziH0BT70FjlGdsYEYPCmY2n0WxlmbuTdep/a13vAfImmPD5V6x+Ba\r\nbSafdq15V24DMGa/YvadjtVTRnUlVP8xisk=\r\n=3UHY\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"c40b64a552bf9cfdedd72b9413793e40e2d581b7","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.16","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.19.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^15.0.1","commander":"^9.4.0","@tediousjs/connection-string":"^0.4.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0"},"_npmOperationalInternal":{"tmp":"tmp/mssql_9.0.1_1660837073226_0.5046765247235083","host":"s3://npm-registry-packages"}},"9.1.0":{"name":"mssql","version":"9.1.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@9.1.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"485bd4b0bf08e161c3c5440af8967ae8c3040e27","tarball":"https://registry.npmjs.org/mssql/-/mssql-9.1.0.tgz","fileCount":33,"integrity":"sha512-rAsD7xfOkzSUqmNMoWX9YT43QfxbabIbrhEuf/PGRCzhWCzwHf25jxNgaoAwqT7vcb5/1irDCi6l6DG05ZGEEQ==","signatures":[{"sig":"MEYCIQCSDeRqmtFmmpp7xPhBx7NbeDkM2v65ACb1qV6toy4xqwIhAIfq/Oxwjb8ENCypdetJ+V3LkUlqvmrPc/EOiWDGm+7I","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":230558,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjxne/ACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmq4ng/+PSw3sujM1+MN4G6ng32rZCLHBeQyMFab4YefU0hBnjXYxUa1\r\nAmdSQK7SSyaGLJ7ptGn72tp9MHG2aEydDcSQMy/OLCmcEUKdGJbDb08USvaM\r\nFG/aPyGejkt/8eAXutTvw8idUzmcmbSnr1PZgVxE1n5yLd+g9KoLBTv3bYum\r\nlJk3UVrvzMfRy1oS6+dQEvkDpzVLhUeGWj8+/hxUqZwzC5NWThwXaip0/0XT\r\n9q0QPHcUPei2LFOS9ovcWeAnhsSya/3UZgQ82MyDyN8WEWtquwQc4WWBlm4d\r\nXPkCd1yG8GfQl9NA+5u8PLw3MY2t2GdeCDIkLWONFt+sTHUurSfE81WKngCd\r\n/3l/NcfeWH7vlU5ytPPYs8bqAN9zIRVJjfhO+VFyAc/CyFAaZGlLgvS/PVqb\r\nSkWxNAKOnlDkIF0XVgyIfUNDdoX2NG4HnPYRjlkgyUWdddynuMuE+FqHw0Xj\r\nus9wn4VnNyt9+1TUPDWJIPCcRzwYsOs84pC9KF6WZx9G970E+WYJHwhT1QaQ\r\n6C56IsEQgqhN5qHBSGGobeIyhFkGoyg3E9EbC/JchAGcOVNqwKrU2S7qD0TN\r\niyAKg16kDtS91U2EnHGx777iUigpIhHf33IdWBn+gG1xjKeu+jkrvNPxAz/T\r\nLW/ro4fHgIFJPwFJKMDtxvh+7XMBljZuK9o=\r\n=7IKE\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"ab79c868f8c4eff68e6a6cea932715d621c00fcc","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"8.19.3","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"16.19.0","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^15.0.1","commander":"^9.4.0","@tediousjs/connection-string":"^0.4.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0"},"_npmOperationalInternal":{"tmp":"tmp/mssql_9.1.0_1673951166880_0.46577122426305406","host":"s3://npm-registry-packages"}},"9.1.1":{"name":"mssql","version":"9.1.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@9.1.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"fcec595834db1ff6e446710794f54082fc74ef02","tarball":"https://registry.npmjs.org/mssql/-/mssql-9.1.1.tgz","fileCount":33,"integrity":"sha512-m0yTx9xzUtTvJpWJHqknUXUDPRnJXZYOOFNygnNIXn1PBkLsC/rkXQdquObd+M0ZPlBhGC00Jg28zG0wCl7VWg==","signatures":[{"sig":"MEYCIQDhrnWSiTwpW738bG5BVE99ADcs8yBUVIPHSPt6PP+FagIhAK9zzW1JeXHES+r/iz0aWFJgAaLRClFjoxBww0w0tqCO","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":228807,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjyH7HACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmr7+g//ekzLmZX/pnSuNXGfmzfBkbecvHOaMkv0LMXtzSRKCZMh0QOQ\r\npqnYYxleXUQ0N43BcFfSS3vjowMh8CJd1sP1orrSf+GTKClfTD/YMb3YKApz\r\n3U7N4V0yuuBn/z99tBVGtOElyAWAOK+C4HCJbZfbEdaiD+yg/P1gc0Rg0vyB\r\nljLHkODAia00byJ/4OaC8kuicihCms1In7aaoMNJFSaR81jgGqR840kjEZLd\r\n81JS9/bcrdVQ8Ibs/pvb79kU41QuTVerXlL5OaUNhbJ57Q2qSWaPmop+a/1v\r\nUtGpZMdhjRlDejMaHRnXQ/CNNIt2TWvlfNs+rQG/Q4g7ZfWLG5USt6X4XpR+\r\ndypQ0K6/0J9vgagSRMCoyiRyWWiF1a2t3DjlcIDWtKK01KpNP22Dla7lTr+s\r\nvbZhREwB0qqr7VijrIkvdlxSkXBHEuk+FvqTlA4L2qQ14jxLatx+EpfggxJh\r\n2lUBO6UiIuxtbt6vxcS/n7VAxQ2aXQ7TYoVi1PoOj4D1jG7fsZmNh2NJ51Oj\r\nR4r0hckGwxdn88R7M+foQ35/VN258UWzyrKWl6rYClMWgTxsq6UqR15U6V+4\r\nhMDzefmpwO/lOz+1Eu4n5grPq+QkyJKU3w8yHcrl41dQTeAkvUViVqep/AKd\r\nFTrB9Chks/Vuv5gqL3OTrzsPHxXJLiNQuu4=\r\n=FIVH\r\n-----END PGP SIGNATURE-----\r\n"},"main":"index.js","engines":{"node":">=10"},"gitHead":"1b12250d20f4df9168a9f96ce6c8bf46888ba390","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 15000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"8.19.3","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"16.19.0","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^15.0.1","commander":"^9.4.0","@tediousjs/connection-string":"^0.4.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0"},"_npmOperationalInternal":{"tmp":"tmp/mssql_9.1.1_1674084039231_0.47886028577424655","host":"s3://npm-registry-packages"}},"9.1.2":{"name":"mssql","version":"9.1.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@9.1.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"fec75be73c4807fb50e0889f8908d440aba64323","tarball":"https://registry.npmjs.org/mssql/-/mssql-9.1.2.tgz","fileCount":34,"integrity":"sha512-AIkCi6env4EoGNkD9BCMiAngaTiaq434wWqhILFKeBZOzGsJWbr7j4Cc+jgZG6wcKeVXiOmfoxEOnCTYDcsYeg==","signatures":[{"sig":"MEQCIGT9WqTCpUJKcI5BGaVLNKkB9WJoKApesOuwVQzgLC8kAiBHhmufpFx6RX130T8zrJJ0vv/lnc5ndzryfZnqBwMmqg==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":258961},"main":"index.js","engines":{"node":">=10"},"gitHead":"73d6861516d62dd2284a6f6f270b6e12e91c2932","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"6.14.18","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"14.21.3","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^15.0.1","commander":"^11.0.0","@tediousjs/connection-string":"^0.4.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^17.6.6","semantic-release":"^21.0.7","@semantic-release/npm":"^10.0.4","@semantic-release/github":"^9.0.3","@commitlint/config-conventional":"^17.6.6","@semantic-release/commit-analyzer":"^10.0.1","@semantic-release/release-notes-generator":"^11.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_9.1.2_1690990741022_0.8385418577091461","host":"s3://npm-registry-packages"}},"9.1.3":{"name":"mssql","version":"9.1.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@9.1.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"97b8e8cf3cef107a46799b737bf8b9d6993f9ebb","tarball":"https://registry.npmjs.org/mssql/-/mssql-9.1.3.tgz","fileCount":33,"integrity":"sha512-oXs2lJ1vKUe2s0twCdcdKnqATTVaIswzpSiGnUjMIhV6Sip9vEDuYt3dCoVWXXNuPJ5iFIqLxvagw4Hrz6xR4A==","signatures":[{"sig":"MEYCIQD46NlDlGZLrKZaOpLP6K1yPNaRG98y2x8fiqNSlVtWyQIhAMuCXdWoR9QqX/wmxMRuFtXt7FnxfYM6wbx6jm5TsHs3","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@9.1.3","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":230042},"main":"index.js","engines":{"node":">=10"},"gitHead":"fdf7b1760652845ce90575ee8b3a87e9a5bc9185","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"9.8.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"18.17.0","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^15.0.1","commander":"^11.0.0","@tediousjs/connection-string":"^0.4.1"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^17.6.6","semantic-release":"^21.0.7","@semantic-release/npm":"^10.0.4","@semantic-release/github":"^9.0.3","@commitlint/config-conventional":"^17.6.6","@semantic-release/commit-analyzer":"^10.0.1","@semantic-release/release-notes-generator":"^11.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_9.1.3_1691472967104_0.5535859936677672","host":"s3://npm-registry-packages"}},"9.2.0":{"name":"mssql","version":"9.2.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@9.2.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"a0f1e8ad010f66c2bc351281b767f37c57859c96","tarball":"https://registry.npmjs.org/mssql/-/mssql-9.2.0.tgz","fileCount":33,"integrity":"sha512-FxX/CTGLH+X5UHH0d4lUJzVGlIZlLoY/ZdFCVect4VwbfKtDtNZWG8vq9SEjVfduhtydVrE4K2y69JnDAYgXlw==","signatures":[{"sig":"MEUCIQDkOy//lH8VleMYG1p39L8iO04EaETvz87lG3x9XzL9QgIgTXTsZVaa8eWb5pUfSqrGF2yySEbFRyXl4BuOVFPBsIk=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@9.2.0","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":229106},"main":"index.js","engines":{"node":">=10"},"gitHead":"ed01abcadb1b03335802866978a8ce8f7eba7196","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"9.8.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"18.17.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^15.0.1","commander":"^11.0.0","@tediousjs/connection-string":"^0.5.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^17.6.6","semantic-release":"^21.0.7","@semantic-release/npm":"^10.0.4","@semantic-release/github":"^9.0.3","@commitlint/config-conventional":"^17.6.6","@semantic-release/commit-analyzer":"^10.0.1","@semantic-release/release-notes-generator":"^11.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_9.2.0_1693263596169_0.67083170160892","host":"s3://npm-registry-packages"}},"9.3.0":{"name":"mssql","version":"9.3.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@9.3.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"3da7f74bde3ee0f60e55b2cee71d580073410351","tarball":"https://registry.npmjs.org/mssql/-/mssql-9.3.0.tgz","fileCount":33,"integrity":"sha512-Eb79Ki+wEicK5/9MU8Lce0HSBepvcaHJkTktEsenmB44OZObKN1RuspoQP+fDnc6cn5SYSCy6od9cLhZ9DnXDw==","signatures":[{"sig":"MEUCIQDoxSmEoghQtjmYvgGpBLAhTGLC51YZZ3rhsbzCxiNNWAIgSTrYUUY7eck1FHMYKl1Js1jGRcznuUugUCYlKomvUAs=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@9.3.0","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":233721},"main":"index.js","engines":{"node":">=10"},"gitHead":"b5cf976c10ff509a610410383325b70c731c00bf","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"9.8.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"18.17.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^15.0.1","commander":"^11.0.0","@tediousjs/connection-string":"^0.5.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^17.6.6","semantic-release":"^21.0.7","@semantic-release/npm":"^10.0.4","@semantic-release/github":"^9.0.3","@commitlint/config-conventional":"^17.6.6","@semantic-release/commit-analyzer":"^10.0.1","@semantic-release/release-notes-generator":"^11.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_9.3.0_1693865963284_0.6392578556828199","host":"s3://npm-registry-packages"}},"9.2.1":{"name":"mssql","version":"9.2.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@9.2.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"b8423e6808c0185463201e2f06d89cb2edd972d7","tarball":"https://registry.npmjs.org/mssql/-/mssql-9.2.1.tgz","fileCount":33,"integrity":"sha512-GIknahzDkssJtE5l6bSrtRWtIdNJ1o3ggzrEbxZ84t+NM0mHQKRQPSDCET1JosK84Xw0oZrc7qY8I7mPVrcTeg==","signatures":[{"sig":"MEUCIQD8/64HiOPCOn/AuftVQ6wWOGi5B6XOa+tqP+MgeFZfyQIgfd3g8Fv2UoctFCBt5VIV/+pCXmJQOPJf/TVNjDyR4u0=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@9.2.1","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":229114},"main":"index.js","readme":"# node-mssql\n\nMicrosoft SQL Server client for Node.js\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server][msnodesqlv8-url] (v2 native - Windows or Linux/macOS 64 bits only)\n\n## Installation\n\n    npm install mssql\n\n## Short Example: Use Connect String\n\n```javascript\nconst sql = require('mssql')\n\nasync () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('Server=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n}\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Longer Example: Connect via Config Object\n\nAssuming you have set the appropriate environment variables, you can construct a config object as follows:\n\n```javascript\nconst sql = require('mssql')\nconst sqlConfig = {\n  user: process.env.DB_USER,\n  password: process.env.DB_PWD,\n  database: process.env.DB_NAME,\n  server: 'localhost',\n  pool: {\n    max: 10,\n    min: 0,\n    idleTimeoutMillis: 30000\n  },\n  options: {\n    encrypt: true, // for azure\n    trustServerCertificate: false // change to true for local dev / self-signed certs\n  }\n}\n\nasync () => {\n try {\n  // make sure that any items are correctly URL encoded in the connection string\n  await sql.connect(sqlConfig)\n  const result = await sql.query`select * from mytable where id = ${value}`\n  console.dir(result)\n } catch (err) {\n  // ... error checks\n }\n}\n```\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [Microsoft / Contributors Node V8 Driver for Node.js for SQL Server](#microsoft--contributors-node-v8-driver-for-nodejs-for-sql-server)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [toReadableStream](#toReadableStream)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Response Schema](#response-schema)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [8.x to 9.x changes](#8x-to-9x-changes)\n* [7.x to 8.x changes](#7x-to-8x-changes)\n* [6.x to 7.x changes](#6x-to-7x-changes)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n            \n        console.dir(result1)\n    \n        // Stored procedure\n        \n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n        \n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    \n    // Stored procedure\n    \n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection. \nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('rowsaffected', rowCount => {\n        // Emitted for each `INSERT`, `UPDATE` or `DELETE` statement\n        // Requires NOCOUNT to be OFF (default)\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool) as this library uses connection pooling extensively. As one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process to create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand how the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection Pool\n\nTo assist with pool management in your application there is the `sql.connect()` function that is used to connect to the global connection pool. You can make repeated calls to this function, and if the global pool is already connected, it will resolve to the connected pool. The following example obtains the global connection pool by running `sql.connect()`, and then runs the query against the pool.\n\nNB: It's important to note that there can only be one global connection pool connected at a time. Providing a different connection config to the `connect()` function will not create a new connection if it is already connected.\n\n```js\nconst sql = require('mssql')\nconst config = { ... }\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect(config).then((pool) => {\n    return pool.query(query)\n  })\n}\n```\n\nAwaiting or `.then`-ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it is needed first. In practice, once the pool is created then there will be no delay for the next `connect()` call.\n\nAlso notice that we do *not* close the global pool by calling `sql.close()` after the query is executed, because other queries may need to be run against this pool and closing it will add additional overhead to running subsequent queries. You should only ever close the global pool if you're certain the application is finished. Or for example, if you are running some kind of CLI tool or a CRON job you can close the pool at the end of the script.\n\n### Global Pool Single Instance\n\nThe ability to call `connect()` and `close()` repeatedly on the global pool is intended to make pool management easier, however it is better to maintain your own reference to the pool, where `connect()` is called **once**, and the resulting global pool's connection promise is re-used throughout the entire application.\n\nFor example, in Express applications, the following approach uses a single global pool instance added to the `app.locals` so the application has access to it when needed. The server start is then chained inside the `connect()` promise.\n\n```js\nconst express = require('express')\nconst sql = require('mssql')\nconst config  = {/*...*/}\n//instantiate a connection pool\nconst appPool = new sql.ConnectionPool(config)\n//require route handlers and use the same connection pool everywhere\nconst route1 = require('./routes/route1')\nconst app = express()\napp.get('/path', route1)\n\n//connect the pool and start the web server when done\nappPool.connect().then(function(pool) {\n  app.locals.db = pool;\n  const server = app.listen(3000, function () {\n    const host = server.address().address\n    const port = server.address().port\n    console.log('Example app listening at http://%s:%s', host, port)\n  })\n}).catch(function(err) {\n  console.error('Error creating connection pool', err)\n});\n```\n\nThen the route uses the connection pool in the `app.locals` object:\n\n```js\n// ./routes/route1.js\nconst sql = require('mssql');\n\nmodule.exports = function(req, res) {\n  req.app.locals.db.query('SELECT TOP 10 * FROM table_name', function(err, recordset) {\n    if (err) {\n      console.error(err)\n      res.status(500).send('SERVER ERROR')\n      return\n    }\n    res.status(200).json({ message: 'success' })\n  })\n}\n```\n\n### Advanced Pool Management\n\nFor some use-cases you may want to implement your own connection pool management, rather than using the global connection pool. Reasons for doing this include:\n\n* Supporting connections to multiple databases\n* Creation of separate pools for read vs read/write operations\n\nThe following code is an example of a custom connection pool implementation.\n\n```js\n// pool-manager.js\nconst mssql = require('mssql')\nconst pools = new Map();\n\nmodule.exports = {\n /**\n  * Get or create a pool. If a pool doesn't exist the config must be provided.\n  * If the pool does exist the config is ignored (even if it was different to the one provided\n  * when creating the pool)\n  *\n  * @param {string} name\n  * @param {{}} [config]\n  * @return {Promise.<mssql.ConnectionPool>}\n  */\n get: (name, config) => {\n  if (!pools.has(name)) {\n   if (!config) {\n    throw new Error('Pool does not exist');\n   }\n   const pool = new mssql.ConnectionPool(config);\n   // automatically remove the pool from the cache if `pool.close()` is called\n   const close = pool.close.bind(pool);\n   pool.close = (...args) => {\n    pools.delete(name);\n    return close(...args);\n   }\n   pools.set(name, pool.connect());\n  }\n  return pools.get(name);\n },\n /**\n  * Closes all the pools and removes them from the store\n  *\n  * @return {Promise<mssql.ConnectionPool[]>}\n  */\n closeAll: () => Promise.all(Array.from(pools.values()).map((connect) => {\n  return connect.then((pool) => pool.close());\n })),\n};\n```\n\nThis file can then be used in your application to create, fetch, and close pools.\n\n```js\nconst { get } = require('./pool-manager')\n\nasync function example() {\n  const pool = await get('default')\n  return pool.request().query('SELECT 1')\n}\n```\n\nSimilar to the global connection pool, you should aim to only close a pool when you know it will never be needed by the application again. Typically this will only be when your application is shutting down.\n\n### Result value manipulation\n\nIn some instances it is desirable to manipulate the record data as it is returned from the database, this may be to cast it as a particular object (eg: `moment` object instead of `Date`) or similar.\n\nIn v8.0.0+ it is possible to register per-datatype handlers:\n\n```js\nconst sql = require('mssql')\n\n// in this example all integer values will return 1 more than their actual value in the database\nsql.valueHandler.set(sql.TYPES.Int, (value) => value + 1)\n\nsql.query('SELECT * FROM [example]').then((result) => {\n  // all `int` columns will return a manipulated value as per the callback above\n})\n```\n\n## Configuration\n\nThe following is an example configuration object:\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. (default: `false`) See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Connection strings are supported.\n\n##### Classic Connection String\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\n**Authentication:**\n\nOn top of the extra options, an `authentication` property can be added to the pool config option\n\n- **authentication** - An object with authentication settings, according to the [Tedious Documentation](https://tediousjs.github.io/tedious/api-connection.html). Passing this object will override `user`, `password`, `domain` settings.\n- **authentication.type** - Type of the authentication method, valid types are `default`, `ntlm`, `azure-active-directory-password`, `azure-active-directory-access-token`, `azure-active-directory-msi-vm`, or `azure-active-directory-msi-app-service`\n- **authentication.options** - Options of the authentication required by the `tedious` driver, depends on `authentication.type`. For more details, check [Tedious Authentication Interfaces](https://github.com/tediousjs/tedious/blob/v11.1.1/src/connection.ts#L200-L318)\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n### Microsoft / Contributors Node V8 Driver for Node.js for SQL Server\n\n**Requires Node.js v10+ or newer. Windows 32-64 bits or Linux/macOS 64 bits only.** This driver is not part of the default package and must be installed separately by `npm install msnodesqlv8@^2`. To use this driver, use this require syntax: `const sql = require('mssql/msnodesqlv8')`.\n\nNote: If you use import into your lib to prepare your request (`const { VarChar } = require('mssql')`) you also need to upgrade all your types import into your code (`const { VarChar } = require('mssql/msnodesqlv8')`) or a `connection.on is not a function` error will be thrown.\n\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nPlease note that the connection string with this driver is not the same than tedious and use yes/no instead of true/false. You can see more on the [ODBC](https://docs.microsoft.com/fr-fr/dotnet/api/system.data.odbc.odbcconnection.connectionstring?view=dotnet-plat-ext-5.0) documentation.\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### toReadableStream\n\nConvert request to a Node.js ReadableStream\n\n__Example__\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream()\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\nOR if you wanted to increase the highWaterMark of the read stream to buffer more rows in memory\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream({ highWaterMark: 100 })\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n        \n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n        \n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nIf you want to add the MSSQL CLI tool to your path, you must install it globally with `npm install -g mssql`.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n__Overriding config settings__\n\nYou can override some config settings via CLI options (`--user`, `--password`, `--server`, `--database`, `--port`).\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config --database anotherdatabase\n```\nResults in:\n```json\n[[{\"username\":\"onotheruser\",\"password\":\"quiteeasy\"}]]\n```\n\n## Geography and Geometry\n\nnode-mssql has built-in deserializer for Geography and Geometry CLR data types.\n\n### Geography\n\nGeography types can be constructed several different ways. Refer carefully to documentation to verify the coordinate ordering; the ST methods tend to order parameters as longitude (x) then latitude (y), while custom CLR methods tend to prefer to order them as latitude (y) then longitude (x).\n\nThe query:\n\n```sql\nselect geography::STGeomFromText(N'POLYGON((1 1, 3 1, 3 1, 1 1))',4326)\n```\n\nresults in:\n\n```javascript\n{\n  srid: 4326,\n  version: 2,\n  points: [\n    Point { lat: 1, lng: 1, z: null, m: null },\n    Point { lat: 1, lng: 3, z: null, m: null },\n    Point { lat: 1, lng: 3, z: null, m: null },\n    Point { lat: 1, lng: 1, z: null, m: null }\n  ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 3 } ],\n  segments: []\n}\n```\n\n**NOTE:** You will also see `x` and `y` coordinates in parsed Geography points,\nthey are not recommended for use. They have thus been omitted from this example.\nFor compatibility, they remain flipped (x, the horizontal offset, is instead used for latitude, the vertical), and thus risk misleading you.\nPrefer instead to use the `lat` and `lng` properties.\n\n### Geometry\n\nGeometry types can also be constructed in several ways. Unlike Geographies, they are consistent in always placing x before y. node-mssql decodes the result of this query:\n\n```sql\nselect geometry::STGeomFromText(N'POLYGON((1 1, 3 1, 3 7, 1 1))',4326)\n```\n\ninto the JavaScript object:\n\n```javascript\n{\n  srid: 4326,\n  version: 1,\n  points: [\n    Point { x: 1, y: 1, z: null, m: null },\n    Point { x: 1, y: 3, z: null, m: null },\n    Point { x: 7, y: 3, z: null, m: null },\n    Point { x: 1, y: 1, z: null, m: null }\n  ],\n  figures: [ { attribute: 2, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 3 } ],\n  segments: []\n}\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\nYou can clear the table rows for easier batching by using `table.rows.clear()`\n\n```js\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\ntvp.rows.clear()\n```\n\n## Response Schema\n\nAn object returned from a `sucessful` basic query would look like the following.\n```javascript\n{\n\trecordsets: [\n\t\t[\n\t\t\t{\n\t\t\t\tCOL1: \"some content\",\n\t\t\t\tCOL2: \"some more content\"\n\t\t\t}\n\t\t]\n\t],\n\trecordset: [\n\t\t{\n\t\t\tCOL1: \"some content\",\n\t\t\tCOL2: \"some more content\"\n\t\t}\n\t],\n\toutput: {},\n\trowsAffected: [1]\n}\n\n```\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\nIn addition to the rowsAffected attribute on the done event, each statement will emit the number of affected rows as it is completed.\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('rowsaffected', rowCount => {\n    console.log(rowCount)\n})\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested. \n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        name: 'first',\n        length: 17,\n        type: [sql.Decimal],\n        scale: 4,\n        precision: 18,\n        nullable: true,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    },\n    second: {\n        index: 1,\n        name: 'second',\n        length: 4,\n        type: [sql.VarChar],\n        nullable: false,\n        caseSensitive: false\n        identity: false\n        readOnly: true\n    }\n}\n```\n\n## Data Types\n\nYou can define data types with length/precision/scale:\n\n```javascript\nrequest.input(\"name\", sql.VarChar, \"abc\")               // varchar(3)\nrequest.input(\"name\", sql.VarChar(50), \"abc\")           // varchar(50)\nrequest.input(\"name\", sql.VarChar(sql.MAX), \"abc\")      // varchar(MAX)\nrequest.output(\"name\", sql.VarChar)                     // varchar(8000)\nrequest.output(\"name\", sql.VarChar, \"abc\")              // varchar(3)\n\nrequest.input(\"name\", sql.Decimal, 155.33)              // decimal(18, 0)\nrequest.input(\"name\", sql.Decimal(10), 155.33)          // decimal(10, 0)\nrequest.input(\"name\", sql.Decimal(10, 2), 155.33)       // decimal(10, 2)\n\nrequest.input(\"name\", sql.DateTime2, new Date())        // datetime2(7)\nrequest.input(\"name\", sql.DateTime2(5), new Date())     // datetime2(5)\n```\n\nList of supported data types:\n\n```\nsql.Bit\nsql.BigInt\nsql.Decimal ([precision], [scale])\nsql.Float\nsql.Int\nsql.Money\nsql.Numeric ([precision], [scale])\nsql.SmallInt\nsql.SmallMoney\nsql.Real\nsql.TinyInt\n\nsql.Char ([length])\nsql.NChar ([length])\nsql.Text\nsql.NText\nsql.VarChar ([length])\nsql.NVarChar ([length])\nsql.Xml\n\nsql.Time ([scale])\nsql.Date\nsql.DateTime\nsql.DateTime2 ([scale])\nsql.DateTimeOffset ([scale])\nsql.SmallDateTime\n\nsql.UniqueIdentifier\n\nsql.Variant\n\nsql.Binary\nsql.VarBinary ([length])\nsql.Image\n\nsql.UDT\nsql.Geography\nsql.Geometry\n```\n\nTo setup MAX length for `VarChar`, `NVarChar` and `VarBinary` use `sql.MAX` length. Types `sql.XML` and `sql.Variant` are not supported as input parameters.\n\n## SQL injection\n\nThis module has built-in SQL injection protection. Always use parameters or tagged template literals to pass sanitized values to your queries.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('myval', sql.VarChar, '-- commented')\nrequest.query('select @myval as myval', (err, result) => {\n    console.dir(result)\n})\n```\n\n## Known issues\n\n### Tedious\n\n- If you're facing problems with connecting SQL Server 2000, try setting the default TDS version to 7.1 with `config.options.tdsVersion = '7_1'` ([issue](https://github.com/tediousjs/node-mssql/issues/36))\n- If you're executing a statement longer than 4000 chars on SQL Server 2000, always use [batch](#batch-batch-callback) instead of [query](#query-command-callback) ([issue](https://github.com/tediousjs/node-mssql/issues/68))\n\n## 8.x to 9.x changes\n\n- Upgraded to tedious version 15\n- Dropped support for Node version <= 12\n\n## 7.x to 8.x changes\n\n- Upgraded to tedious version 14\n- Removed internal library for connection string parsing. Connection strings can be resolved using the static method `parseConnectionString` on ConnectionPool\n\n## 6.x to 7.x changes\n\n- Upgraded tedious version to v11\n- Upgraded msnodesqlv8 version support to v2\n- Upgraded tarn.js version to v3\n- Requests in stream mode that pipe into other streams no longer pass errors up the stream chain\n- Request.pipe now pipes a true node stream for better support of backpressure\n- tedious config option `trustServerCertificate` defaults to `false` if not supplied\n- Dropped support for Node < 10\n\n## 5.x to 6.x changes\n\n- Upgraded `tarn.js` so `_poolDestroy` can take advantage of being a promise\n- `ConnectionPool.close()` now returns a promise / callbacks will be executed once closing of the pool is complete; you must make\nsure that connections are properly released back to the pool otherwise the pool may fail to close.\n- It is safe to pass read-only config objects to the library; config objects are now cloned\n- `options.encrypt` is now `true` by default\n- `TYPES.Null` has now been removed\n- Upgraded tedious driver to v6 and upgraded support for msnodesqlv8]\n- You can now close the global connection by reference and this will clean up the global connection, eg: `const conn = sql.connect(); conn.close()` will be the same as `sql.close()`\n- Bulk table inserts will attempt to coerce dates from non-Date objects if the column type is expecting a date\n- Repeat calls to the global connect function (`sql.connect()`) will return the current global connection if it exists (rather than throwing an error)\n- Attempting to add a parameter to queries / stored procedures will now throw an error; use `replaceInput` and `replaceOutput` instead\n- Invalid isolation levels passed to `Transaction`s will now throw an error\n- `ConnectionPool` now reports if it is healthy or not (`ConnectionPool.healthy`) which can be used to determine if the pool is able\nto create new connections or not\n- Pause/Resume support for streamed results has been added to the msnodesqlv8 driver\n\n## 4.x to 5.x changes\n\n- Moved pool library from `node-pool` to `tarn.js`\n- `ConnectionPool.pool.size` deprecated, use `ConnectionPool.size` instead\n- `ConnectionPool.pool.available` deprecated, use `ConnectionPool.available` instead\n- `ConnectionPool.pool.pending` deprecated, use `ConnectionPool.pending` instead\n- `ConnectionPool.pool.borrowed` deprecated, use `ConnectionPool.borrowed` instead\n\n## 3.x to 4.x changes\n\n- Library & tests are rewritten to ES6.\n- `Connection` was renamed to `ConnectionPool`.\n- Drivers are no longer loaded dynamically so the library is now compatible with Webpack. To use `msnodesqlv8` driver, use `const sql = require('mssql/msnodesqlv8')` syntax.\n- Every callback/resolve now returns `result` object only. This object contains `recordsets` (array of recordsets), `recordset` (first recordset from array of recordsets), `rowsAffected` (array of numbers representig number of affected rows by each insert/update/delete statement) and `output` (key/value collection of output parameters' values).\n- Affected rows are now returned as an array. A separate number for each SQL statement.\n- Directive `multiple: true` was removed.\n- `Transaction` and `PreparedStatement` internal queues was removed.\n- ConnectionPool no longer emits `connect` and `close` events.\n- Removed verbose and debug mode.\n- Removed support for `tds` and `msnodesql` drivers.\n- Removed support for Node versions lower than 4.\n\n[npm-image]: https://img.shields.io/npm/v/mssql.svg?style=flat-square\n[npm-url]: https://www.npmjs.com/package/mssql\n[downloads-image]: https://img.shields.io/npm/dm/mssql.svg?style=flat-square\n[downloads-url]: https://www.npmjs.com/package/mssql\n[david-image]: https://img.shields.io/david/tediousjs/node-mssql.svg?style=flat-square\n[david-url]: https://david-dm.org/tediousjs/node-mssql\n[appveyor-image]: https://ci.appveyor.com/api/projects/status/e5gq1a0ujwams9t7/branch/master?svg=true\n[appveyor-url]: https://ci.appveyor.com/project/tediousjs/node-mssql\n\n[tedious-url]: https://www.npmjs.com/package/tedious\n[msnodesqlv8-url]: https://www.npmjs.com/package/msnodesqlv8\n","engines":{"node":">=10"},"gitHead":"53fc9ea20be6b2a5b225ad3ef70cd9e8177d7e35","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"9.8.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"18.17.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^15.0.1","commander":"^11.0.0","@tediousjs/connection-string":"^0.5.0"},"_hasShrinkwrap":false,"readmeFilename":"README.md","devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^17.6.6","semantic-release":"^21.0.7","@semantic-release/npm":"^10.0.4","@semantic-release/github":"^9.0.3","@commitlint/config-conventional":"^17.6.6","@semantic-release/commit-analyzer":"^10.0.1","@semantic-release/release-notes-generator":"^11.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_9.2.1_1693954715699_0.1961275902088131","host":"s3://npm-registry-packages"}},"9.3.1":{"name":"mssql","version":"9.3.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@9.3.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"67a82850ff3a1e75e89a7ce7eb623ae976cb0977","tarball":"https://registry.npmjs.org/mssql/-/mssql-9.3.1.tgz","fileCount":33,"integrity":"sha512-DtgrG5MFQ1/8d3+5NOHZqLh2F20+MPJjSbIoDquXEyeQI++YCA+O4+89xC2HFtOgGOI6P4Vd1uYbovY3Z/r4aA==","signatures":[{"sig":"MEUCIQDfVikrF+uFrKE1TNUOudSrPZv6pYxY2psIt3JWhTvDogIgKSqSfMtfaot3Z3oKyK1yWFDRDaHrsOpi6nxG7+FwTaY=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@9.3.1","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":233729},"main":"index.js","engines":{"node":">=10"},"gitHead":"31bdaca73ca8eca30f85e0f98135eb814b90ae67","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"deprecated":"contains breaking changes","repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"9.8.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"18.17.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^16.4.0","commander":"^11.0.0","@tediousjs/connection-string":"^0.5.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^17.6.6","semantic-release":"^21.0.7","@semantic-release/npm":"^10.0.4","@semantic-release/github":"^9.0.3","@commitlint/config-conventional":"^17.6.6","@semantic-release/commit-analyzer":"^10.0.1","@semantic-release/release-notes-generator":"^11.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_9.3.1_1693958983250_0.20740810409417576","host":"s3://npm-registry-packages"}},"9.3.2":{"name":"mssql","version":"9.3.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@9.3.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"c74777e1f1691543649cda16462dee61db5834b4","tarball":"https://registry.npmjs.org/mssql/-/mssql-9.3.2.tgz","fileCount":33,"integrity":"sha512-XI5GOGCCSSNL8K2SSXg9HMyugJoCjLmrhiZfcZrJrJ2r3NfTcnz3Cegeg4m+xPkNVd0o3owsSL/NsDCFYfjOlw==","signatures":[{"sig":"MEUCIB5cuveC6A9IDFOSIaQ9ICOF4jUvZY0uyh5jopUuoWVFAiEA6uAx6zlwJH1GK+xtDlidwnlRJHcqwpkvg6A26xPEsfY=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@9.3.2","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":233729},"main":"index.js","engines":{"node":">=10"},"gitHead":"cb6f8e227b1113d9bc8a9e08775445873fea63b8","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"9.8.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"18.17.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^15.0.1","commander":"^11.0.0","@tediousjs/connection-string":"^0.5.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^17.6.6","semantic-release":"^21.0.7","@semantic-release/npm":"^10.0.4","@semantic-release/github":"^9.0.3","@commitlint/config-conventional":"^17.6.6","@semantic-release/commit-analyzer":"^10.0.1","@semantic-release/release-notes-generator":"^11.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_9.3.2_1693963703405_0.8818381849096382","host":"s3://npm-registry-packages"}},"10.0.0":{"name":"mssql","version":"10.0.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@10.0.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"b142a45443047e611104e580a90ce46b822fcfd7","tarball":"https://registry.npmjs.org/mssql/-/mssql-10.0.0.tgz","fileCount":33,"integrity":"sha512-N2nW/4szMASu5IiPEbMdi7UkhylpHYDlWe6Bpf90S1ELev2gTs8msaV99TGTWA838LhdnhcZg+QdgCL4nHE95g==","signatures":[{"sig":"MEYCIQDT3nRWOf2kR63Tw/8MhBPT2wERhqlF43smOgzJYtP/PQIhAP+2dS3ng3uS1aFlfGdj53k5yoHFYUO6oYznTHaFbMFn","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@10.0.0","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":233730},"main":"index.js","engines":{"node":">=10"},"gitHead":"4688d614ecc0a6dbfb320c3fdf88c6049474731e","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"9.8.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"18.17.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^16.4.0","commander":"^11.0.0","@tediousjs/connection-string":"^0.5.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^17.6.6","semantic-release":"^21.0.7","@semantic-release/npm":"^10.0.4","@semantic-release/github":"^9.0.3","@commitlint/config-conventional":"^17.6.6","@semantic-release/commit-analyzer":"^10.0.1","@semantic-release/release-notes-generator":"^11.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_10.0.0_1693967474295_0.6050079047187684","host":"s3://npm-registry-packages"}},"10.0.1":{"name":"mssql","version":"10.0.1","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@10.0.1","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"96053ae91b96fdc0469b9d8ca34663d448075bdf","tarball":"https://registry.npmjs.org/mssql/-/mssql-10.0.1.tgz","fileCount":33,"integrity":"sha512-k0Xkav/3OppZs8Kj+FIo7k7ejbcsVNxp5/ePayxfXzuBZhxD/Y/RhIhrtfHyH6FmlJnBQPj7eDI2IN7B0BiSxQ==","signatures":[{"sig":"MEUCIFhwopwT844vF/Ma6Zn4zSfVU4fgez2tXMBahu8QmF6aAiEAszw2UovVhAn+KBWQPgTcI2xhb8I00+bifZKCLMk3oEo=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@10.0.1","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":233761},"main":"index.js","engines":{"node":">=14"},"gitHead":"c4544becc3e77301686c8ba38492c767e20eb0c7","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"9.8.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"18.17.1","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^16.4.0","commander":"^11.0.0","@tediousjs/connection-string":"^0.5.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^17.6.6","semantic-release":"^21.0.7","@semantic-release/npm":"^10.0.4","@semantic-release/github":"^9.0.3","@commitlint/config-conventional":"^17.6.6","@semantic-release/commit-analyzer":"^10.0.1","@semantic-release/release-notes-generator":"^11.0.4"},"_npmOperationalInternal":{"tmp":"tmp/mssql_10.0.1_1694549099365_0.4284363832218261","host":"s3://npm-registry-packages"}},"10.0.2":{"name":"mssql","version":"10.0.2","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@10.0.2","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"99f9113a05b8ee32c84704fddc3780554cd89a60","tarball":"https://registry.npmjs.org/mssql/-/mssql-10.0.2.tgz","fileCount":33,"integrity":"sha512-GrQ6gzv2xA7ndOvONyZ++4RZsNkr8qDiIpvuFn2pR3TPiSk/cKdmvOrDU3jWgon7EPj7CPgmDiMh7Hgtft2xLg==","signatures":[{"sig":"MEUCIGF+DTcPnSVpsMqOHLJbxCTMcT6C4SQDdhxgNI8Y6mtWAiEA+FRMG8dK81S+8XsVqfrCKGp3OsWKVcNaTJVmUCAOXAE=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@10.0.2","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":233783},"main":"index.js","type":"commonjs","engines":{"node":">=14"},"gitHead":"f09c23daa93e7bed101136f4ed7b60b9ae15005c","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"10.1.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"20.10.0","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^16.4.0","commander":"^11.0.0","@tediousjs/connection-string":"^0.5.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^18.0.0","semantic-release":"^22.0.0","@semantic-release/npm":"^11.0.0","@semantic-release/github":"^9.0.3","@commitlint/config-conventional":"^18.0.0","@semantic-release/commit-analyzer":"^11.0.0","@semantic-release/release-notes-generator":"^12.0.0"},"_npmOperationalInternal":{"tmp":"tmp/mssql_10.0.2_1705414573867_0.5856038242431434","host":"s3://npm-registry-packages"}},"10.0.3":{"name":"mssql","version":"10.0.3","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@10.0.3","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"ef0cb076c39c4380d5004f245d33c4acc6ffcdbd","tarball":"https://registry.npmjs.org/mssql/-/mssql-10.0.3.tgz","fileCount":33,"integrity":"sha512-H+hUqIsSWIjhfGFNlL8AA9A4Ba7CFrmR21iexJS12B4qCIuAxr/rMoRqfcke2Dl0uHulsMGsUeQZeS46wD/hHw==","signatures":[{"sig":"MEYCIQDf1GzEZNM996R6q5AyS9KXvu57uuyFvKrl7jvPXKw8zgIhAIfmvp3TFxnn1s8sA0hIeKcN6klaNRL5S4suVsrrGv1P","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@10.0.3","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":233812},"main":"index.js","type":"commonjs","engines":{"node":">=18"},"gitHead":"a655df29426f133e71e1211bbd14906b625a8d09","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"10.5.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"20.14.0","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^18.2.1","commander":"^11.0.0","@tediousjs/connection-string":"^0.5.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^19.0.3","semantic-release":"^24.0.0","@semantic-release/npm":"^12.0.0","@semantic-release/github":"^10.0.2","@commitlint/config-conventional":"^19.0.3","@semantic-release/commit-analyzer":"^13.0.0","@semantic-release/release-notes-generator":"^14.0.0"},"_npmOperationalInternal":{"tmp":"tmp/mssql_10.0.3_1718713985634_0.4149679502323673","host":"s3://npm-registry-packages"}},"10.0.4":{"name":"mssql","version":"10.0.4","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@10.0.4","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"030a96651748a192d7592851b67d176225cf1ac2","tarball":"https://registry.npmjs.org/mssql/-/mssql-10.0.4.tgz","fileCount":33,"integrity":"sha512-MhX5IcJ75/q+dUiOe+1ajpqjEe96ZKqMchYYPUIDU+Btqhwt4gbFeZhcGUZaRCEMV9uF+G8kLvaNSFaEzL9OXQ==","signatures":[{"sig":"MEQCIAWxHDaVW7fS/esYwhEvjUa2XNPRFw04qzJeNcZxtbmmAiBm0l7r1OMLRGZd/Tyg62SF3Is3Gw9eynD3sSxhUsd/Rw==","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@10.0.4","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":233793},"main":"index.js","type":"commonjs","engines":{"node":">=14"},"gitHead":"2b35ef3952e5c2a5d7c7ce14519f04a5b78054c5","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"10.5.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"20.14.0","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^16.4.0","commander":"^11.0.0","@tediousjs/connection-string":"^0.5.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^19.0.3","semantic-release":"^24.0.0","@semantic-release/npm":"^12.0.0","@semantic-release/github":"^10.0.2","@commitlint/config-conventional":"^19.0.3","@semantic-release/commit-analyzer":"^13.0.0","@semantic-release/release-notes-generator":"^14.0.0"},"_npmOperationalInternal":{"tmp":"tmp/mssql_10.0.4_1718736361166_0.06777821365272807","host":"s3://npm-registry-packages"}},"11.0.0":{"name":"mssql","version":"11.0.0","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"author":{"url":"https://patriksimek.cz","name":"Patrik Simek"},"license":"MIT","_id":"mssql@11.0.0","maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"bin":{"mssql":"bin/mssql"},"dist":{"shasum":"021e741a75ab6f09c0e16ee5958697f813efa007","tarball":"https://registry.npmjs.org/mssql/-/mssql-11.0.0.tgz","fileCount":33,"integrity":"sha512-XvfsSHeHD/hPIWjnfati1h2/K05pbJNIOOhf32xJ+9dnViSNF95XU6QgkI+CmNx4oYDTMBNN3b7p460PUbq0tw==","signatures":[{"sig":"MEUCIGjcdaVnp1xv7QvVsoBIxyRoGNX/o3AI/u+jojqu5eeyAiEA9oN66yyi7hi2JlYvPeho3ef6ZkNRX5RIrm7taRreAvg=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@11.0.0","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"unpackedSize":233812},"main":"index.js","type":"commonjs","engines":{"node":">=18"},"gitHead":"7490fd832815959ab7e8888b11a18d4e4158f277","scripts":{"lint":"standard","test":"npm run lint && npm run test-unit","test-cli":"mocha --exit -t 15000 test/common/cli.js","test-unit":"mocha --exit -t 15000 test/common/unit.js","commitlint":"commitlint --from origin/master --to HEAD","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8"},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"repository":{"url":"git+https://github.com/tediousjs/node-mssql.git","type":"git"},"_npmVersion":"10.5.0","description":"Microsoft SQL Server client for Node.js.","directories":{},"_nodeVersion":"18.20.3","dependencies":{"rfdc":"^1.3.0","tarn":"^3.0.2","debug":"^4.3.3","tedious":"^18.2.1","commander":"^11.0.0","@tediousjs/connection-string":"^0.5.0"},"_hasShrinkwrap":false,"devDependencies":{"mocha":"^10.0.0","standard":"^17.0.0","@commitlint/cli":"^19.3.0","semantic-release":"^22.0.12","@semantic-release/npm":"^11.0.3","@semantic-release/github":"^9.2.6","@commitlint/config-conventional":"^19.2.2","@semantic-release/commit-analyzer":"^11.1.0","@semantic-release/release-notes-generator":"^12.1.0"},"_npmOperationalInternal":{"tmp":"tmp/mssql_11.0.0_1718752047358_0.26603433585465686","host":"s3://npm-registry-packages"}},"11.0.1":{"author":{"name":"Patrik Simek","url":"https://patriksimek.cz"},"name":"mssql","description":"Microsoft SQL Server client for Node.js.","keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"version":"11.0.1","main":"index.js","type":"commonjs","repository":{"type":"git","url":"git+https://github.com/tediousjs/node-mssql.git"},"license":"MIT","dependencies":{"@tediousjs/connection-string":"^0.5.0","commander":"^11.0.0","debug":"^4.3.3","rfdc":"^1.3.0","tarn":"^3.0.2","tedious":"^18.2.1"},"devDependencies":{"@commitlint/cli":"^19.3.0","@commitlint/config-conventional":"^19.2.2","@semantic-release/commit-analyzer":"^11.1.0","@semantic-release/github":"^9.2.6","@semantic-release/npm":"^11.0.3","@semantic-release/release-notes-generator":"^12.1.0","mocha":"^10.0.0","semantic-release":"^22.0.12","standard":"^17.0.0"},"engines":{"node":">=18"},"scripts":{"commitlint":"commitlint --from origin/master --to HEAD","test":"npm run lint && npm run test-unit","lint":"standard","test-unit":"mocha --exit -t 15000 test/common/unit.js","test-tedious":"mocha --exit -t 15000 test/tedious","test-msnodesqlv8":"mocha --exit -t 30000 test/msnodesqlv8","test-cli":"mocha --exit -t 15000 test/common/cli.js"},"bin":{"mssql":"bin/mssql"},"_id":"mssql@11.0.1","gitHead":"9e5aef4e864f08dc703e077f27c76ff7858bef7a","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"homepage":"https://github.com/tediousjs/node-mssql#readme","_nodeVersion":"18.20.3","_npmVersion":"10.5.0","dist":{"integrity":"sha512-KlGNsugoT90enKlR8/G36H0kTxPthDhmtNUCwEHvgRza5Cjpjoj+P2X6eMpFUDN7pFrJZsKadL4x990G8RBE1w==","shasum":"a32ab7763bfbb3f5d970e47563df3911fc04e21d","tarball":"https://registry.npmjs.org/mssql/-/mssql-11.0.1.tgz","fileCount":33,"unpackedSize":234870,"attestations":{"url":"https://registry.npmjs.org/-/npm/v1/attestations/mssql@11.0.1","provenance":{"predicateType":"https://slsa.dev/provenance/v1"}},"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEUCIQCkYSdesV1cE8OOnSJozjWzOGjAcAQngQ8lurQZ+e8jsAIgS8jlAUmF1FuxHeMYdg1nm2QyyR1q8yIvf1GjUWsF0dE="}]},"_npmUser":{"name":"dhensby","email":"npm@dhensby.co.uk"},"directories":{},"maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages","tmp":"tmp/mssql_11.0.1_1719995102062_0.9414661491302787"},"_hasShrinkwrap":false}},"time":{"created":"2013-08-10T23:27:58.461Z","modified":"2024-07-03T08:25:02.618Z","0.2.0":"2013-08-10T23:28:01.771Z","0.2.1":"2013-08-11T01:11:44.412Z","0.2.2":"2013-08-11T23:10:26.030Z","0.2.3":"2013-08-14T16:14:18.379Z","0.2.4":"2013-08-15T14:42:26.802Z","0.2.5":"2013-09-05T14:13:41.499Z","0.3.0":"2013-09-08T00:08:12.265Z","0.3.1":"2013-09-13T15:59:15.598Z","0.3.2":"2013-09-30T11:23:02.870Z","0.3.3":"2013-10-23T19:59:47.817Z","0.3.4":"2013-10-23T21:31:08.980Z","0.4.0":"2013-12-12T00:44:31.198Z","0.4.1":"2013-12-13T12:14:03.581Z","0.4.2":"2014-01-06T03:00:19.423Z","0.4.3":"2014-01-14T23:03:27.154Z","0.4.4":"2014-01-22T20:48:58.647Z","0.4.5":"2014-01-23T01:32:44.641Z","0.5.0":"2014-01-25T02:51:08.098Z","0.5.1":"2014-04-01T16:44:20.324Z","0.5.2":"2014-04-04T17:33:11.891Z","0.5.3":"2014-04-04T17:50:18.198Z","0.5.4":"2014-06-15T20:42:31.767Z","0.5.5":"2014-06-24T02:02:08.639Z","0.6.0":"2014-07-03T19:49:38.046Z","0.6.1":"2014-07-03T22:31:11.509Z","0.6.2":"2014-07-04T00:48:56.897Z","1.0.0":"2014-07-04T01:23:13.408Z","1.0.1":"2014-07-04T02:04:58.463Z","1.0.2":"2014-07-04T15:42:15.228Z","1.1.0":"2014-07-12T23:24:57.241Z","1.1.1":"2014-08-07T11:33:31.572Z","1.2.0":"2014-08-26T15:52:12.209Z","1.2.1":"2014-10-07T21:57:02.079Z","1.3.0":"2014-10-27T21:46:47.128Z","2.0.0":"2015-02-17T22:23:03.771Z","2.1.0":"2015-02-20T04:15:19.076Z","2.1.1":"2015-02-25T12:23:45.225Z","2.1.2":"2015-03-28T03:30:42.046Z","2.1.3":"2015-05-02T22:27:35.017Z","2.1.4":"2015-06-05T17:14:39.462Z","2.1.5":"2015-06-05T20:22:44.048Z","2.1.6":"2015-06-17T15:19:00.855Z","2.1.7":"2015-08-09T20:08:25.870Z","2.1.8":"2015-08-11T14:15:27.780Z","2.2.0":"2015-08-17T14:40:50.641Z","2.2.1":"2015-09-19T19:42:32.813Z","2.3.0":"2015-09-20T14:22:28.848Z","2.3.1":"2015-09-21T15:19:57.717Z","2.3.2":"2015-11-11T18:52:01.116Z","2.4.0":"2015-12-11T17:06:18.414Z","2.5.0":"2015-12-17T01:18:17.688Z","2.6.0":"2015-12-25T01:45:57.910Z","2.6.1":"2015-12-25T01:47:24.275Z","2.6.2":"2015-12-25T02:17:34.395Z","3.0.0":"2016-01-07T23:05:10.660Z","3.0.1":"2016-02-04T01:28:43.678Z","3.1.0":"2016-02-13T22:24:55.622Z","3.1.1":"2016-02-21T00:14:57.930Z","3.1.2":"2016-03-08T20:50:26.374Z","3.2.0":"2016-04-11T00:24:04.633Z","3.2.1":"2016-04-15T23:16:38.816Z","3.3.0":"2016-05-06T23:08:19.403Z","4.0.0-alpha1":"2017-02-14T03:01:07.704Z","4.0.0-alpha2":"2017-03-11T02:12:12.122Z","4.0.0":"2017-04-01T00:40:14.304Z","4.0.1":"2017-04-01T22:00:32.694Z","4.0.2":"2017-04-19T20:15:04.153Z","4.0.3":"2017-04-25T16:43:19.986Z","4.0.4":"2017-04-25T21:38:35.916Z","4.1.0":"2017-09-29T16:26:32.347Z","4.2.0":"2018-07-05T19:47:38.799Z","4.2.1":"2018-08-05T21:12:00.182Z","4.2.2":"2018-10-17T21:41:46.182Z","4.2.3":"2018-11-06T16:01:11.013Z","4.3.0":"2018-11-22T12:32:40.044Z","5.0.0-alpha.1":"2018-11-22T14:24:31.533Z","5.0.0-alpha.2":"2019-01-07T10:26:07.511Z","5.0.0-alpha.3":"2019-01-07T14:30:56.596Z","5.0.0-alhpa.4":"2019-01-17T09:50:39.516Z","5.0.0-alpha.5":"2019-01-29T10:21:22.961Z","5.0.0-beta.1":"2019-02-04T14:49:53.710Z","4.3.1":"2019-02-04T18:15:07.733Z","4.3.2":"2019-02-13T17:14:48.770Z","4.3.3":"2019-03-07T09:43:54.803Z","5.0.0":"2019-03-07T10:12:18.239Z","6.0.0-alpha.1":"2019-03-07T17:15:11.840Z","6.0.0-alpha.2":"2019-03-08T11:21:18.873Z","4.3.4":"2019-03-09T00:19:43.650Z","5.0.1":"2019-03-09T00:25:09.144Z","6.0.0-alpha.3":"2019-03-09T00:28:18.440Z","4.3.5":"2019-03-09T13:21:58.471Z","5.0.2":"2019-03-09T13:23:59.352Z","6.0.0-alpha.4":"2019-03-09T13:26:23.936Z","5.0.3":"2019-03-13T12:52:48.227Z","6.0.0-alpha.5":"2019-03-13T12:55:07.115Z","6.0.0-alpha.6":"2019-03-15T10:33:35.044Z","6.0.0-alpha.7":"2019-03-25T13:03:11.217Z","4.3.6":"2019-03-27T10:28:44.208Z","5.0.4":"2019-03-27T10:31:45.466Z","4.3.7":"2019-03-28T14:09:14.141Z","5.0.5":"2019-03-28T14:10:42.442Z","6.0.0-alpha.8":"2019-03-28T14:12:19.433Z","5.0.6":"2019-04-16T23:26:11.746Z","5.1.0":"2019-04-17T17:25:46.175Z","6.0.0-alpha.9":"2019-04-17T17:28:56.648Z","6.0.0-beta.1":"2019-08-07T08:39:14.563Z","6.0.0":"2019-11-05T00:31:30.937Z","6.0.1":"2019-11-15T11:50:51.725Z","6.1.0":"2020-02-17T14:53:59.235Z","4.3.8":"2020-03-13T22:19:26.593Z","5.1.1":"2020-03-13T22:22:59.651Z","6.2.0":"2020-03-13T22:32:49.502Z","7.0.0-alpha.1":"2020-03-13T22:37:16.385Z","7.0.0-alpha.2":"2020-04-23T17:20:59.015Z","7.0.0-alpha.3":"2020-06-29T17:08:43.221Z","4.3.9":"2020-07-22T20:21:31.428Z","5.1.2":"2020-07-22T20:25:32.713Z","6.2.1":"2020-07-22T20:34:37.857Z","5.1.3":"2020-09-18T13:19:40.223Z","6.2.2":"2020-09-18T13:28:56.488Z","6.2.3":"2020-09-25T12:37:13.289Z","6.3.0":"2020-12-14T13:53:07.166Z","5.1.4":"2021-01-01T10:50:30.294Z","6.3.1":"2021-01-01T11:02:03.047Z","7.0.0-alpha.4":"2021-01-01T11:08:54.392Z","7.0.0-beta.1":"2021-01-14T15:34:21.884Z","7.0.0-beta.2":"2021-01-16T22:14:13.726Z","7.0.0-beta.3":"2021-01-24T21:16:24.498Z","7.0.0-beta.4":"2021-04-15T21:13:15.589Z","7.0.0-beta.5":"2021-04-15T21:26:57.124Z","7.0.0":"2021-05-06T17:30:50.716Z","5.1.5":"2021-05-13T18:43:36.447Z","6.3.2":"2021-05-13T18:47:20.191Z","7.1.0":"2021-05-13T18:49:53.947Z","7.1.1":"2021-06-09T10:02:01.257Z","7.1.2":"2021-06-11T08:25:00.280Z","7.1.3":"2021-06-11T08:30:42.356Z","7.2.0":"2021-07-29T07:35:25.105Z","7.2.1":"2021-08-19T20:11:42.822Z","6.4.0":"2021-11-18T22:41:14.708Z","7.3.0":"2021-11-18T22:48:21.731Z","8.0.0":"2022-01-30T22:24:56.515Z","8.0.1":"2022-01-30T22:29:51.404Z","8.0.2":"2022-02-07T13:19:20.886Z","6.4.1":"2022-02-24T22:50:28.824Z","7.3.1":"2022-02-24T22:57:29.067Z","8.1.0":"2022-04-06T11:00:13.724Z","7.3.3":"2022-05-18T07:48:52.743Z","7.3.2":"2022-05-18T07:57:16.737Z","7.3.4":"2022-05-18T08:04:20.071Z","8.1.1":"2022-05-18T08:06:56.648Z","7.3.5":"2022-05-27T16:26:58.154Z","8.1.2":"2022-05-27T16:30:37.082Z","8.1.3":"2022-08-08T15:54:29.654Z","9.0.0":"2022-08-09T22:09:25.021Z","8.1.4":"2022-08-18T15:37:42.301Z","9.0.1":"2022-08-18T15:37:53.389Z","9.1.0":"2023-01-17T10:26:07.117Z","9.1.1":"2023-01-18T23:20:39.390Z","9.1.2":"2023-08-02T15:39:01.185Z","9.1.3":"2023-08-08T05:36:07.283Z","9.2.0":"2023-08-28T22:59:56.373Z","9.3.0":"2023-09-04T22:19:23.521Z","9.2.1":"2023-09-05T22:58:36.042Z","9.3.1":"2023-09-06T00:09:43.452Z","9.3.2":"2023-09-06T01:28:23.637Z","10.0.0":"2023-09-06T02:31:14.576Z","10.0.1":"2023-09-12T20:04:59.616Z","10.0.2":"2024-01-16T14:16:14.034Z","10.0.3":"2024-06-18T12:33:05.802Z","10.0.4":"2024-06-18T18:46:01.344Z","11.0.0":"2024-06-18T23:07:27.538Z","11.0.1":"2024-07-03T08:25:02.212Z"},"maintainers":[{"name":"patriksimek","email":"patrik@patriksimek.cz"},{"name":"arthurschreiber","email":"schreiber.arthur@googlemail.com"},{"name":"wmorgan","email":"will+npm@willmorgan.co.uk"},{"name":"dhensby","email":"npm@dhensby.co.uk"}],"author":{"name":"Patrik Simek","url":"https://patriksimek.cz"},"repository":{"type":"git","url":"git+https://github.com/tediousjs/node-mssql.git"},"keywords":["database","mssql","sql","server","msnodesql","sqlserver","tds","node-tds","tedious","node-sqlserver","sqlserver","msnodesqlv8","azure","node-mssql"],"license":"MIT","homepage":"https://github.com/tediousjs/node-mssql#readme","bugs":{"url":"https://github.com/tediousjs/node-mssql/issues"},"readme":"# node-mssql\n\n**Microsoft SQL Server client for Node.js**\n\n[![NPM Version][npm-image]][npm-url] [![NPM Downloads][downloads-image]][downloads-url] [![Appveyor CI][appveyor-image]][appveyor-url] [![Join the chat at https://gitter.im/patriksimek/node-mssql](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/patriksimek/node-mssql?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nSupported TDS drivers:\n\n- [Tedious][tedious-url] (pure JavaScript - Windows/macOS/Linux, default)\n- [MSNodeSQLv8][msnodesqlv8-url] (Microsoft / Contributors Node V8 Driver for Node.js for SQL Server, v2 native - Windows or Linux/macOS 64 bits only)\n\n## Installation\n\n### Tedious driver (default)\n\n```\nnpm install mssql\n```\n\n### MSNodeSQLv8 driver (optional)\n\n```\nnpm install mssql msnodesqlv8\n```\n\n## SQL Server prerequisites\n\nThis package requires TCP/IP to connect to SQL Server, and you may need to enable this in your installation.\n\n## Short Example: Use Connect String\n\n```javascript\nconst sql = require('mssql')\n\n(async () => {\n    try {\n        // make sure that any items are correctly URL encoded in the connection string\n        await sql.connect('Server=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true')\n        const result = await sql.query`select * from mytable where id = ${value}`\n        console.dir(result)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n```\n\nIf you're on Windows Azure, add `?encrypt=true` to your connection string. See [docs](#configuration) to learn more.\n\nParts of the connection URI should be correctly URL encoded so that the URI can be parsed correctly.\n\n## Longer Example: Connect via Config Object\n\nAssuming you have set the appropriate environment variables, you can construct a config object as follows:\n\n```javascript\nconst sql = require('mssql')\n\nconst sqlConfig = {\n  user: process.env.DB_USER,\n  password: process.env.DB_PWD,\n  database: process.env.DB_NAME,\n  server: 'localhost',\n  pool: {\n    max: 10,\n    min: 0,\n    idleTimeoutMillis: 30000\n  },\n  options: {\n    encrypt: true, // for azure\n    trustServerCertificate: false // change to true for local dev / self-signed certs\n  }\n}\n\n(async () => {\n try {\n  // make sure that any items are correctly URL encoded in the connection string\n  await sql.connect(sqlConfig)\n  const result = await sql.query`select * from mytable where id = ${value}`\n  console.dir(result)\n } catch (err) {\n  // ... error checks\n }\n})()\n```\n\n## Windows Authentication Example Using MSNodeSQLv8\n\n```javascript\nconst sql = require('mssql/msnodesqlv8');\n\nconst config = {\n  server: \"MyServer\",\n  database: \"MyDatabase\",\n  options: {\n    trustedConnection: true, // Set to true if using Windows Authentication\n    trustServerCertificate: true, // Set to true if using self-signed certificates\n  },\n  driver: \"msnodesqlv8\", // Required if using Windows Authentication\n};\n\n(async () => {\n  try {\n    await sql.connect(config);\n    const result = await sql.query`select TOP 10 * from MyTable`;\n    console.dir(result);\n  } catch (err) {\n    console.error(err);\n  }\n})();\n```\n\n## Documentation\n\n### Examples\n\n* [Async/Await](#asyncawait)\n* [Promises](#promises)\n* [ES6 Tagged template literals](#es6-tagged-template-literals)\n* [Callbacks](#callbacks)\n* [Streaming](#streaming)\n* [Connection Pools](#connection-pools)\n\n### Configuration\n\n* [General](#general-same-for-all-drivers)\n* [Formats](#formats)\n\n### Drivers\n\n* [Tedious](#tedious)\n* [MSNodeSQLv8](#msnodesqlv8)\n\n### Connections\n\n* [Pool Management](#pool-management)\n* [ConnectionPool](#connections-1)\n* [connect](#connect-callback)\n* [close](#close)\n\n### Requests\n\n* [Request](#request)\n* [execute](#execute-procedure-callback)\n* [input](#input-name-type-value)\n* [output](#output-name-type-value)\n* [toReadableStream](#toReadableStream)\n* [pipe](#pipe-stream)\n* [query](#query-command-callback)\n* [batch](#batch-batch-callback)\n* [bulk](#bulk-table-options-callback)\n* [cancel](#cancel)\n\n### Transactions\n\n* [Transaction](#transaction)\n* [begin](#begin-isolationlevel-callback)\n* [commit](#commit-callback)\n* [rollback](#rollback-callback)\n\n### Prepared Statements\n\n* [PreparedStatement](#prepared-statement)\n* [input](#input-name-type)\n* [output](#output-name-type)\n* [prepare](#prepare-statement-callback)\n* [execute](#execute-values-callback)\n* [unprepare](#unprepare-callback)\n\n### Other\n\n* [CLI](#cli)\n* [Geography and Geometry](#geography-and-geometry)\n* [Table-Valued Parameter](#table-valued-parameter-tvp)\n* [Response Schema](#response-schema)\n* [Affected Rows](#affected-rows)\n* [JSON support](#json-support)\n* [Handling Duplicate Column Names](#handling-duplicate-column-names)\n* [Errors](#errors)\n* [Informational messages](#informational-messages)\n* [Metadata](#metadata)\n* [Data Types](#data-types)\n* [SQL injection](#sql-injection)\n* [Known Issues](#known-issues)\n* [Contributing](https://github.com/tediousjs/node-mssql/wiki/Contributing)\n* [8.x to 9.x changes](#8x-to-9x-changes)\n* [7.x to 8.x changes](#7x-to-8x-changes)\n* [6.x to 7.x changes](#6x-to-7x-changes)\n* [5.x to 6.x changes](#5x-to-6x-changes)\n* [4.x to 5.x changes](#4x-to-5x-changes)\n* [3.x to 4.x changes](#3x-to-4x-changes)\n* [3.x Documentation](https://github.com/tediousjs/node-mssql/blob/1893969195045a250f0fdeeb2de7f30dcf6689ad/README.md)\n\n## Examples\n\n### Config\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost', // You can use 'localhost\\\\instance' to connect to named instance\n    database: '...',\n}\n```\n\n\n### Async/Await\n\n```javascript\nconst sql = require('mssql')\n\n(async function () {\n    try {\n        let pool = await sql.connect(config)\n        let result1 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .query('select * from mytable where id = @input_parameter')\n\n        console.dir(result1)\n\n        // Stored procedure\n\n        let result2 = await pool.request()\n            .input('input_parameter', sql.Int, value)\n            .output('output_parameter', sql.VarChar(50))\n            .execute('procedure_name')\n\n        console.dir(result2)\n    } catch (err) {\n        // ... error checks\n    }\n})()\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Promises\n\n#### Queries\n\n```javascript\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n    // Query\n\n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .query('select * from mytable where id = @input_parameter')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n  // ... error checks\n});\n```\n\n#### Stored procedures\n\n```js\nconst sql = require('mssql')\n\nsql.on('error', err => {\n    // ... error handler\n})\n\nsql.connect(config).then(pool => {\n\n    // Stored procedure\n\n    return pool.request()\n        .input('input_parameter', sql.Int, value)\n        .output('output_parameter', sql.VarChar(50))\n        .execute('procedure_name')\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n```\n\nNative Promise is used by default. You can easily change this with `sql.Promise = require('myownpromisepackage')`.\n\n### ES6 Tagged template literals\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config).then(() => {\n    return sql.query`select * from mytable where id = ${value}`\n}).then(result => {\n    console.dir(result)\n}).catch(err => {\n    // ... error checks\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nAll values are automatically sanitized against sql injection.\nThis is because it is rendered as prepared statement, and thus all limitations imposed in MS SQL on parameters apply.\ne.g. Column names cannot be passed/set in statements using variables.\n\n### Callbacks\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    // Query\n\n    new sql.Request().query('select 1 as number', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Stored Procedure\n\n    new sql.Request()\n    .input('input_parameter', sql.Int, value)\n    .output('output_parameter', sql.VarChar(50))\n    .execute('procedure_name', (err, result) => {\n        // ... error checks\n\n        console.dir(result)\n    })\n\n    // Using template literal\n\n    const request = new sql.Request()\n    request.query(request.template`select * from mytable where id = ${value}`, (err, result) => {\n        // ... error checks\n        console.dir(result)\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\n### Streaming\n\nIf you plan to work with large amount of rows, you should always use streaming. Once you enable this, you must listen for events to receive data.\n\n```javascript\nconst sql = require('mssql')\n\nsql.connect(config, err => {\n    // ... error checks\n\n    const request = new sql.Request()\n    request.stream = true // You can set streaming differently for each request\n    request.query('select * from verylargetable') // or request.execute(procedure)\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('rowsaffected', rowCount => {\n        // Emitted for each `INSERT`, `UPDATE` or `DELETE` statement\n        // Requires NOCOUNT to be OFF (default)\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n    })\n})\n\nsql.on('error', err => {\n    // ... error handler\n})\n```\n\nWhen streaming large sets of data you want to back-off or chunk the amount of data you're processing\n to prevent memory exhaustion issues; you can use the `Request.pause()` function to do this. Here is\n an example of managing rows in batches of 15:\n\n```javascript\nlet rowsToProcess = [];\nrequest.on('row', row => {\n  rowsToProcess.push(row);\n  if (rowsToProcess.length >= 15) {\n    request.pause();\n    processRows();\n  }\n});\nrequest.on('done', () => {\n    processRows();\n});\n\nfunction processRows() {\n  // process rows\n  rowsToProcess = [];\n  request.resume();\n}\n```\n\n## Connection Pools\n\nAn important concept to understand when using this library is [Connection Pooling](https://en.wikipedia.org/wiki/Connection_pool) as this library uses connection pooling extensively. As one Node JS process is able to handle multiple requests at once, we can take advantage of this long running process to create a pool of database connections for reuse; this saves overhead of connecting to the database for each request\n(as would be the case in something like PHP, where one process handles one request).\n\nWith the advantages of pooling comes some added complexities, but these are mostly just conceptual and once you understand how the pooling is working, it is simple to make use of it efficiently and effectively.\n\n### The Global Connection Pool\n\nTo assist with pool management in your application there is the `sql.connect()` function that is used to connect to the global connection pool. You can make repeated calls to this function, and if the global pool is already connected, it will resolve to the connected pool. The following example obtains the global connection pool by running `sql.connect()`, and then runs the query against the pool.\n\nNB: It's important to note that there can only be one global connection pool connected at a time. Providing a different connection config to the `connect()` function will not create a new connection if it is already connected.\n\n```js\nconst sql = require('mssql')\nconst config = { ... }\n\n// run a query against the global connection pool\nfunction runQuery(query) {\n  // sql.connect() will return the existing global pool if it exists or create a new one if it doesn't\n  return sql.connect(config).then((pool) => {\n    return pool.query(query)\n  })\n}\n```\n\nAwaiting or `.then`-ing the pool creation is a safe way to ensure that the pool is always ready, without knowing where it is needed first. In practice, once the pool is created then there will be no delay for the next `connect()` call.\n\nAlso notice that we do *not* close the global pool by calling `sql.close()` after the query is executed, because other queries may need to be run against this pool and closing it will add additional overhead to running subsequent queries. You should only ever close the global pool if you're certain the application is finished. Or for example, if you are running some kind of CLI tool or a CRON job you can close the pool at the end of the script.\n\n### Global Pool Single Instance\n\nThe ability to call `connect()` and `close()` repeatedly on the global pool is intended to make pool management easier, however it is better to maintain your own reference to the pool, where `connect()` is called **once**, and the resulting global pool's connection promise is re-used throughout the entire application.\n\nFor example, in Express applications, the following approach uses a single global pool instance added to the `app.locals` so the application has access to it when needed. The server start is then chained inside the `connect()` promise.\n\n```js\nconst express = require('express')\nconst sql = require('mssql')\nconst config  = {/*...*/}\n//instantiate a connection pool\nconst appPool = new sql.ConnectionPool(config)\n//require route handlers and use the same connection pool everywhere\nconst route1 = require('./routes/route1')\nconst app = express()\napp.get('/path', route1)\n\n//connect the pool and start the web server when done\nappPool.connect().then(function(pool) {\n  app.locals.db = pool;\n  const server = app.listen(3000, function () {\n    const host = server.address().address\n    const port = server.address().port\n    console.log('Example app listening at http://%s:%s', host, port)\n  })\n}).catch(function(err) {\n  console.error('Error creating connection pool', err)\n});\n```\n\nThen the route uses the connection pool in the `app.locals` object:\n\n```js\n// ./routes/route1.js\nconst sql = require('mssql');\n\nmodule.exports = function(req, res) {\n  req.app.locals.db.query('SELECT TOP 10 * FROM table_name', function(err, recordset) {\n    if (err) {\n      console.error(err)\n      res.status(500).send('SERVER ERROR')\n      return\n    }\n    res.status(200).json({ message: 'success' })\n  })\n}\n```\n\n### Advanced Pool Management\n\nFor some use-cases you may want to implement your own connection pool management, rather than using the global connection pool. Reasons for doing this include:\n\n* Supporting connections to multiple databases\n* Creation of separate pools for read vs read/write operations\n\nThe following code is an example of a custom connection pool implementation.\n\n```js\n// pool-manager.js\nconst mssql = require('mssql')\nconst pools = new Map();\n\nmodule.exports = {\n /**\n  * Get or create a pool. If a pool doesn't exist the config must be provided.\n  * If the pool does exist the config is ignored (even if it was different to the one provided\n  * when creating the pool)\n  *\n  * @param {string} name\n  * @param {{}} [config]\n  * @return {Promise.<mssql.ConnectionPool>}\n  */\n get: (name, config) => {\n  if (!pools.has(name)) {\n   if (!config) {\n    throw new Error('Pool does not exist');\n   }\n   const pool = new mssql.ConnectionPool(config);\n   // automatically remove the pool from the cache if `pool.close()` is called\n   const close = pool.close.bind(pool);\n   pool.close = (...args) => {\n    pools.delete(name);\n    return close(...args);\n   }\n   pools.set(name, pool.connect());\n  }\n  return pools.get(name);\n },\n /**\n  * Closes all the pools and removes them from the store\n  *\n  * @return {Promise<mssql.ConnectionPool[]>}\n  */\n closeAll: () => Promise.all(Array.from(pools.values()).map((connect) => {\n  return connect.then((pool) => pool.close());\n })),\n};\n```\n\nThis file can then be used in your application to create, fetch, and close pools.\n\n```js\nconst { get } = require('./pool-manager')\n\nasync function example() {\n  const pool = await get('default')\n  return pool.request().query('SELECT 1')\n}\n```\n\nSimilar to the global connection pool, you should aim to only close a pool when you know it will never be needed by the application again. Typically this will only be when your application is shutting down.\n\n### Result value manipulation\n\nIn some instances it is desirable to manipulate the record data as it is returned from the database, this may be to cast it as a particular object (eg: `moment` object instead of `Date`) or similar.\n\nIn v8.0.0+ it is possible to register per-datatype handlers:\n\n```js\nconst sql = require('mssql')\n\n// in this example all integer values will return 1 more than their actual value in the database\nsql.valueHandler.set(sql.TYPES.Int, (value) => value + 1)\n\nsql.query('SELECT * FROM [example]').then((result) => {\n  // all `int` columns will return a manipulated value as per the callback above\n})\n```\n\n## Configuration\n\nThe following is an example configuration object:\n\n```javascript\nconst config = {\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...',\n    pool: {\n        max: 10,\n        min: 0,\n        idleTimeoutMillis: 30000\n    }\n}\n```\n\n### General (same for all drivers)\n\n- **user** - User name to use for authentication.\n- **password** - Password to use for authentication.\n- **server** - Server to connect to. You can use 'localhost\\\\instance' to connect to named instance.\n- **port** - Port to connect to (default: `1433`). Don't set when connecting to named instance.\n- **domain** - Once you set domain, driver will connect to SQL Server using domain login.\n- **database** - Database to connect to (default: dependent on server configuration).\n- **connectionTimeout** - Connection timeout in ms (default: `15000`).\n- **requestTimeout** - Request timeout in ms (default: `15000`). NOTE: msnodesqlv8 driver doesn't support timeouts < 1 second. When passed via connection string, the key must be `request timeout`\n- **stream** - Stream recordsets/rows instead of returning them all at once as an argument of callback (default: `false`). You can also enable streaming for each request independently (`request.stream = true`). Always set to `true` if you plan to work with large amount of rows.\n- **parseJSON** - Parse JSON recordsets to JS objects (default: `false`). For more information please see section [JSON support](#json-support).\n- **pool.max** - The maximum number of connections there can be in the pool (default: `10`).\n- **pool.min** - The minimum of connections there can be in the pool (default: `0`).\n- **pool.idleTimeoutMillis** - The Number of milliseconds before closing an unused connection (default: `30000`).\n- **arrayRowMode** - Return row results as a an array instead of a keyed object. Also adds `columns` array. (default: `false`) See [Handling Duplicate Column Names](#handling-duplicate-column-names)\n\nComplete list of pool options can be found [here](https://github.com/vincit/tarn.js/#usage).\n\n### Formats\n\nIn addition to configuration object there is an option to pass config as a connection string. Connection strings are supported.\n\n##### Classic Connection String\n\n###### Standard configuration using tedious driver\n\n```\nServer=localhost,1433;Database=database;User Id=username;Password=password;Encrypt=true\n```\n###### Standard configuration using MSNodeSQLv8 driver\n```\nDriver=msnodesqlv8;Server=(local)\\INSTANCE;Database=database;UID=DOMAIN\\username;PWD=password;Encrypt=true\n```\n\n##### Azure Active Directory Authentication Connection String\n\nSeveral types of Azure Authentication are supported:\n\n###### Authentication using Active Directory Integrated\n```\nServer=*.database.windows.net;Database=database;Authentication=Active Directory Integrated;Client secret=clientsecret;Client Id=clientid;Tenant Id=tenantid;Encrypt=true\n```\nNote: Internally, the 'Active Directory Integrated' will change its type depending on the other parameters you add to it. On the example above, it will change to azure-active-directory-service-principal-secret because we supplied a Client Id, Client secret and Tenant Id.\n\nIf you want to utilize Authentication tokens (azure-active-directory-access-token) Just remove the unnecessary additional parameters and supply only a token parameter, such as in this example:\n\n```\nServer=*.database.windows.net;Database=database;Authentication=Active Directory Integrated;token=token;Encrypt=true\n```\n\nFinally if you want to utilize managed identity services such as managed identity service app service you can follow this example below:\n```\nServer=*.database.windows.net;Database=database;Authentication=Active Directory Integrated;msi endpoint=msiendpoint;Client Id=clientid;msi secret=msisecret;Encrypt=true\n```\nor if its managed identity service virtual machines, then follow this:\n```\nServer=*.database.windows.net;Database=database;Authentication=Active Directory Integrated;msi endpoint=msiendpoint;Client Id=clientid;Encrypt=true\n```\n\nWe can also utilizes Active Directory Password but unlike the previous examples, it is not part of the Active Directory Integrated Authentication.\n\n###### Authentication using Active Directory Password\n```\nServer=*.database.windows.net;Database=database;Authentication=Active Directory Password;User Id=username;Password=password;Client Id=clientid;Tenant Id=tenantid;Encrypt=true\n```\n\nFor more reference, you can consult [here](https://tediousjs.github.io/tedious/api-connection.html#function_newConnection). Under the authentication.type parameter.\n\n## Drivers\n\n### Tedious\n\nDefault driver, actively maintained and production ready. Platform independent, runs everywhere Node.js runs. Officially supported by Microsoft.\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the configured tedious `Connection`. It can be used for attaching event handlers like in this example:\n```js\nrequire('mssql').connect({...config, beforeConnect: conn => {\n  conn.once('connect', err => { err ? console.error(err) : console.log('mssql connected')})\n  conn.once('end', err => { err ? console.error(err) : console.log('mssql disconnected')})\n}})\n```\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1434 on the database server must be reachable.\n- **options.useUTC** - A boolean determining whether or not use UTC time for values without time zone offset (default: `true`).\n- **options.encrypt** - A boolean determining whether or not the connection will be encrypted (default: `true`).\n- **options.tdsVersion** - The version of TDS to use (default: `7_4`, available: `7_1`, `7_2`, `7_3_A`, `7_3_B`, `7_4`).\n- **options.appName** - Application name used for SQL server logging.\n- **options.abortTransactionOnError** - A boolean determining whether to rollback a transaction automatically if any error is encountered during the given transaction's execution. This sets the value for `XACT_ABORT` during the initial SQL phase of a connection.\n\n**Authentication:**\n\nOn top of the extra options, an `authentication` property can be added to the pool config option\n\n- **authentication** - An object with authentication settings, according to the [Tedious Documentation](https://tediousjs.github.io/tedious/api-connection.html). Passing this object will override `user`, `password`, `domain` settings.\n- **authentication.type** - Type of the authentication method, valid types are `default`, `ntlm`, `azure-active-directory-password`, `azure-active-directory-access-token`, `azure-active-directory-msi-vm`, or `azure-active-directory-msi-app-service`\n- **authentication.options** - Options of the authentication required by the `tedious` driver, depends on `authentication.type`. For more details, check [Tedious Authentication Interfaces](https://github.com/tediousjs/tedious/blob/v11.1.1/src/connection.ts#L200-L318)\n- `tedious` does not support Windows Authentication/Trusted Connection, however the `msnodesqlv8` driver does.\n\nMore information about Tedious specific options: http://tediousjs.github.io/tedious/api-connection.html\n\n___\n\n### MSNodeSQLv8\n\nAlternative driver, requires Node.js v10+ or newer; Windows (32 or 64-bit) or Linux/macOS (64-bit only). It's not part of the default package so it must be [installed](#msnodesqlv8-driver) in addition. Supports [Windows/Trusted Connection authentication](#windows-authentication-example-using-msnodesqlv8).\n\n**To use this driver you must use this `require` statement:**\n\n```javascript\nconst sql = require('mssql/msnodesqlv8')\n```\n\nNote: If you use import into your lib to prepare your request (`const { VarChar } = require('mssql')`) you also need to upgrade all your types import into your code (`const { VarChar } = require('mssql/msnodesqlv8')`) or a `connection.on is not a function` error will be thrown.\n\n\n**Extra options:**\n\n- **beforeConnect(conn)** - Function, which is invoked before opening the connection. The parameter `conn` is the connection configuration, that can be modified to pass extra parameters to the driver's `open()` method.\n- **connectionString** - Connection string (default: see below).\n- **options.instanceName** - The instance name to connect to. The SQL Server Browser service must be running on the database server, and UDP port 1444 on the database server must be reachable.\n- **options.trustedConnection** - Use Windows Authentication (default: `false`).\n- **options.useUTC** - A boolean determining whether or not to use UTC time for values without time zone offset (default: `true`).\n\nDefault connection string when connecting to port:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server},#{port}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nDefault connection string when connecting to named instance:\n```\nDriver={SQL Server Native Client 11.0};Server={#{server}\\\\#{instance}};Database={#{database}};Uid={#{user}};Pwd={#{password}};Trusted_Connection={#{trusted}};\n```\n\nPlease note that the connection string with this driver is not the same than tedious and use yes/no instead of true/false. You can see more on the [ODBC](https://docs.microsoft.com/fr-fr/dotnet/api/system.data.odbc.odbcconnection.connectionstring?view=dotnet-plat-ext-5.0) documentation.\n\n___\n\n## Connections\n\nInternally, each `ConnectionPool` instance is a separate pool of TDS connections. Once you create a new `Request`/`Transaction`/`Prepared Statement`, a new TDS connection is acquired from the pool and reserved for desired action. Once the action is complete, connection is released back to the pool. Connection health check is built-in so once the dead connection is discovered, it is immediately replaced with a new one.\n\n**IMPORTANT**: Always attach an `error` listener to created connection. Whenever something goes wrong with the connection it will emit an error and if there is no listener it will crash your application with an uncaught error.\n\n```javascript\nconst pool = new sql.ConnectionPool({ /* config */ })\n```\n\n### Events\n\n- **error(err)** - Dispatched on connection error.\n\n---------------------------------------\n\n### connect ([callback])\n\nCreate a new connection pool. The initial probe connection is created to find out whether the configuration is valid.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after initial probe connection has established, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst pool = new sql.ConnectionPool({\n    user: '...',\n    password: '...',\n    server: 'localhost',\n    database: '...'\n})\n\npool.connect(err => {\n    // ...\n})\n```\n\n__Errors__\n- ELOGIN (`ConnectionError`) - Login failed.\n- ETIMEOUT (`ConnectionError`) - Connection timeout.\n- EALREADYCONNECTED (`ConnectionError`) - Database is already connected!\n- EALREADYCONNECTING (`ConnectionError`) - Already connecting to database!\n- EINSTLOOKUP (`ConnectionError`) - Instance lookup failed.\n- ESOCKET (`ConnectionError`) - Socket error.\n\n---------------------------------------\n\n### close()\n\nClose all active connections in the pool.\n\n__Example__\n\n```javascript\npool.close()\n```\n\n## Request\n\n```javascript\nconst request = new sql.Request(/* [pool or transaction] */)\n```\n\nIf you omit pool/transaction argument, global pool is used instead.\n\n### Events\n\n- **recordset(columns)** - Dispatched when metadata for new recordset are parsed.\n- **row(row)** - Dispatched when new row is parsed.\n- **done(returnValue)** - Dispatched when request is complete.\n- **error(err)** - Dispatched on error.\n- **info(message)** - Dispatched on informational message.\n\n---------------------------------------\n\n### execute (procedure, [callback])\n\nCall a stored procedure.\n\n__Arguments__\n\n- **procedure** - Name of the stored procedure to be executed.\n- **callback(err, recordsets, returnValue)** - A callback which is called after execution has completed, or an error has occurred. `returnValue` is also accessible as property of recordsets. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.input('input_parameter', sql.Int, value)\nrequest.output('output_parameter', sql.Int)\nrequest.execute('procedure_name', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordsets.length) // count of recordsets returned by the procedure\n    console.log(result.recordsets[0].length) // count of rows contained in first recordset\n    console.log(result.recordset) // first recordset from result.recordsets\n    console.log(result.returnValue) // procedure return value\n    console.log(result.output) // key/value collection of output values\n    console.log(result.rowsAffected) // array of numbers, each number represents the number of rows affected by executed statemens\n\n    // ...\n})\n```\n\n__Errors__\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### input (name, [type], value)\n\nAdd an input parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter. If you omit type, module automatically decide which SQL data type should be used based on JS data type.\n- **value** - Input parameter value. `undefined` and `NaN` values are automatically converted to `null` values.\n\n__Example__\n\n```javascript\nrequest.input('input_parameter', value)\nrequest.input('input_parameter', sql.Int, value)\n```\n\n__JS Data Type To SQL Data Type Map__\n\n- `String` -> `sql.NVarChar`\n- `Number` -> `sql.Int`\n- `Boolean` -> `sql.Bit`\n- `Date` -> `sql.DateTime`\n- `Buffer` -> `sql.VarBinary`\n- `sql.Table` -> `sql.TVP`\n\nDefault data type for unknown object is `sql.NVarChar`.\n\nYou can define your own type map.\n\n```javascript\nsql.map.register(MyClass, sql.Text)\n```\n\nYou can also overwrite the default type map.\n\n```javascript\nsql.map.register(Number, sql.BigInt)\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\nNB: Do not use parameters `@p{n}` as these are used by the internal drivers and cause a conflict.\n\n### output (name, type, [value])\n\nAdd an output parameter to the request.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n- **value** - Output parameter value initial value. `undefined` and `NaN` values are automatically converted to `null` values. Optional.\n\n__Example__\n\n```javascript\nrequest.output('output_parameter', sql.Int)\nrequest.output('output_parameter', sql.VarChar(50), 'abc')\n```\n\n__Errors__ (synchronous)\n- EARGS (`RequestError`) - Invalid number of arguments.\n- EINJECT (`RequestError`) - SQL injection warning.\n\n---------------------------------------\n\n### toReadableStream\n\nConvert request to a Node.js ReadableStream\n\n__Example__\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream()\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\nOR if you wanted to increase the highWaterMark of the read stream to buffer more rows in memory\n\n```javascript\nconst { pipeline } = require('stream')\nconst request = new sql.Request()\nconst readableStream = request.toReadableStream({ highWaterMark: 100 })\npipeline(readableStream, transformStream, writableStream)\nrequest.query('select * from mytable')\n```\n\n\n### pipe (stream)\n\nSets request to `stream` mode and pulls all rows from all recordsets to a given stream.\n\n__Arguments__\n\n- **stream** - Writable stream in object mode.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.pipe(stream)\nrequest.query('select * from mytable')\nstream.on('error', err => {\n    // ...\n})\nstream.on('finish', () => {\n    // ...\n})\n```\n\n---------------------------------------\n\n### query (command, [callback])\n\nExecute the SQL command. To execute commands like `create procedure` or if you plan to work with local temporary tables, use [batch](#batch-batch-callback) instead.\n\n__Arguments__\n\n- **command** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n\n    // ...\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select 1 as number; select 2 as number', (err, result) => {\n    // ... error checks\n\n    console.log(result.recordset[0].number) // return 1\n    console.log(result.recordsets[0][0].number) // return 1\n    console.log(result.recordsets[1][0].number) // return 2\n})\n```\n\n**NOTE**: To get number of rows affected by the statement(s), see section [Affected Rows](#affected-rows).\n\n---------------------------------------\n\n### batch (batch, [callback])\n\nExecute the SQL command. Unlike [query](#query-command-callback), it doesn't use `sp_executesql`, so is not likely that SQL Server will reuse the execution plan it generates for the SQL. Use this only in special cases, for example when you need to execute commands like `create procedure` which can't be executed with [query](#query-command-callback) or if you're executing statements longer than 4000 chars on SQL Server 2000. Also you should use this if you're plan to work with local temporary tables ([more information here](http://weblogs.sqlteam.com/mladenp/archive/2006/11/03/17197.aspx)).\n\nNOTE: Table-Valued Parameter (TVP) is not supported in batch.\n\n__Arguments__\n\n- **batch** - T-SQL command to be executed.\n- **callback(err, recordset)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.batch('create procedure #temporary as select * from table', (err, result) => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\nYou can enable multiple recordsets in queries with the `request.multiple = true` command.\n\n---------------------------------------\n\n### bulk (table, [options,] [callback])\n\nPerform a bulk insert.\n\n__Arguments__\n\n- **table** - `sql.Table` instance.\n- **options** - Options object to be passed through to driver (currently tedious only). Optional. If argument is a function it will be treated as the callback.\n- **callback(err, rowCount)** - A callback which is called after bulk insert has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst table = new sql.Table('table_name') // or temporary table, e.g. #temptable\ntable.create = true\ntable.columns.add('a', sql.Int, {nullable: true, primary: true})\ntable.columns.add('b', sql.VarChar(50), {nullable: false})\ntable.rows.add(777, 'test')\n\nconst request = new sql.Request()\nrequest.bulk(table, (err, result) => {\n    // ... error checks\n})\n```\n\n**IMPORTANT**: Always indicate whether the column is nullable or not!\n\n**TIP**: If you set `table.create` to `true`, module will check if the table exists before it start sending data. If it doesn't, it will automatically create it. You can specify primary key columns by setting `primary: true` to column's options. Primary key constraint on multiple columns is supported.\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\n__Errors__\n- ENAME (`RequestError`) - Table name must be specified for bulk insert.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n- ENOCONN (`RequestError`) - No connection is specified for that request.\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- ECONNCLOSED (`ConnectionError`) - Connection is closed.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EABORT (`TransactionError`) - Transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### cancel()\n\nCancel currently executing request. Return `true` if cancellation packet was send successfully.\n\n__Example__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('waitfor delay \\'00:00:05\\'; select 1 as number', (err, result) => {\n    console.log(err instanceof sql.RequestError)  // true\n    console.log(err.message)                      // Cancelled.\n    console.log(err.code)                         // ECANCEL\n\n    // ...\n})\n\nrequest.cancel()\n```\n\n## Transaction\n\n**IMPORTANT:** always use `Transaction` class to create transactions - it ensures that all your requests are executed on one connection. Once you call `begin`, a single connection is acquired from the connection pool and all subsequent requests (initialized with the `Transaction` object) are executed exclusively on this connection. After you call `commit` or `rollback`, connection is then released back to the connection pool.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\n```\n\nIf you omit connection argument, global connection is used instead.\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    const request = new sql.Request(transaction)\n    request.query('insert into mytable (mycolumn) values (12345)', (err, result) => {\n        // ... error checks\n\n        transaction.commit(err => {\n            // ... error checks\n\n            console.log(\"Transaction committed.\")\n        })\n    })\n})\n```\n\nTransaction can also be created by `const transaction = pool.transaction()`. Requests can also be created by `const request = transaction.request()`.\n\n__Aborted transactions__\n\nThis example shows how you should correctly handle transaction errors when `abortTransactionOnError` (`XACT_ABORT`) is enabled. Added in 2.0.\n\n```javascript\nconst transaction = new sql.Transaction(/* [pool] */)\ntransaction.begin(err => {\n    // ... error checks\n\n    let rolledBack = false\n\n    transaction.on('rollback', aborted => {\n        // emited with aborted === true\n\n        rolledBack = true\n    })\n\n    new sql.Request(transaction)\n    .query('insert into mytable (bitcolumn) values (2)', (err, result) => {\n        // insert should fail because of invalid value\n\n        if (err) {\n            if (!rolledBack) {\n                transaction.rollback(err => {\n                    // ... error checks\n                })\n            }\n        } else {\n            transaction.commit(err => {\n                // ... error checks\n            })\n        }\n    })\n})\n```\n\n### Events\n\n- **begin** - Dispatched when transaction begin.\n- **commit** - Dispatched on successful commit.\n- **rollback(aborted)** - Dispatched on successful rollback with an argument determining if the transaction was aborted (by user or because of an error).\n\n---------------------------------------\n\n### begin ([isolationLevel], [callback])\n\nBegin a transaction.\n\n__Arguments__\n\n- **isolationLevel** - Controls the locking and row versioning behavior of TSQL statements issued by a connection. Optional. `READ_COMMITTED` by default. For possible values see `sql.ISOLATION_LEVEL`.\n- **callback(err)** - A callback which is called after transaction has began, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYBEGUN (`TransactionError`) - Transaction has already begun.\n\n---------------------------------------\n\n### commit ([callback])\n\nCommit a transaction.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has committed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.commit(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't commit transaction. There is a request in progress.\n\n---------------------------------------\n\n### rollback ([callback])\n\nRollback a transaction. If the queue isn't empty, all queued requests will be Cancelled and the transaction will be marked as aborted.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after transaction has rolled back, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst transaction = new sql.Transaction()\ntransaction.begin(err => {\n    // ... error checks\n\n    transaction.rollback(err => {\n        // ... error checks\n    })\n})\n```\n\n__Errors__\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n- EREQINPROG (`TransactionError`) - Can't rollback transaction. There is a request in progress.\n\n## Prepared Statement\n\n**IMPORTANT:** always use `PreparedStatement` class to create prepared statements - it ensures that all your executions of prepared statement are executed on one connection. Once you call `prepare`, a single connection is acquired from the connection pool and all subsequent executions are executed exclusively on this connection. After you call `unprepare`, the connection is then released back to the connection pool.\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\n```\n\nIf you omit the connection argument, the global connection is used instead.\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement(/* [pool] */)\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        // release the connection after queries are executed\n        ps.unprepare(err => {\n            // ... error checks\n\n        })\n    })\n})\n```\n\n**IMPORTANT**: Remember that each prepared statement means one reserved connection from the pool. Don't forget to unprepare a prepared statement when you've finished your queries!\n\nYou can execute multiple queries against the same prepared statement but you *must* unprepare the statement when you have finished using it otherwise you will cause the connection pool to run out of available connections.\n\n**TIP**: You can also create prepared statements in transactions (`new sql.PreparedStatement(transaction)`), but keep in mind you can't execute other requests in the transaction until you call `unprepare`.\n\n---------------------------------------\n\n### input (name, type)\n\nAdd an input parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the input parameter without @ char.\n- **type** - SQL data type of input parameter.\n\n__Example__\n\n```javascript\nps.input('input_parameter', sql.Int)\nps.input('input_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### output (name, type)\n\nAdd an output parameter to the prepared statement.\n\n__Arguments__\n\n- **name** - Name of the output parameter without @ char.\n- **type** - SQL data type of output parameter.\n\n__Example__\n\n```javascript\nps.output('output_parameter', sql.Int)\nps.output('output_parameter', sql.VarChar(50))\n```\n\n__Errors__ (synchronous)\n- EARGS (`PreparedStatementError`) - Invalid number of arguments.\n- EINJECT (`PreparedStatementError`) - SQL injection warning.\n\n---------------------------------------\n\n### prepare (statement, [callback])\n\nPrepare a statement.\n\n__Arguments__\n\n- **statement** - T-SQL statement to prepare.\n- **callback(err)** - A callback which is called after preparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.prepare('select @param as value', err => {\n    // ... error checks\n})\n```\n\n__Errors__\n- ENOTOPEN (`ConnectionError`) - Connection not yet open.\n- EALREADYPREPARED (`PreparedStatementError`) - Statement is already prepared.\n- ENOTBEGUN (`TransactionError`) - Transaction has not begun.\n\n---------------------------------------\n\n### execute (values, [callback])\n\nExecute a prepared statement.\n\n__Arguments__\n\n- **values** - An object whose names correspond to the names of parameters that were added to the prepared statement before it was prepared.\n- **callback(err)** - A callback which is called after execution has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.execute({param: 12345}, (err, result) => {\n        // ... error checks\n\n        console.log(result.recordset[0].value) // return 12345\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n\n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\nYou can also stream executed request.\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.stream = true\n    const request = ps.execute({param: 12345})\n\n    request.on('recordset', columns => {\n        // Emitted once for each recordset in a query\n    })\n\n    request.on('row', row => {\n        // Emitted for each row in a recordset\n    })\n\n    request.on('error', err => {\n        // May be emitted multiple times\n    })\n\n    request.on('done', result => {\n        // Always emitted as the last one\n\n        console.log(result.rowsAffected) // Returns number of affected rows in case of INSERT, UPDATE or DELETE statement.\n\n        ps.unprepare(err => {\n            // ... error checks\n        })\n    })\n})\n```\n\n**TIP**: To learn more about how number of affected rows works, see section [Affected Rows](#affected-rows).\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n- ETIMEOUT (`RequestError`) - Request timeout.\n- EREQUEST (`RequestError`) - *Message from SQL Server*\n- ECANCEL (`RequestError`) - Cancelled.\n\n---------------------------------------\n\n### unprepare ([callback])\n\nUnprepare a prepared statement.\n\n__Arguments__\n\n- **callback(err)** - A callback which is called after unpreparation has completed, or an error has occurred. Optional. If omitted, returns [Promise](#promises).\n\n__Example__\n\n```javascript\nconst ps = new sql.PreparedStatement()\nps.input('param', sql.Int)\nps.prepare('select @param as value', err => {\n    // ... error checks\n\n    ps.unprepare(err => {\n        // ... error checks\n\n    })\n})\n```\n\n__Errors__\n- ENOTPREPARED (`PreparedStatementError`) - Statement is not prepared.\n\n## CLI\n\nIf you want to add the MSSQL CLI tool to your path, you must install it globally with `npm install -g mssql`.\n\n__Setup__\n\nCreate a `.mssql.json` configuration file (anywhere). Structure of the file is the same as the standard configuration object.\n\n```json\n{\n    \"user\": \"...\",\n    \"password\": \"...\",\n    \"server\": \"localhost\",\n    \"database\": \"...\"\n}\n```\n\n__Example__\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}]]\n```\n\nYou can also query for multiple recordsets.\n\n```shell\necho \"select * from mytable; select * from myothertable\" | mssql\n```\nResults in:\n```json\n[[{\"username\":\"patriksimek\",\"password\":\"tooeasy\"}],[{\"id\":15,\"name\":\"Product name\"}]]\n```\n\nIf you omit config path argument, mssql will try to load it from current working directory.\n\n__Overriding config settings__\n\nYou can override some config settings via CLI options (`--user`, `--password`, `--server`, `--database`, `--port`).\n\n```shell\necho \"select * from mytable\" | mssql /path/to/config --database anotherdatabase\n```\nResults in:\n```json\n[[{\"username\":\"onotheruser\",\"password\":\"quiteeasy\"}]]\n```\n\n## Geography and Geometry\n\nnode-mssql has built-in deserializer for Geography and Geometry CLR data types.\n\n### Geography\n\nGeography types can be constructed several different ways. Refer carefully to documentation to verify the coordinate ordering; the ST methods tend to order parameters as longitude (x) then latitude (y), while custom CLR methods tend to prefer to order them as latitude (y) then longitude (x).\n\nThe query:\n\n```sql\nselect geography::STGeomFromText(N'POLYGON((1 1, 3 1, 3 1, 1 1))',4326)\n```\n\nresults in:\n\n```javascript\n{\n  srid: 4326,\n  version: 2,\n  points: [\n    Point { lat: 1, lng: 1, z: null, m: null },\n    Point { lat: 1, lng: 3, z: null, m: null },\n    Point { lat: 1, lng: 3, z: null, m: null },\n    Point { lat: 1, lng: 1, z: null, m: null }\n  ],\n  figures: [ { attribute: 1, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 3 } ],\n  segments: []\n}\n```\n\n**NOTE:** You will also see `x` and `y` coordinates in parsed Geography points,\nthey are not recommended for use. They have thus been omitted from this example.\nFor compatibility, they remain flipped (x, the horizontal offset, is instead used for latitude, the vertical), and thus risk misleading you.\nPrefer instead to use the `lat` and `lng` properties.\n\n### Geometry\n\nGeometry types can also be constructed in several ways. Unlike Geographies, they are consistent in always placing x before y. node-mssql decodes the result of this query:\n\n```sql\nselect geometry::STGeomFromText(N'POLYGON((1 1, 3 1, 3 7, 1 1))',4326)\n```\n\ninto the JavaScript object:\n\n```javascript\n{\n  srid: 4326,\n  version: 1,\n  points: [\n    Point { x: 1, y: 1, z: null, m: null },\n    Point { x: 1, y: 3, z: null, m: null },\n    Point { x: 7, y: 3, z: null, m: null },\n    Point { x: 1, y: 1, z: null, m: null }\n  ],\n  figures: [ { attribute: 2, pointOffset: 0 } ],\n  shapes: [ { parentOffset: -1, figureOffset: 0, type: 3 } ],\n  segments: []\n}\n```\n\n## Table-Valued Parameter (TVP)\n\nSupported on SQL Server 2008 and later. You can pass a data table as a parameter to stored procedure. First, we have to create custom type in our database.\n\n```sql\nCREATE TYPE TestType AS TABLE ( a VARCHAR(50), b INT );\n```\n\nNext we will need a stored procedure.\n\n```sql\nCREATE PROCEDURE MyCustomStoredProcedure (@tvp TestType readonly) AS SELECT * FROM @tvp\n```\n\nNow let's go back to our Node.js app.\n\n```javascript\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\n```\n\nYou can send table as a parameter to stored procedure.\n\n```javascript\nconst request = new sql.Request()\nrequest.input('tvp', tvp)\nrequest.execute('MyCustomStoredProcedure', (err, result) => {\n    // ... error checks\n\n    console.dir(result.recordsets[0][0]) // {a: 'hello tvp', b: 777}\n})\n```\n\n**TIP**: You can also create Table variable from any recordset with `recordset.toTable()`. You can optionally specify table type name in the first argument.\n\nYou can clear the table rows for easier batching by using `table.rows.clear()`\n\n```js\nconst tvp = new sql.Table() // You can optionally specify table type name in the first argument.\n\n// Columns must correspond with type we have created in database.\ntvp.columns.add('a', sql.VarChar(50))\ntvp.columns.add('b', sql.Int)\n\n// Add rows\ntvp.rows.add('hello tvp', 777) // Values are in same order as columns.\ntvp.rows.clear()\n```\n\n## Response Schema\n\nAn object returned from a `sucessful` basic query would look like the following.\n```javascript\n{\n\trecordsets: [\n\t\t[\n\t\t\t{\n\t\t\t\tCOL1: \"some content\",\n\t\t\t\tCOL2: \"some more content\"\n\t\t\t}\n\t\t]\n\t],\n\trecordset: [\n\t\t{\n\t\t\tCOL1: \"some content\",\n\t\t\tCOL2: \"some more content\"\n\t\t}\n\t],\n\toutput: {},\n\trowsAffected: [1]\n}\n\n```\n\n## Affected Rows\n\nIf you're performing `INSERT`, `UPDATE` or `DELETE` in a query, you can read number of affected rows. The `rowsAffected` variable is an array of numbers. Each number represents number of affected rows by a single statement.\n\n__Example using Promises__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100').then(result => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using callbacks__\n\n```javascript\nconst request = new sql.Request()\nrequest.query('update myAwesomeTable set awesomness = 100', (err, result) => {\n    console.log(result.rowsAffected)\n})\n```\n\n__Example using streaming__\n\nIn addition to the rowsAffected attribute on the done event, each statement will emit the number of affected rows as it is completed.\n\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query('update myAwesomeTable set awesomness = 100')\nrequest.on('rowsaffected', rowCount => {\n    console.log(rowCount)\n})\nrequest.on('done', result => {\n    console.log(result.rowsAffected)\n})\n```\n\n## JSON support\n\nSQL Server 2016 introduced built-in JSON serialization. By default, JSON is returned as a plain text in a special column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B`.\n\nExample\n```sql\nSELECT\n    1 AS 'a.b.c',\n    2 AS 'a.b.d',\n    3 AS 'a.x',\n    4 AS 'a.y'\nFOR JSON PATH\n```\n\nResults in:\n```javascript\nrecordset = [ { 'JSON_F52E2B61-18A1-11d1-B105-00805F49916B': '{\"a\":{\"b\":{\"c\":1,\"d\":2},\"x\":3,\"y\":4}}' } ]\n```\n\nYou can enable built-in JSON parser with `config.parseJSON = true`. Once you enable this, recordset will contain rows of parsed JS objects. Given the same example, result will look like this:\n```javascript\nrecordset = [ { a: { b: { c: 1, d: 2 }, x: 3, y: 4 } } ]\n```\n\n**IMPORTANT**: In order for this to work, there must be exactly one column named `JSON_F52E2B61-18A1-11d1-B105-00805F49916B` in the recordset.\n\nMore information about JSON support can be found in [official documentation](https://msdn.microsoft.com/en-us/library/dn921882.aspx).\n\n## Handling Duplicate Column Names\n\nIf your queries contain output columns with identical names, the default behaviour of `mssql` will only return column metadata for the last column with that name. You will also not always be able to re-assemble the order of output columns requested.\n\nDefault behaviour:\n```javascript\nconst request = new sql.Request()\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\nResults in:\n```javascript\n{\n  recordsets: [\n    [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ]\n  ],\n  recordset: [ { name: [ 'asdf', 'jkl' ], other_name: 'qwerty' } ],\n  output: {},\n  rowsAffected: [ 1 ]\n}\n```\n\nYou can use the `arrayRowMode` configuration parameter to return the row values as arrays and add a separate array of column values. `arrayRowMode` can be set globally during the initial connection, or per-request.\n\n```javascript\nconst request = new sql.Request()\nrequest.arrayRowMode = true\nrequest\n    .query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n    .then(result => {\n        console.log(result)\n    });\n```\n\nResults in:\n```javascript\n{\n  recordsets: [ [ [ 'asdf', 'qwerty', 'jkl' ] ] ],\n  recordset: [ [ 'asdf', 'qwerty', 'jkl' ] ],\n  output: {},\n  rowsAffected: [ 1 ],\n  columns: [\n    [\n      {\n        index: 0,\n        name: 'name',\n        length: 4,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 1,\n        name: 'other_name',\n        length: 6,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      },\n      {\n        index: 2,\n        name: 'name',\n        length: 3,\n        type: [sql.VarChar],\n        scale: undefined,\n        precision: undefined,\n        nullable: false,\n        caseSensitive: false,\n        identity: false,\n        readOnly: true\n      }\n    ]\n  ]\n}\n```\n\n__Streaming Duplicate Column Names__\n\nWhen using `arrayRowMode` with `stream` enabled, the output from the `recordset` event (as described in [Streaming](#streaming)) is returned as an array of column metadata, instead of as a keyed object. The order of the column metadata provided by the `recordset` event will match the order of row values when `arrayRowMode` is enabled.\n\nDefault behaviour (without `arrayRowMode`):\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\n\nResults in:\n\n```javascript\n{\n  name: {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  other_name: {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n}\n```\n\nWith `arrayRowMode`:\n```javascript\nconst request = new sql.Request()\nrequest.stream = true\nrequest.arrayRowMode = true\nrequest.query(\"select 'asdf' as name, 'qwerty' as other_name, 'jkl' as name\")\n\nrequest.on('recordset', recordset => console.log(recordset))\n```\n\nResults in:\n```javascript\n[\n  {\n    index: 0,\n    name: 'name',\n    length: 4,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 1,\n    name: 'other_name',\n    length: 6,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  },\n  {\n    index: 2,\n    name: 'name',\n    length: 3,\n    type: [sql.VarChar],\n    scale: undefined,\n    precision: undefined,\n    nullable: false,\n    caseSensitive: false,\n    identity: false,\n    readOnly: true\n  }\n]\n```\n\n## Errors\n\nThere are 4 types of errors you can handle:\n\n- **ConnectionError** - Errors related to connections and connection pool.\n- **TransactionError** - Errors related to creating, committing and rolling back transactions.\n- **RequestError** - Errors related to queries and stored procedures execution.\n- **PreparedStatementError** - Errors related to prepared statements.\n\nThose errors are initialized in node-mssql module and its original stack may be cropped. You can always access original error with `err.originalError`.\n\nSQL Server may generate more than one error for one request so you can access preceding errors with `err.precedingErrors`.\n\n### Error Codes\n\nEach known error has `name`, `code` and `message` properties.\n\nName | Code | Message\n:--- | :--- | :---\n`ConnectionError` | ELOGIN | Login failed.\n`ConnectionError` | ETIMEOUT | Connection timeout.\n`ConnectionError` | EDRIVER | Unknown driver.\n`ConnectionError` | EALREADYCONNECTED | Database is already connected!\n`ConnectionError` | EALREADYCONNECTING | Already connecting to database!\n`ConnectionError` | ENOTOPEN | Connection not yet open.\n`ConnectionError` | EINSTLOOKUP | Instance lookup failed.\n`ConnectionError` | ESOCKET | Socket error.\n`ConnectionError` | ECONNCLOSED | Connection is closed.\n`TransactionError` | ENOTBEGUN | Transaction has not begun.\n`TransactionError` | EALREADYBEGUN | Transaction has already begun.\n`TransactionError` | EREQINPROG | Can't commit/rollback transaction. There is a request in progress.\n`TransactionError` | EABORT | Transaction has been aborted.\n`RequestError` | EREQUEST | Message from SQL Server. Error object contains additional details.\n`RequestError` | ECANCEL | Cancelled.\n`RequestError` | ETIMEOUT | Request timeout.\n`RequestError` | EARGS | Invalid number of arguments.\n`RequestError` | EINJECT | SQL injection warning.\n`RequestError` | ENOCONN | No connection is specified for that request.\n`PreparedStatementError` | EARGS | Invalid number of arguments.\n`PreparedStatementError` | EINJECT | SQL injection warning.\n`PreparedStatementError` | EALREADYPREPARED | Statement is already prepared.\n`PreparedStatementError` | ENOTPREPARED | Statement is not prepared.\n\n### Detailed SQL Errors\n\nSQL errors (`RequestError` with `err.code` equal to `EREQUEST`) contains additional details.\n\n- **err.number** - The error number.\n- **err.state** - The error state, used as a modifier to the number.\n- **err.class** - The class (severity) of the error. A class of less than 10 indicates an informational message. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **err.lineNumber** - The line number in the SQL batch or stored procedure that caused the error. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **err.serverName** - The server name.\n- **err.procName** - The stored procedure name.\n\n## Informational messages\n\nTo receive informational messages generated by `PRINT` or `RAISERROR` commands use:\n\n```javascript\nconst request = new sql.Request()\nrequest.on('info', info => {\n    console.dir(info)\n})\nrequest.query('print \\'Hello world.\\';', (err, result) => {\n    // ...\n})\n```\n\nStructure of informational message:\n\n- **info.message** - Message.\n- **info.number** - The message number.\n- **info.state** - The message state, used as a modifier to the number.\n- **info.class** - The class (severity) of the message. Equal or lower than 10. Detailed explanation can be found [here](https://msdn.microsoft.com/en-us/library/dd304156.aspx).\n- **info.lineNumber** - The line number in the SQL batch or stored procedure that generated the message. Line numbers begin at 1; therefore, if the line number is not applicable to the message, the value of LineNumber will be 0.\n- **info.serverName** - The server name.\n- **info.procName** - The stored procedure name.\n\n## Metadata\n\nRecordset metadata are accessible through the `recordset.columns` property.\n\n```javascript\nconst request = new sql.Request()\nrequest.query('select convert(decimal(18, 4), 1) as first, \\'asdf\\' as second', (err, result) => {\n    console.dir(result.recordset.columns)\n\n    console.log(result.recordset.columns.first.type === sql.Decimal) // true\n    console.log(result.recordset.columns.second.type === sql.VarChar) // true\n})\n```\n\nColumns structure for example above:\n\n```javascript\n{\n    first: {\n        index: 0,\n        na","readmeFilename":"README.md","users":{"td3":true,"anvk":true,"cfen":true,"cisc":true,"isik":true,"kpax":true,"anpdx":true,"ffphp":true,"m1k3y":true,"sjnnr":true,"subas":true,"yvesg":true,"aireol":true,"figroc":true,"flpamr":true,"hubbly":true,"knoja4":true,"mjaric":true,"noodie":true,"partap":true,"sako73":true,"tarcio":true,"thorn0":true,"tjwebb":true,"zerodi":true,"zhoutk":true,"zlatip":true,"andreiu":true,"aslezak":true,"astesio":true,"atomgao":true,"awangxh":true,"benoror":true,"bruno.m":true,"edision":true,"ekelvin":true,"gztomas":true,"hulio21":true,"isaac95":true,"jesus81":true,"lvivier":true,"mikepol":true,"morehao":true,"rickkky":true,"shivayl":true,"siirial":true,"springy":true,"sunfork":true,"ungurys":true,"xfloops":true,"zenrumi":true,"bugkarma":true,"bvelas77":true,"d.barros":true,"damianof":true,"elosoman":true,"faraoman":true,"geooogle":true,"guywicks":true,"hobbit71":true,"jiyardev":true,"jonathas":true,"jonkoala":true,"keynside":true,"kistoryg":true,"mikemena":true,"rizowski":true,"ryuslunk":true,"sappharx":true,"trendoid":true,"wattanar":true,"alykoshin":true,"claudio76":true,"deadcoder":true,"deepgoing":true,"devmoreno":true,"dockawash":true,"felixpang":true,"guzgarcia":true,"jasoncmcg":true,"johnmanko":true,"milfromoz":true,"nkudupudi":true,"sbvonline":true,"snowdream":true,"superhans":true,"tomgao365":true,"tonikhil1":true,"wander_lp":true,"brainpoint":true,"cescnguyen":true,"cybortibor":true,"dericdavis":true,"donvercety":true,"f124275809":true,"isaacvitor":true,"jasonevrtt":true,"justinshea":true,"kenjisan4u":true,"krishaamer":true,"leizongmin":true,"mcpshiming":true,"narunarthy":true,"nerdybeast":true,"rh-dcawley":true,"shahnawazk":true,"tiagobraga":true,"baipgydx729":true,"coolhanddev":true,"craigpatten":true,"dangerdroid":true,"eserozvataf":true,"fernandezja":true,"flumpus-dev":true,"jamesbender":true,"knownasilya":true,"danielmilner":true,"ivan.marquez":true,"jabedhasan21":true,"johnny.young":true,"leothelocust":true,"ramalvakonda":true,"silverbeetle":true,"tchiagoneses":true,"gamersdelight":true,"jamesbjackson":true,"kirangopaluni":true,"danieljameskay":true,"leonardothibes":true,"michjewastaken":true,"paul.bastowski":true,"joaquin.briceno":true,"jeffersonaguilar":true,"scott.m.sarsfield":true}}